#include "data.h"

#include "print.h"

const std::string dll = "DLL_EXPORT";
const std::string dataClassPtr = "IdPtr";
const std::string storageImpl = "StorageImpl";
const std::string iObject = "IObjectBase";
const std::string idAccess = ".id";
const std::string String = "String";
const std::string containerAccess = "->";

std::string tr(std::string s)
{
    return "QCoreApplication::translate(\"DB\", \"" + s + "\")";
}

std::string trUE4(std::string s)
{
    // #define USE_UNREAL_EDITOR
    // #define LOCTEXT_NAMESPACE "DBTool"
    return "LOCTEXT(\"DB\", \"" + s + "\")";
}

std::string ctableType(const std::string &s)
{
    return "CTable<" + s + ">";
}

std::string arrayType(const std::string &s)
{
    return "Ptr<" + ctableType(s) + ">";
}

std::string splitWords(std::string s)
{
    std::string r;
    for (size_t i = 0; i < s.size(); i++)
    {
        if (isupper(s[i]) && i)
            r += " ";
        r += s[i];
    }
    return r;
}

template<typename T, typename K>
std::set<T> mapToSet(const std::map<K, T> &map)
{
    std::set<T> s;
    for (auto &v : map)
        s.insert(v.second);
    return s;
}

DataType dataTypeFromName(const Name &name)
{
    if (name == "int" ||
        name == "int32_t" ||
        name == "uint32_t" ||
        name.find("int") != Name::npos)
        return DataType::Integer;
    if (name == "float" || name.find("double") != Name::npos)
        return DataType::Real;
    if (name == "bool")
        return DataType::Bool;
    if (name == "Text")
        return DataType::Text;
    if (name == "Blob")
        return DataType::Blob;
    return DataType::Complex;
}

std::string dataTypeToSqlite3(DataType t)
{
    std::string s;
    switch (t)
    {
    case DataType::Integer:
    case DataType::Complex:
    case DataType::Bool:
        s += "INTEGER";
        break;
    case DataType::Real:
        s += "REAL";
        break;
    case DataType::Text:
        s += "TEXT";
        break;
    case DataType::Blob:
        s += "BLOB";
        break;
    }
    return s;
}

Schema convert(const ast::Schema &ast)
{
    Schema s;
    std::unordered_map<Name, const ast::Class*> astClasses;

    auto find_type = [ast](Name name)
    {
        while (1)
        {
            auto i = ast.types.find(name);
            if (i == ast.types.end() || name == i->second)
                break;
            name = i->second;
        }
        return name;
    };

    //
    s.version = ast.version;
    for (auto &t : ast.types)
    {
        Type type;
        type.name = find_type(t.second);
        type.dataType = dataTypeFromName(type.name);
        s.types.insert(type);
    }
    for (auto &c : ast.classes)
    {
        Class class_;
        class_.name = c.name;
        class_.humanName = c.getHumanName();
        class_.enumName = c.getEnumName();
        class_.dataType = dataTypeFromName(c.name);
        auto no = c.getNamesOrder();
        if (!no.empty())
            class_.namesOrder = no;
        class_.objectName = c.getObjectName();
        class_.setFlags(c.flags());
        s.classes.push_back(class_);
    }
    for (auto &d : ast.databases)
    {
        Database db;
        db.name = d.name;
        for (auto &t : d.types)
        {
            Type type;
            type.name = find_type(t.second);
            type.dataType = dataTypeFromName(type.name);
            db.types.insert(type);
        }
        s.databases.push_back(db);
    }

    // create pointers
    for (auto &t : ast.types)
    {
        auto i = std::find_if(s.types.begin(), s.types.end(), [n = find_type(t.second)](const auto &t)
            { return t.name == n; });
        s.typePtrs[t.second] = const_cast<Type *>(&*i);
    }
    for (auto &c : ast.classes)
    {
        s.typePtrs[c.name] = &s.getClass(c.name);
        astClasses[c.name] = &c;
    }

    // init variables
    for (auto &c : s.classes)
    {
        auto &ac = *astClasses[c.name];
        auto pn = ac.getParentName();
        if (!pn.empty())
        {
            auto i = s.typePtrs.find(pn);
            assert(i != s.typePtrs.end());
            c.parent = (Class *)i->second;
            c.parent->children.push_back(&c);
        }
        for (auto &av : ac.variables)
        {
            Variable v;
            v.id = av.id;
            v.name = av.name;
            v.defaultValue = av.defaultValue;
            auto tn = find_type(av.type);
            auto t = s.typePtrs.find(tn);
            assert(t != s.typePtrs.end());
            v.type = s.typePtrs[tn];
            v.flags = av.flags();
            c.addVariable(v);
        }
    }

    return s;
}

ModuleContext Schema::printObjectTypes() const
{
    ModuleContext mc;
    mc.hpp.addLine(autogenerated_warning);
    mc.hpp.addLine();
    mc.hpp.addLine(pragma_once);
    mc.hpp.addLine();
    mc.hpp.beginNamespace("polygon4");
    mc.hpp.beginNamespace("detail");
    mc.hpp.beginBlock("enum class EObjectType : EnumType");
    for (auto &c : classes({ fInline }, true))
        mc.hpp.addLine(c.getCppName() + ",");
    mc.hpp.endBlock(true);
    mc.hpp.addLine();
    mc.hpp.endNamespace();
    mc.hpp.addLine();
    mc.hpp.endNamespace();
    return mc;
}

ModuleContext Schema::printHelpers() const
{
    ModuleContext mc;
    mc.hpp.addLine(autogenerated_warning);
    mc.hpp.addLine();
    mc.hpp.addLine(pragma_once);
    mc.hpp.addLine();

    mc.cpp.addLine(autogenerated_warning);
    mc.cpp.addLine();

    // getTableType()
    {
        mc.hpp.addLine("" + dll + " EObjectType getTableType(const std::string &table);");

        mc.cpp.addLine("std::map<std::string, EObjectType> types =");
        mc.cpp.beginBlock();
        for (auto &c : classes({ fInline }, true))
            mc.cpp.addLine("{ \"" + c.getSqlName() + "\", EObjectType::" + c.getCppName() + " },");
        mc.cpp.endBlock(true);
        mc.cpp.addLine();
        mc.cpp.beginFunction("EObjectType getTableType(const std::string &table)");
        mc.cpp.addLine("return types[table];");
        mc.cpp.endFunction();
    }

    // getTableNameByType()
    {
        mc.hpp.addLine("" + dll + " Text getTableNameByType(EObjectType type);");

        mc.cpp.addLine("std::map<EObjectType, Text> tables =");
        mc.cpp.beginBlock();
        for (auto &c : classes({ fInline }, true))
            mc.cpp.addLine("{ EObjectType::" + c.getCppName() + ", \"" + c.getSqlName() + "\" },");
        mc.cpp.endBlock(true);
        mc.cpp.addLine();
        mc.cpp.beginFunction("Text getTableNameByType(EObjectType type)");
        mc.cpp.addLine("return tables[type];");
        mc.cpp.endFunction();
    }

    // qt
    {
        mc.hpp.addLine();
        mc.hpp.addLineNoSpace("#ifdef USE_QT");
        mc.cpp.addLineNoSpace("#ifdef USE_QT");

        // retranslateFieldNames()
        {
            mc.hpp.addLine("void retranslateFieldNames();");

            mc.cpp.addLine("typedef std::map<std::string, QString> FieldNames;");
            mc.cpp.addLine();
            mc.cpp.addLine("FieldNames fieldNames;");
            mc.cpp.addLine();
            mc.cpp.beginFunction("void retranslateFieldNames()");
            mc.cpp.addLine("FieldNames names =");
            mc.cpp.beginBlock();
            std::set<Variable> vars;
            for (auto &c : classes)
                for (auto &v : c.getVariables())
                    vars.insert(v);
            for (auto &v : vars)
            {
                mc.cpp.addLine("{ \"" + v.getSqlName() + "\", " + tr(v.getName()) + " },");
            }
            mc.cpp.endBlock(true);
            mc.cpp.addLine("fieldNames = names;");
            mc.cpp.endFunction();
        }

        // getFieldName()
        {
            mc.hpp.addLine("QString getFieldName(const std::string &name);");

            mc.cpp.beginFunction("QString getFieldName(const std::string &name)");
            mc.cpp.addLine("return fieldNames[name];");
            mc.cpp.endFunction();
        }

        // retranslateTableNames()
        {
            mc.hpp.addLine("void retranslateTableNames();");

            mc.cpp.addLine("typedef std::map<std::string, QString> TableNames;");
            mc.cpp.addLine();
            mc.cpp.addLine("TableNames tableNames;");
            mc.cpp.addLine();
            mc.cpp.beginFunction("void retranslateTableNames()");
            mc.cpp.addLine("TableNames names =");
            mc.cpp.beginBlock();
            for (auto &c : classes({ fInline }, true))
                mc.cpp.addLine("{ \"" + c.getName() + "\", " + tr(splitWords(c.getHumanName())) + " },");
            mc.cpp.endBlock(true);
            mc.cpp.addLine("tableNames = names;");
            mc.cpp.endFunction();
        }

        // getTableName()
        {
            mc.hpp.addLine("QString getTableName(const std::string &name);");

            mc.cpp.beginFunction("QString getTableName(const std::string &name)");
            mc.cpp.addLine("return tableNames[name];");
            mc.cpp.endFunction();
        }

        mc.hpp.addLineNoSpace("#endif");
        mc.cpp.addLineNoSpace("#endif");
    }

    return mc;
}

ModuleContext Schema::printObjectInterfaces() const
{
    ModuleContext mc;
    mc.hpp.addLine(autogenerated_warning);
    mc.hpp.addLine();
    mc.hpp.addLine(pragma_once);
    mc.hpp.addLine();
    mc.hpp.beginNamespace("polygon4");
    for (auto &c : getClasses())
    {
        auto name = c.getCppName();
        auto nameUpper = name;
        std::transform(name.begin(), name.end(), nameUpper.begin(), ::toupper);
        mc.hpp.addLineNoSpace("#ifndef POLYGON4_" + nameUpper + "_INTERFACE");
        mc.hpp.addLineNoSpace("DECLARE_INTERFACE_STUB(" + name + ");");
        mc.hpp.addLineNoSpace("#endif");
        mc.hpp.addLine();
    }
    mc.hpp.endNamespace();
    return mc;
}

ModuleContext Schema::printTypes() const
{
    auto cls_ = getClasses();
    std::vector<Class> cls(cls_.begin(), cls_.end());

    ModuleContext mc;
    mc.hpp.addLine(autogenerated_warning);
    mc.hpp.addLine();
    mc.hpp.addLine(pragma_once);
    mc.hpp.addLine();
    mc.hpp.beginNamespace("polygon4");
    mc.hpp.beginNamespace("detail");
    for (auto &c : cls)
        mc.hpp.addLine("class " + c.getCppName() + ";");
    mc.hpp.addLine();

    mc.cpp.addLine(autogenerated_warning);
    mc.cpp.addLine();
    for (auto &c : cls)
        mc += c.print();

    mc.hpp.endNamespace();
    mc.hpp.addLine();
    mc.hpp.endNamespace();
    return mc;
}

ModuleContext Schema::printStorage() const
{
    const auto cls = getClasses();

    ModuleContext mc;
    mc.hpp.addLine(autogenerated_warning);
    mc.hpp.addLine();
    mc.hpp.addLine(pragma_once);
    mc.hpp.addLine();
    mc.hpp.beginBlock("class Storage");
    mc.hpp.addLineNoSpace("public:");
    for (auto &c : cls)
        mc.hpp.addLine(ctableType(c.getCppName()) + " " + c.getCppArrayVariableName() + ";");
    mc.hpp.addLine();
    mc.hpp.addLineNoSpace("public:");
    mc.hpp.addLine("Storage();");
    mc.hpp.addLine("virtual ~Storage();");
    mc.hpp.addLine();
    mc.hpp.addLine("virtual void create() const = 0;");
    mc.hpp.addLine("virtual void clear() = 0;");
    mc.hpp.addLine("virtual void load(ProgressCallback callback = ProgressCallback()) = 0;");
    mc.hpp.addLine("virtual void save(ProgressCallback callback = ProgressCallback()) const = 0;");
    mc.hpp.addLine();
    mc.hpp.addLine("virtual Ptr<TreeItem> printTree() const = 0;");
    mc.hpp.addLine("virtual Ptr<TreeItem> addRecord(TreeItem *item) = 0;");
    mc.hpp.addLine("virtual void deleteRecord(TreeItem *item) = 0;");
    mc.hpp.addLine();
    mc.hpp.addLine("virtual OrderedObjectMap getOrderedMap(EObjectType type, std::function<bool(" + iObject + " *)> f = std::function<bool(" + iObject + " *)>()) const = 0;");
    mc.hpp.addLine();

    // printAddDeleteRecordVirtual()
    {
        for (auto &c : cls)
            mc += c.printAddDeleteRecordVirtual();
        mc.hpp.addLine();
        mc.hpp.addLine("virtual " + dataClassPtr + "<" + iObject + "> addRecord(" + iObject + " *parent = nullptr) = 0;");
        mc.hpp.addLine("virtual void deleteRecord(" + iObject + " *data) = 0;");
    }
    mc.hpp.endBlock(true);

    mc.cpp.addLine(autogenerated_warning);
    mc.cpp.addLine();
    mc.cpp.beginFunction("Storage::Storage()");
    for (auto &c : cls)
        mc.cpp.addLine(c.getCppArrayVariableName() + ".setName(\"" + c.getCppName() + "\");");
    mc.cpp.endFunction();
    mc.cpp.beginFunction("Storage::~Storage()");
    mc.cpp.endBlock();
    return mc;
}

ModuleContext Schema::printStorageImplementation() const
{
    const auto cls = getClasses();

    ModuleContext mc;
    mc.hpp.addLine(autogenerated_warning);
    mc.hpp.addLine();
    mc.hpp.addLine(pragma_once);
    mc.hpp.addLine();
    mc.hpp.beginFunction("class StorageImpl : public Storage");
    mc.hpp.addLineNoSpace("#ifdef USE_QT");
    mc.hpp.addLine("Q_DECLARE_TR_FUNCTIONS(StorageImpl)");
    mc.hpp.addLineNoSpace("#endif");
    mc.hpp.addLine();
    mc.hpp.addLineNoSpace("private:");
    mc.hpp.addLine("std::shared_ptr<Database> db;");
    mc.hpp.addLine();
    mc.hpp.addLineNoSpace("private:");

    mc.cpp.addLine(autogenerated_warning);
    mc.cpp.addLine();
    for (auto &c : cls)
    {
        mc += c.printIo();
        mc.hpp.addLine();
    }

    mc.hpp.addLineNoSpace("public:");
    mc.hpp.addLine("StorageImpl(std::shared_ptr<Database> db) : db(db) {}");
    mc.hpp.addLine();
    mc.hpp.addLine("void setDb(std::shared_ptr<Database> db) { this->db = db; }");
    mc.hpp.addLine();

    // create()
    {
        mc.hpp.addLine("virtual void create() const override;");

        mc.cpp.beginFunction("void " + storageImpl + "::create() const");
        for (auto &c : cls)
            mc.cpp.addLine("db->execute(" + c.getCppName() + "::getSql()" + ");");
        mc.cpp.endFunction();
    }

    // clear()
    {
        mc.hpp.addLine("virtual void clear() override;");

        mc.cpp.beginFunction("void " + storageImpl + "::clear()");
        for (auto &c : cls)
            mc.cpp.addLine(c.getCppArrayVariableName() + ".clear();");
        mc.cpp.endFunction();
    }

    // load()
    {
        double step = 100.0 / (cls.size() * 3.0);
        double progress = 0;

        mc.hpp.addLine("virtual void load(ProgressCallback callback = ProgressCallback()) override;");

        mc.cpp.beginFunction("void " + storageImpl + "::load(ProgressCallback callback)");
        for (auto &c : cls)
        {
            mc.cpp.addLine("_load" + c.getSqlName() + "();");
            mc.cpp.addLine("PROGRESS_CALLBACK(" + std::to_string(progress += step) + ");");
        }
        mc.cpp.addLine();
        for (auto &c : cls)
        {
            mc.cpp.addLine("_load" + c.getSqlName() + "Ptrs();");
            mc.cpp.addLine("PROGRESS_CALLBACK(" + std::to_string(progress += step) + ");");
        }
        mc.cpp.addLine();
        for (auto &c : cls)
        {
            mc.cpp.addLine("_load" + c.getSqlName() + "Arrays();");
            mc.cpp.addLine("PROGRESS_CALLBACK(" + std::to_string(progress += step) + ");");
        }
        mc.cpp.endFunction();
    }

    // save()
    {
        double step = 100.0 / cls.size();
        double progress = 0;

        mc.hpp.addLine("virtual void save(ProgressCallback callback = ProgressCallback()) const override;");

        mc.cpp.beginFunction("void " + storageImpl + "::save(ProgressCallback callback) const");
        for (auto &c : cls)
        {
            mc.cpp.addLine("_save" + c.getSqlName() + "();");
            mc.cpp.addLine("PROGRESS_CALLBACK(" + std::to_string(progress += step) + ");");
        }
        mc.cpp.endFunction();
    }

    // printAddDeleteRecord()
    {
        mc.hpp.addLine();
        for (auto &c : cls)
            mc += c.printAddDeleteRecord();
        mc.hpp.addLine();

        // addRecord()
        {
            mc.hpp.addLine("virtual " + dataClassPtr + "<" + iObject + "> addRecord(" + iObject + " *parent = nullptr) override;");

            mc.cpp.beginFunction("" + dataClassPtr + "<" + iObject + "> " + storageImpl + "::addRecord(" + iObject + " *parent)");
            mc.cpp.addLine("" + dataClassPtr + "<" + iObject + "> p;");
            mc.cpp.addLine("EObjectType type = parent->getType();");
            mc.cpp.beginBlock("switch (type)", false);
            for (auto &c : cls)
            {
                mc.cpp.addLine("case EObjectType::" + c.getCppName() + ":");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("p = add" + c.getCppName() + "(" + (c.getParent() ? "parent" : "") + ");");
                mc.cpp.addLine("break;");
                mc.cpp.decreaseIndent();
            }
            mc.cpp.addLine("default:");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("break;");
            mc.cpp.endBlock();
            mc.cpp.addLine("return p;");
            mc.cpp.endFunction();
        }

        // deleteRecord()
        {
            mc.hpp.addLine("virtual void deleteRecord(" + iObject + " *data) override;");

            mc.cpp.beginFunction("void " + storageImpl + "::deleteRecord(" + iObject + " *data)");
            mc.cpp.addLine("EObjectType type = data->getType();");
            mc.cpp.beginBlock("switch (type)", false);
            for (auto &c : cls)
            {
                mc.cpp.addLine("case EObjectType::" + c.getCppName() + ":");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("delete" + c.getCppName() + "(data);");
                mc.cpp.addLine("break;");
                mc.cpp.decreaseIndent();
            }
            mc.cpp.addLine("default:");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("break;");
            mc.cpp.endBlock();
            mc.cpp.endFunction();
        }
    }

    // printTree()
    {
        mc.hpp.addLine();

        // printTree()
        {
            mc.hpp.addLine("virtual Ptr<TreeItem> printTree() const override;");

            mc.cpp.beginFunction("Ptr<TreeItem> " + storageImpl + "::printTree() const");
            mc.cpp.addLine("Ptr<TreeItem> root = std::make_shared<TreeItem>();");
            mc.cpp.addLine("Ptr<TreeItem> item;");
            mc.cpp.addLine("Ptr<TreeItem> tmp;");
            for (auto &c : cls)
            {
                if (!c.getFlags()[fTreeView])
                    continue;
                mc.cpp.addLine();
                mc.cpp.addLine("item = std::make_shared<TreeItem>();");
                mc.cpp.addLine("item->name = \"" + splitWords(c.getCppArrayName()) + "\";");
                mc.cpp.addLine("item->type = EObjectType::" + c.getCppName() + ";");
                mc.cpp.addLine("item->parent = root.get();");
                mc.cpp.addLine("auto " + c.getCppArrayVariableName() + " = getOrderedMap(EObjectType::" + c.getCppName() + ");");
                mc.cpp.addLine("for (auto &v : " + c.getCppArrayVariableName() + ")");
                mc.cpp.beginBlock();
                mc.cpp.addLine("item->children.push_back(tmp = v.second->printTree());");
                mc.cpp.addLine("tmp->parent = item.get();");
                mc.cpp.endBlock();
                mc.cpp.addLine("root->children.push_back(item);");
            }
            mc.cpp.addLine();
            mc.cpp.addLine("return root;");
            mc.cpp.endFunction();
        }

        // addRecord()
        {
            mc.hpp.addLine("virtual Ptr<TreeItem> addRecord(TreeItem *item) override;");

            mc.cpp.beginFunction("Ptr<TreeItem> " + storageImpl + "::addRecord(TreeItem *item)");
            mc.cpp.addLine("Ptr<TreeItem> tmp;");
            mc.cpp.beginBlock("switch (item->type)", false);
            for (auto &c : cls)
            {
                mc.cpp.addLine("case EObjectType::" + c.getCppName() + ":");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("item->children.push_back(tmp = add" + c.getCppName() + "(" + (c.getParent() ? "item->parent->object" : "") + ")->printTree());");
                mc.cpp.addLine("tmp->parent = item;");
                mc.cpp.addLine("break;");
                mc.cpp.decreaseIndent();
            }
            mc.cpp.addLine("default:");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("break;");
            mc.cpp.endBlock();
            mc.cpp.addLine("return tmp;");
            mc.cpp.endFunction();
        }

        // deleteRecord()
        {
            mc.hpp.addLine("virtual void deleteRecord(TreeItem *item) override;");

            mc.cpp.beginFunction("void " + storageImpl + "::deleteRecord(TreeItem *item)");
            mc.cpp.addLine("if (!item || !item->object)");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return;");
            mc.cpp.decreaseIndent();
            mc.cpp.beginBlock("switch (item->type)", false);
            for (auto &c : cls)
            {
                mc.cpp.addLine("case EObjectType::" + c.getCppName() + ":");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("delete" + c.getCppName() + "(item->object);");
                mc.cpp.addLine("break;");
                mc.cpp.decreaseIndent();
            }
            mc.cpp.addLine("default:");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("break;");
            mc.cpp.endBlock();
            mc.cpp.endBlock();
        }
    }

    // printGetOrderedMap()
    {
        mc.hpp.addLine();
        mc.hpp.addLine("virtual OrderedObjectMap getOrderedMap(EObjectType type, std::function<bool(" + iObject + " *)> f = std::function<bool(" + iObject + " *)>()) const override;");

        mc.cpp.addLine();
        mc.cpp.beginFunction("OrderedObjectMap " + storageImpl + "::getOrderedMap(EObjectType type, std::function<bool(" + iObject + " *)> f) const");
        mc.cpp.beginBlock("switch (type)", false);
        for (auto &c : cls)
        {
            mc.cpp.addLine("case EObjectType::" + c.getCppName() + ":");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return ::getOrderedMap(" + c.getCppArrayVariableName() + ", f);");
            mc.cpp.decreaseIndent();
        }
        mc.cpp.addLine("default:");
        mc.cpp.increaseIndent();
        mc.cpp.addLine("return OrderedObjectMap();");
        mc.cpp.endBlock();
        mc.cpp.endFunction();
    }

    mc.hpp.endBlock(true);
    return mc;
}

ModuleContext Class::print() const
{
    ModuleContext mc;
    const auto vars = getVariables();
    const auto vars_container = getVariables(true);

    // enums
    {
        if (flags[fCreateEnum])
        {
            mc.hpp.beginBlock("enum class " + getEnumName() + " : EnumType");
            for (auto &v : variables)
            {
                if (v.getFlags()[fEnumItem])
                    mc.hpp.addLine(v.getName() + ",");
            }
            mc.hpp.addLine();
            mc.hpp.addLine("max,");
            mc.hpp.endBlock(true);
            mc.hpp.addLine();
        }
    }

    // class
    {
        mc.hpp.beginBlock("class " + dll + " " + getCppName() + " : public I" + getCppName());
        mc.hpp.addLine("// data");
        mc.hpp.addLineNoSpace("public:");
        printVariables(mc);
        mc.hpp.decreaseIndent();
    }

    // containers
    {
        if (!vars_container.empty())
            mc.hpp.addLine();
        mc.hpp.increaseIndent();
        for (auto &v : vars_container)
            mc.hpp.addLine(v.print() + ";");
        mc.hpp.addLine();
    }

    mc.hpp.addLine("// constructors");
    mc.hpp.addLineNoSpace("public:");

    // constructors
    {
        mc.hpp.addLine(getCppName() + "();");
        mc.hpp.addLine(getCppName() + "(const " + getCppName() + " &);");
        mc.hpp.addLine(getCppName() + " &operator=(const " + getCppName() + " &);");
        mc.hpp.addLine(getCppName() + "(" + getCppName() + " &&) = default;");
        mc.hpp.addLine(getCppName() + " &operator=(" + getCppName() + " &&) = default;");
        mc.hpp.addLine("virtual ~" + getCppName() + "();");

        // default ctor
        mc.cpp.beginFunction(getCppName() + "::" + getCppName() + "()");
        for (auto &v : vars_container)
        {
            mc.cpp.addLine(v.getName() + " = std::make_shared<" + ctableType(v.getType()->getCppName()) + ">();");
        }
        mc.cpp.endFunction();

        // copy ctor
        mc.cpp.beginFunction(getCppName() + "::" + getCppName() + "(const " + getCppName() + " &rhs)");
        mc.cpp.addLine("copyFrom(rhs);");
        mc.cpp.endFunction();

        // copy assign
        mc.cpp.beginFunction(getCppName() + " &" + getCppName() + "::operator=(const " + getCppName() + " &rhs)");
        mc.cpp.addLine("copyFrom(rhs);");
        mc.cpp.addLine("return *this;");
        mc.cpp.endFunction();

        // dtor: prevent different destructors for dll and exe
        mc.cpp.beginFunction(getCppName() + "::~" + getCppName() + "()");
        mc.cpp.endFunction();
    }

    mc.hpp.addLine();
    mc.hpp.addLine("// functions");
    mc.hpp.addLineNoSpace("public:");

    // getType()
    {
        mc.hpp.addLine("virtual EObjectType getType() const override;");

        mc.cpp.beginFunction("EObjectType " + getCppName() + "::getType() const");
        mc.cpp.addLine("return object_type;");
        mc.cpp.endFunction();
    }

    // getVariableString()
    {
        mc.hpp.addLine("virtual Text getVariableString(int columnId) const override;");

        mc.cpp.beginFunction("Text " + getCppName() + "::getVariableString(int columnId) const");
        mc.cpp.beginBlock("switch (columnId)", false);
        for (auto &v : vars)
        {
            if (v.getType()->getDataType() == DataType::Blob)
                continue;
            mc.cpp.addLine("case " + std::to_string(v.getId()) + ":");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return to_string(" + v.getName() + ");");
            mc.cpp.decreaseIndent();
        }
        mc.cpp.addLine("default:");
        mc.cpp.increaseIndent();
        mc.cpp.addLine(R"(return "";)");
        mc.cpp.endBlock(true);
        mc.cpp.addLine(R"(return "";)");
        mc.cpp.endFunction();
    }

    // setVariableString()
    {
        mc.hpp.addLine("virtual void setVariableString(int columnId, const Text &text) override;");

        mc.cpp.beginFunction("void " + getCppName() + "::setVariableString(int columnId, const Text &text)");
        mc.cpp.beginBlock("switch (columnId)", false);
        for (auto &v : vars)
        {
            if (v.isFk())
                continue;
            mc.cpp.addLine("case " + std::to_string(v.getId()) + ":");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("this->" + v.printSet() + ";");
            mc.cpp.addLine("break;");
            mc.cpp.decreaseIndent();
        }
        mc.cpp.addLine("default:");
        mc.cpp.increaseIndent();
        mc.cpp.addLine("break;");
        mc.cpp.endBlock(true);
        mc.cpp.endFunction();
    }

    // setVariableString2()
    {
        mc.hpp.addLine("virtual void setVariableString(int columnId, " + iObject + " *ptr) override;");

        mc.cpp.beginFunction("void " + getCppName() + "::setVariableString(int columnId, " + iObject + " *ptr)");
        mc.cpp.beginBlock("switch (columnId)", false);
        for (auto &v : vars)
        {
            if (!v.isFk())
                continue;
            mc.cpp.addLine("case " + std::to_string(v.getId()) + ":");
            mc.cpp.increaseIndent();
            mc.cpp.addLine(v.printSetPtr() + ";");
            mc.cpp.addLine("break;");
            mc.cpp.decreaseIndent();
        }
        mc.cpp.addLine("default:");
        mc.cpp.increaseIndent();
        mc.cpp.addLine("break;");
        mc.cpp.endBlock(true);
        mc.cpp.endFunction();
    }

    // printTree()
    {
        mc.hpp.addLine("virtual Ptr<TreeItem> printTree() const override;");

        mc.cpp.beginFunction("Ptr<TreeItem> " + getCppName() + "::printTree() const");
        if (!vars_container.empty())
        {
            mc.cpp.addLine("auto item = createTreeItem();");
            mc.cpp.addLine();
            mc.cpp.addLine("Ptr<TreeItem> root;");
            mc.cpp.addLine("Ptr<TreeItem> tmp;");
            for (auto &v : vars_container)
            {
                mc.cpp.addLine();
                mc.cpp.addLine("root = std::make_shared<TreeItem>();");
                mc.cpp.addLine("root->name = \"" + splitWords(v.getNameWithCaptitalLetter()) + "\";");
                mc.cpp.addLine("root->type = EObjectType::" + v.getType()->getCppName() + ";");
                mc.cpp.addLine("root->parent = item.get();");
                mc.cpp.addLine("for (auto &v : *" + v.getName() + ")");
                mc.cpp.beginBlock();
                mc.cpp.addLine("root->children.push_back(tmp = v->printTree());");
                mc.cpp.addLine("tmp->parent = root.get();");
                mc.cpp.endBlock();
                mc.cpp.addLine("item->children.push_back(root);");
            }
            mc.cpp.addLine();
            mc.cpp.addLine("return item;");
        }
        else
        {
            mc.cpp.addLine("return createTreeItem();");
        }
        mc.cpp.endFunction();
    }

    // getName()
    {
        mc.hpp.addLine("virtual Text getName() const override;");
        mc.hpp.addLine();

        mc.cpp.beginFunction("Text " + getCppName() + "::getName() const");
        if (getCppName() != String)
        {
            mc.cpp.addLine("Text s;");

            std::string return_add;
            auto checkReturn = [&]
            {
                mc.cpp.addLine("if (!s.empty())");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("return s" + return_add + ";");
                mc.cpp.decreaseIndent();
            };
            auto printTextColumn = [&](auto *c)
            {
                if (c == nullptr)
                    return;
                if (c->getType()->getDataType() == DataType::Text)
                    mc.cpp.addLine("s = " + c->getName() + ";");
                else
                    mc.cpp.addLine("s = to_string(" + c->getName() + ");");
                checkReturn();
            };

            for (auto &nameType : namesOrder)
            {
                switch (nameType)
                {
                case ObjectName::Custom:
                {
                    if (!objectName.empty())
                    {
                        mc.cpp.addLine("s = " + objectName + ";");
                        checkReturn();
                    }
                    break;
                }
                case ObjectName::Name:
                    printTextColumn(getNameVariable());
                    break;
                case ObjectName::Text:
                    printTextColumn(getTextVariable());
                    break;
                case ObjectName::Parent:
                    if (flags[fProxy])
                    {
                        std::string var_name = parent->getCppVariableName();
                        for (auto &v : getVariables())
                        {
                            if (parent->getName() == v.getType()->getName())
                            {
                                var_name = v.getName();
                                break;
                            }
                        }
                        mc.cpp.addLine("s = to_string(" + var_name + ");");
                        checkReturn();
                    }
                    break;
                }
            }
            mc.cpp.addLine("return " + iObject + "::getName()" + return_add + ";");
        }
        else
        {
            auto iter = vars.begin();
            while (iter->getName() != "ru")
                iter = next(iter);
            mc.cpp.addLine("auto s = ((Text *)&" + iter->getName() + ")[gCurrentLocalizationId];");
            mc.cpp.addLine("if (!s.empty())");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return s;");
            mc.cpp.decreaseIndent();
            mc.cpp.addLine("s = text_id;");
            mc.cpp.addLine("if (!s.empty())");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return s;");
            mc.cpp.decreaseIndent();
            mc.cpp.addLine("for (int i = 0; i < static_cast<int>(LocalizationType::max); i++)");
            mc.cpp.beginBlock();
            mc.cpp.addLine("s = ((Text *)&" + iter->getName() + ")[i];");
            mc.cpp.addLine("if (!s.empty())");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return s;");
            mc.cpp.decreaseIndent();
            mc.cpp.endBlock();
            mc.cpp.addLine("return s;");
        }
        mc.cpp.endFunction();
    }

    // operator==()
    {
        mc.hpp.addLine("bool operator==(const " + getCppName() + " &rhs) const;");

        mc.cpp.beginFunction("bool " + getCppName() + "::operator==(const " + getCppName() + " &rhs) const");
        mc.cpp.addLine("return");
        mc.cpp.increaseIndent();
        for (auto &v : vars)
        {
            if (v.getName() != "id")
            {
                mc.cpp.addLine(v.getName() + " == rhs." + v.getName() + " &&");
            }
        }
        mc.cpp.addLine("1;");
        mc.cpp.decreaseIndent();
        mc.cpp.endFunction();
    }

    // operator->()
    {
        if (flags[fProxy])
        {
            mc.hpp.addLine("" + dataClassPtr + "<" + parent->getCppName() + "> operator->() const;");

            mc.cpp.beginFunction("" + dataClassPtr + "<" + parent->getCppName() + "> " + getCppName() + "::operator->() const");
            std::string var_name = parent->getCppVariableName();
            for (auto &v : getVariables())
            {
                if (parent->getName() == v.getType()->getName())
                {
                    var_name = v.getName();
                    break;
                }
            }
            mc.cpp.addLine("if (" + var_name + ")");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return " + var_name + ";");
            mc.cpp.decreaseIndent();
            mc.cpp.addLine("throw EXCEPTION(\"Value is missing\");");
            mc.cpp.endFunction();
        }
    }

    // protected
    if (!vars_container.empty())
    {
        mc.hpp.addLine();
        mc.hpp.addLineNoSpace("protected:");

        // init children
        {
            for (auto v : vars_container)
            {
                mc.hpp.addLine("template <class T, class... Args>");
                mc.hpp.beginFunction("void init" + v.getNameWithCaptitalLetter() + "(Args&&... args)");
                mc.hpp.addLine("for (auto &v : *" + v.getName() + ")");
                mc.hpp.beginBlock();
                if (v.getType()->getFlags()[fProxy])
                    mc.hpp.addLine("auto p = v->" + v.getType()->getParent()->getCppVariableName() + ".get();");
                else
                    mc.hpp.addLine("auto p = v.second.get();");
                mc.hpp.addLine("p->replace<T>(p, std::forward<Args>(args)...);");
                mc.hpp.endBlock();
                mc.hpp.endFunction();
            }
        }
    }
    else
        mc.hpp.addLine();

    // private
    mc.hpp.addLineNoSpace("private:");

    // copyFrom()
    {
        mc.hpp.addLine("void copyFrom(const " + getCppName() + " &rhs);");

        mc.cpp.beginFunction("void " + getCppName() + "::copyFrom(const " + getCppName() + " &rhs)");
        for (auto &v : vars)
            mc.cpp.addLine(v.getName() + " = rhs." + v.getName() + ";");
        if (!vars_container.empty())
        {
            mc.cpp.addLine();
            for (auto &v : vars_container)
            {
                mc.cpp.addLine(v.getName() + " = std::make_shared<" + ctableType(v.getType()->getCppName()) + ">(*rhs." + v.getName() + ");");
            }
        }
        mc.cpp.endFunction();
    }

    // private
    mc.hpp.addLine();
    mc.hpp.addLineNoSpace("private:");

    // friends
    mc.hpp.addLine("friend class " + storageImpl + ";");
    mc.hpp.addLine("template <class T> friend class CTable;");
    mc.hpp.addLine();

    // static functions & data
    mc.hpp.addLineNoSpace("public:");

    // type
    mc.hpp.addLine("static const EObjectType object_type = EObjectType::" + getCppName() + ";");
    mc.hpp.addLine(std::string("static const bool has_id = ") + (hasIdField ? "true" : "false") + ";");
    mc.hpp.addLine();

    // getSql()
    {
        mc.hpp.addLine("static const char *getSql();");

        mc.cpp.beginFunction("const char *" + getCppName() + "::getSql()");
        auto sql = printSql();
        replaceAll(sql, "\n", " \\\n");
        replaceAll(sql, "\"", "\\\"");
        mc.cpp.addLine("return");
        mc.cpp.addLine("\" \\");
        mc.cpp.decreaseIndent();
        mc.cpp.addLine(sql + " \\");
        mc.cpp.increaseIndent();
        mc.cpp.addLine("\";");
        mc.cpp.endFunction();
    }

    mc.hpp.endBlock(true);
    mc.hpp.addLine();
    return mc;
}

ModuleContext Class::printAddDeleteRecordVirtual() const
{
    std::string param;
    std::string param_name;
    if (parent)
    {
        param_name = "parent";
        param = "" + iObject + " *" + param_name + " = nullptr";
    }
    ModuleContext mc;
    mc.hpp.increaseIndent();
    mc.hpp.addLine("virtual " + dataClassPtr + "<" + getCppName() + "> add" + getCppName() + "(" + param + ") = 0;");
    mc.hpp.addLine("virtual void delete" + getCppName() + "(" + iObject + " *object) = 0;");
    mc.hpp.decreaseIndent();
    return mc;
}

ModuleContext Class::printIo() const
{
    ModuleContext mc;
    const auto vars = getVariables();
    const auto vars_container = variables({ fContainer }, false, false);
    bool fks = false;
    for (auto &v : vars)
        fks |= v.isFk();

    mc.hpp.increaseIndent();

    // printLoad()
    {
        mc.hpp.addLine("void _load" + getSqlName() + "();");

        mc.cpp.beginFunction("void " + storageImpl + "::_load" + getSqlName() + "()");
        mc.cpp.addLine("const std::string query = \"select * from " + getSqlName() + ";\"" + ";");
        mc.cpp.addLine("auto db3 = db->getDb();");
        mc.cpp.addLine("sqlite3_stmt *stmt;");
        mc.cpp.addLine("sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);");
        mc.cpp.addLine("while (sqlite3_step(stmt) == SQLITE_ROW)");
        mc.cpp.beginBlock();
        mc.cpp.addLine("auto v = " + getCppArrayVariableName() + ".create();");
        for (auto &v : vars)
            mc.cpp.addLine(v.printLoadSqlite3("v") + ";");
        mc.cpp.addLine(getCppArrayVariableName() + ".insert(v);");
        mc.cpp.endBlock();
        mc.cpp.addLine("sqlite3_finalize(stmt);");
        mc.cpp.endFunction();
    }

    // printLoadPtrs()
    {
        mc.hpp.addLine("void _load" + getSqlName() + "Ptrs();");

        mc.cpp.beginFunction("void " + storageImpl + "::_load" + getSqlName() + "Ptrs()");
        if (fks)
        {
            mc.cpp.addLine("for (auto &" + getCppVariableName() + " : " + getCppArrayVariableName() + ")");
            mc.cpp.beginBlock();
            bool prev = false;
            for (auto &v : vars)
            {
                std::string name = getCppName();
                std::string var = getCppVariableName();
                if (v.isFk())
                {
                    if (prev)
                        mc.cpp.addLine();
                    std::string name2 = v.getType()->getCppArrayVariableName();
                    mc.cpp.addLine("auto " + v.getName() + " = " + name2 + ".find(" + var + "->" + v.getName() + idAccess + ");");
                    mc.cpp.addLine("if (" + v.getName() + " != " + name2 + ".end())");
                    mc.cpp.increaseIndent();
                    mc.cpp.addLine(var + "->" + v.getName() + " = *" + v.getName() + ";");
                    mc.cpp.decreaseIndent();
                    prev = true;
                }
            }
            mc.cpp.endBlock();
        }
        mc.cpp.endFunction();
    }

    // printLoadArrays()
    {
        mc.hpp.addLine("void _load" + getSqlName() + "Arrays();");

        mc.cpp.beginFunction("void " + storageImpl + "::_load" + getSqlName() + "Arrays()");
        if (!vars_container.empty())
        {
            mc.cpp.beginBlock("for (auto &" + getCppVariableName() + " : " + getCppArrayVariableName() + ")");
            for (auto &v : vars_container)
            {
                auto t = (Class *)v.getType();
                mc.cpp.addLine("for (auto &" + t->getCppVariableName() + " : " + t->getCppArrayVariableName() + ")");
                mc.cpp.increaseIndent();
                std::string var_name = getCppVariableName();
                for (auto &v2 : t->getVariables())
                {
                    if (this->getName() == v2.getType()->getName())
                    {
                        var_name = v2.getName();
                        break;
                    }
                }
                mc.cpp.addLine(
                    "if (" + getCppVariableName() + "->id" + " == " +
                    t->getCppVariableName() + "->" + var_name + idAccess + ")");
                mc.cpp.increaseIndent();
                mc.cpp.addLine(
                    getCppVariableName() + "->" + v.getName() + containerAccess +
                    "insert(" + t->getCppVariableName() + ");");
                mc.cpp.decreaseIndent();
                mc.cpp.decreaseIndent();
            }
            mc.cpp.endBlock();
        }
        mc.cpp.endFunction();
    }

    // printSave()
    {
        mc.hpp.addLine("void _save" + getSqlName() + "() const;");

        mc.cpp.beginFunction("void " + storageImpl + "::_save" + getSqlName() + "() const");
        mc.cpp.addLine("db->execute(\"BEGIN;\");");
        mc.cpp.addLine("db->execute(\"delete from " + getSqlName() + ";\");");
        mc.cpp.addNoNewLine("const std::string query = \"insert into " + getSqlName() + " values (");
        for (int i = 0; i < vars.size(); i++)
            mc.cpp.addText("?, ");
        mc.cpp.trimEnd(2);
        mc.cpp.addLineNoSpace(");\";");
        mc.cpp.addLine("auto db3 = db->getDb();");
        mc.cpp.addLine("sqlite3_stmt *stmt;");
        mc.cpp.addLine("sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);");
        mc.cpp.beginBlock("for (auto &" + getCppVariableName() + " : " + getCppArrayVariableName() + ")");
        mc.cpp.addLine("auto &v = " + getCppVariableName() + (hasIdField ? ".second" : "") + ";");
        for (auto &v : vars)
            mc.cpp.addLine(v.printSaveSqlite3("v") + ";");
        mc.cpp.addLine("sqlite3_step(stmt);");
        mc.cpp.addLine("sqlite3_reset(stmt);");
        mc.cpp.endBlock();
        mc.cpp.addLine("sqlite3_finalize(stmt);");
        mc.cpp.addLine("db->execute(\"COMMIT;\");");
        mc.cpp.endFunction();
    }
    
    return mc;
}

ModuleContext Class::printAddDeleteRecord() const
{
    ModuleContext mc;
    mc.hpp.increaseIndent();

    std::string param, param_h;
    std::string param_name;

    if (getParent())
    {
        param_name = "parent";
        param_h = "" + iObject + " *" + param_name + " = nullptr";
        param = "" + iObject + " *" + param_name;
    }

    // add record
    {
        mc.hpp.addLine("virtual " + dataClassPtr + "<" + getCppName() + "> add" + getCppName() + "(" + param_h + ") override;");

        mc.cpp.beginFunction("" + dataClassPtr + "<" + getCppName() + "> " + storageImpl + "::add" + getCppName() + "(" + param + ")");
        /*if (parent && !children.empty())
        {
            std::string var = parent->getCppVariableName();
            mc.cpp.addLine("auto v = " + getCppArrayVariableName() + ".createAtEnd();");
            mc.cpp.addLine(parent->getCppName() + " *" + var + " = (" + parent->getCppName() + " *)" + param_name + ";");
            mc.cpp.addLine(var + "->" + parent->getCppArrayVariableName() + ".insert(v);");
            mc.cpp.addLine("v->" + var + " = " + var + "s[" + var + "->id];");
            mc.cpp.addLine("return v;");
        }
        else
        {*/
            if (hasIdField || !parent)
            {
                mc.cpp.addLine("return " + getCppArrayVariableName() + ".createAtEnd();");
            }
            else
            {
                std::string var = parent->getCppVariableName();
                mc.cpp.addLine("auto v = " + getCppArrayVariableName() + ".createAtEnd();");
                mc.cpp.addLine(parent->getCppName() + " *" + var + " = (" + parent->getCppName() + " *)" + param_name + ";");
                std::string var_name1 = parent->getCppArrayVariableName();
                for (auto &v2 : parent->getVariables(true))
                {
                    if (this->getName() == v2.getType()->getName())
                    {
                        var_name1 = v2.getName();
                        break;
                    }
                }
                mc.cpp.addLine(var + "->" + var_name1 + containerAccess + "insert(v);");
                std::string var_name2 = var;
                for (auto &v2 : getVariables())
                {
                    if (parent->getName() == v2.getType()->getName())
                    {
                        var_name2 = v2.getName();
                        break;
                    }
                }
                mc.cpp.addLine("v->" + var_name2 + " = " + parent->getCppArrayVariableName() + "[" + var + "->id];");
                mc.cpp.addLine("return v;");
            }
        //}
        mc.cpp.endFunction();
    }

    // delete record
    {
        mc.hpp.addLine("virtual void delete" + getCppName() + "(" + iObject + " *object) override;");

        mc.cpp.beginFunction("void " + storageImpl + "::delete" + getCppName() + "(" + iObject + " *v)");
        mc.cpp.addLine(getCppArrayVariableName() + ".erase(v->id);");
        mc.cpp.endFunction();
    }

    return mc;
}

void Class::printVariables(ModuleContext &mc) const
{
    for (auto &v : variables({ fContainer }, true, false))
    {
        if (v.isId())
            continue;
        if (v.getType()->getFlags()[fInline])
        {
            v.getType()->printVariables(mc);
            continue;
        }
        mc.hpp.addLine(v.print() + ";");
    }
}

std::string Class::printSql() const
{
    auto quoted = [](const std::string &s)
    {
        return "\"" + s + "\"";
    };
    auto braced = [](const std::string &s)
    {
        return "(" + s + ")";
    };

    const auto vars = getVariables();
    bool hasPks = false;
    bool hasFks = false;

    std::string s;
    s += "create table " + quoted(getSqlName()) + " (" + "\n";

    // fields
    for (auto &v : vars)
    {
        s += quoted(v.getSqlName()) + " " + dataTypeToSqlite3(v.getType()->getDataType());
        auto d = v.getRawDefaultValue();
        if (!d.empty())
            s += " DEFAULT " + quoted(d);
        s += ",\n";

        hasPks |= v.getFlags()[fPrimaryKey];
        hasFks |= v.isFk();
    }

    // pks
    if (hasPks)
    {
        s += "PRIMARY KEY ";
        std::string p;
        for (auto &v : vars)
        {
            if (v.getFlags()[fPrimaryKey])
            {
                p += quoted(v.getSqlName()) + ", ";
            }
        }
        p.resize(p.size() - 2);
        s += braced(p) + ",\n";
    }

    // fks
    if (hasFks)
    {
        for (auto &v : vars)
        {
            if (v.isFk())
            {
                s += "FOREIGN KEY " + braced(quoted(v.getSqlName())) + " REFERENCES " +
                    quoted(v.getType()->getCppArrayName()) + " " + braced(quoted("id"));
                s += ",\n";
            }
        }
    }

    s.resize(s.size() - 2);
    s += "\n);";
    return s;
}

Variables Class::getVariables(bool container) const
{
    Variables r;
    auto vars = variables({ fContainer }, !container, false);
    for (auto &v : vars)
    {
        if (v.getType()->getFlags()[fInline])
        {
            auto v2 = ((Class *)v.getType())->getVariables();
            r.insert(r.end(), v2.begin(), v2.end());
            continue;
        }
        r.push_back(v);
    }
    int id = 0;
    for (auto &v : r)
        v.setId(id++);
    return r;
}

std::string Variable::print() const
{
    std::string s;
    if (flags[fContainer])
    {
        s += arrayType(type->getCppName()) + " " + getName();
        return s;
    }
    if (isFk())
    {
        s += "" + dataClassPtr + "<" + type->getCppName() + "> " + getName();
    }
    else
    {
        s += type->getCppName() + " " + getName();
        if (type->getDataType() == DataType::Integer || type->getDataType() == DataType::Real)
            s += " = " + getDefaultValue();
    }
    return s;
}

std::string Variable::printSet() const
{
    std::string s;
    if (isFk())
    {
        s += getName() + idAccess + " = std::stoi(to_string(text))";
    }
    else
    {
        s += name + " = ";
        switch (type->getDataType())
        {
        case DataType::Integer:
            s += "std::stoi(to_string(text))";
            break;
        case DataType::Real:
            s += "std::stof(to_string(text))";
            break;
        case DataType::Text:
            s += "to_string(text)";
            break;
        case DataType::Bool:
            s += "to_bool(to_string(text))";
            break;
        case DataType::Blob:
            s += "text";
            break;
        default:
            assert(false);
            break;
        }
    }
    return s;
}

std::string Variable::printSetPtr() const
{
    std::string s;
    if (isFk())
    {
        s += getName() + " = std::static_pointer_cast<" + type->getCppName() + ">(std::shared_ptr<" + iObject + ">(ptr, [](auto p){}))";
    }
    return s;
}

std::string Variable::getDefaultValue() const
{
    std::string s;
    switch (type->getDataType())
    {
    case DataType::Integer:
        s += defaultValue.empty() ? "0" : defaultValue;
        break;
    case DataType::Real:
        s += defaultValue.empty() ? "0.0f" : defaultValue;
        break;
    case DataType::Text:
        s += defaultValue;
        break;
    case DataType::Bool:
        s += defaultValue.empty() ? "false" : defaultValue;
        break;
    case DataType::Blob:
        break;
    default:
        assert(false);
        break;
    }
    return s;
}

std::string Variable::printLoadSqlite3(std::string var) const
{
    auto t = type->getDataType();
    std::string s;
    s += var + "->" + getName() + " = ";
    if (isFk())
        t = DataType::Integer;
    switch (t)
    {
    case DataType::Bool:
        s += "!!";
    case DataType::Integer:
        s += "sqlite3_column_int";
        break;
    case DataType::Real:
        s += "(float)sqlite3_column_double";
        break;
    case DataType::Text:
        s += "(const char *)sqlite3_column_text";
        break;
    case DataType::Blob:
        s += "Blob(sqlite3_column_blob(stmt, " + std::to_string(id) + "), sqlite3_column_bytes(stmt, " + std::to_string(id) + "))";
        break;
    default:
        assert(false);
        break;
    }
    if (t != DataType::Blob)
        s += "(stmt, " + std::to_string(id) + ")";
    return s;
}

std::string Variable::printSaveSqlite3(std::string var) const
{
    auto t = type->getDataType();

    std::string s;
    if (isFk())
    {
        s += "sqlite3_bind_int(stmt, " + std::to_string(id + 1) + ", " + var + "->" + getName() + idAccess + ")";
    }
    else
    {
        switch (t)
        {
        case DataType::Bool:
        case DataType::Integer:
            s += "sqlite3_bind_int(stmt, " + std::to_string(id + 1) + ", " + var + "->" + name + ")";
            break;
        case DataType::Real:
            s += "sqlite3_bind_double(stmt, " + std::to_string(id + 1) + ", " + var + "->" + name + ")";
            break;
        case DataType::Text:
            s += "sqlite3_bind_text(stmt, " + std::to_string(id + 1) + ", std::to_string(" + var + "->" + name +
                ").c_str()" + ", -1, SQLITE_TRANSIENT)";
            break;
        case DataType::Blob:
            s += "sqlite3_bind_blob(stmt, " + std::to_string(id + 1) + ", " +
                var + "->" + name + ".getRawData()" + ", " +
                var + "->" + name + ".getLength()" +
                ", SQLITE_TRANSIENT)";
            break;
        default:
            assert(false);
            break;
        }
    }
    return s;
}
