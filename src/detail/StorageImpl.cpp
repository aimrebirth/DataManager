/* DO NOT EDIT! This is an autogenerated file. */

void StorageImpl::_loadBuildings()
{
    int ret = 0;
    const std::string query = "select * from Buildings;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = buildings.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->scale = (float)sqlite3_column_double(stmt, 3);
        v->scale_x = (float)sqlite3_column_double(stmt, 4);
        v->scale_y = (float)sqlite3_column_double(stmt, 5);
        v->scale_z = (float)sqlite3_column_double(stmt, 6);
        buildings.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadBuildingsPtrs()
{
}

void StorageImpl::_loadBuildingsArrays()
{
}

void StorageImpl::_saveBuildings() const
{
    db->execute("BEGIN;");
    db->execute("delete from Buildings;");
    const std::string query = "insert into Buildings values (?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &building : buildings)
    {
        auto &v = building.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_double(stmt, 4, v->scale);
        ret = sqlite3_bind_double(stmt, 5, v->scale_x);
        ret = sqlite3_bind_double(stmt, 6, v->scale_y);
        ret = sqlite3_bind_double(stmt, 7, v->scale_z);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadClans()
{
    int ret = 0;
    const std::string query = "select * from Clans;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = clans.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name->id = (stmt, 3);
        v->member_name->id = (stmt, 4);
        v->modification->id = (stmt, 5);
        v->bonusexp = sqlite3_column_int(stmt, 6);
        v->bonusrepair = sqlite3_column_int(stmt, 7);
        v->bonustrade = sqlite3_column_int(stmt, 8);
        v->helpness = sqlite3_column_int(stmt, 9);
        v->Volatile = (float)sqlite3_column_double(stmt, 10);
        v->noblivion = (float)sqlite3_column_double(stmt, 11);
        v->playereffect = (float)sqlite3_column_double(stmt, 12);
        v->color = sqlite3_column_int(stmt, 13);
        clans.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadClansPtrs()
{
    for (auto &clan : clans)
    {
        if (strings.find(clan->name->id) != strings.end())
            clan->name = strings[clan->name->id];
        if (strings.find(clan->member_name->id) != strings.end())
            clan->member_name = strings[clan->member_name->id];
        if (modifications.find(clan->modification->id) != modifications.end())
            clan->modification = modifications[clan->modification->id];
    }
}

void StorageImpl::_loadClansArrays()
{
    for (auto &clan : clans)
    {
        for (auto &mechanoid : mechanoids)
            if (clan->id == mechanoid->clan->id)
                clan->mechanoids->insert(mechanoid);
        for (auto &clanReputation : clanReputations)
            if (clan->id == clanReputation->clan1->id)
                clan->reputations->insert(clanReputation);
    }
}

void StorageImpl::_saveClans() const
{
    db->execute("BEGIN;");
    db->execute("delete from Clans;");
    const std::string query = "insert into Clans values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &clan : clans)
    {
        auto &v = clan.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->name->id);
        ret = sqlite3_bind_int(stmt, 5, v->member_name->id);
        ret = sqlite3_bind_int(stmt, 6, v->modification->id);
        ret = sqlite3_bind_int(stmt, 7, v->bonusexp);
        ret = sqlite3_bind_int(stmt, 8, v->bonusrepair);
        ret = sqlite3_bind_int(stmt, 9, v->bonustrade);
        ret = sqlite3_bind_int(stmt, 10, v->helpness);
        ret = sqlite3_bind_double(stmt, 11, v->Volatile);
        ret = sqlite3_bind_double(stmt, 12, v->noblivion);
        ret = sqlite3_bind_double(stmt, 13, v->playereffect);
        ret = sqlite3_bind_int(stmt, 14, v->color);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadClanReputations()
{
    int ret = 0;
    const std::string query = "select * from ClanReputations;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = clanReputations.create();
        v->clan1->id = (stmt, 0);
        v->clan2->id = (stmt, 1);
        v->reputation = (float)sqlite3_column_double(stmt, 2);
        clanReputations.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadClanReputationsPtrs()
{
    for (auto &clanReputation : clanReputations)
    {
        if (clans.find(clanReputation->clan1->id) != clans.end())
            clanReputation->clan1 = clans[clanReputation->clan1->id];
        if (clans.find(clanReputation->clan2->id) != clans.end())
            clanReputation->clan2 = clans[clanReputation->clan2->id];
    }
}

void StorageImpl::_loadClanReputationsArrays()
{
}

void StorageImpl::_saveClanReputations() const
{
    db->execute("BEGIN;");
    db->execute("delete from ClanReputations;");
    const std::string query = "insert into ClanReputations values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &clanReputation : clanReputations)
    {
        auto &v = clanReputation;
        ret = sqlite3_bind_int(stmt, 1, v->clan1->id);
        ret = sqlite3_bind_int(stmt, 2, v->clan2->id);
        ret = sqlite3_bind_double(stmt, 3, v->reputation);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadConfigurations()
{
    int ret = 0;
    const std::string query = "select * from Configurations;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = configurations.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->name->id = (stmt, 2);
        v->glider->id = (stmt, 3);
        configurations.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadConfigurationsPtrs()
{
    for (auto &configuration : configurations)
    {
        if (strings.find(configuration->name->id) != strings.end())
            configuration->name = strings[configuration->name->id];
        if (gliders.find(configuration->glider->id) != gliders.end())
            configuration->glider = gliders[configuration->glider->id];
    }
}

void StorageImpl::_loadConfigurationsArrays()
{
    for (auto &configuration : configurations)
    {
        for (auto &configurationEquipment : configurationEquipments)
            if (configuration->id == configurationEquipment->configuration->id)
                configuration->equipments->insert(configurationEquipment);
        for (auto &configurationGood : configurationGoods)
            if (configuration->id == configurationGood->configuration->id)
                configuration->goods->insert(configurationGood);
        for (auto &configurationProjectile : configurationProjectiles)
            if (configuration->id == configurationProjectile->configuration->id)
                configuration->projectiles->insert(configurationProjectile);
        for (auto &configurationWeapon : configurationWeapons)
            if (configuration->id == configurationWeapon->configuration->id)
                configuration->weapons->insert(configurationWeapon);
    }
}

void StorageImpl::_saveConfigurations() const
{
    db->execute("BEGIN;");
    db->execute("delete from Configurations;");
    const std::string query = "insert into Configurations values (?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &configuration : configurations)
    {
        auto &v = configuration.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->name->id);
        ret = sqlite3_bind_int(stmt, 4, v->glider->id);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadConfigurationEquipments()
{
    int ret = 0;
    const std::string query = "select * from ConfigurationEquipments;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = configurationEquipments.create();
        v->configuration->id = (stmt, 0);
        v->equipment->id = (stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        configurationEquipments.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadConfigurationEquipmentsPtrs()
{
    for (auto &configurationEquipment : configurationEquipments)
    {
        if (configurations.find(configurationEquipment->configuration->id) != configurations.end())
            configurationEquipment->configuration = configurations[configurationEquipment->configuration->id];
        if (equipments.find(configurationEquipment->equipment->id) != equipments.end())
            configurationEquipment->equipment = equipments[configurationEquipment->equipment->id];
    }
}

void StorageImpl::_loadConfigurationEquipmentsArrays()
{
}

void StorageImpl::_saveConfigurationEquipments() const
{
    db->execute("BEGIN;");
    db->execute("delete from ConfigurationEquipments;");
    const std::string query = "insert into ConfigurationEquipments values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &configurationEquipment : configurationEquipments)
    {
        auto &v = configurationEquipment;
        ret = sqlite3_bind_int(stmt, 1, v->configuration->id);
        ret = sqlite3_bind_int(stmt, 2, v->equipment->id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadConfigurationGoods()
{
    int ret = 0;
    const std::string query = "select * from ConfigurationGoods;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = configurationGoods.create();
        v->configuration->id = (stmt, 0);
        v->good->id = (stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        configurationGoods.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadConfigurationGoodsPtrs()
{
    for (auto &configurationGood : configurationGoods)
    {
        if (configurations.find(configurationGood->configuration->id) != configurations.end())
            configurationGood->configuration = configurations[configurationGood->configuration->id];
        if (goods.find(configurationGood->good->id) != goods.end())
            configurationGood->good = goods[configurationGood->good->id];
    }
}

void StorageImpl::_loadConfigurationGoodsArrays()
{
}

void StorageImpl::_saveConfigurationGoods() const
{
    db->execute("BEGIN;");
    db->execute("delete from ConfigurationGoods;");
    const std::string query = "insert into ConfigurationGoods values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &configurationGood : configurationGoods)
    {
        auto &v = configurationGood;
        ret = sqlite3_bind_int(stmt, 1, v->configuration->id);
        ret = sqlite3_bind_int(stmt, 2, v->good->id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadConfigurationProjectiles()
{
    int ret = 0;
    const std::string query = "select * from ConfigurationProjectiles;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = configurationProjectiles.create();
        v->configuration->id = (stmt, 0);
        v->projectile->id = (stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        configurationProjectiles.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadConfigurationProjectilesPtrs()
{
    for (auto &configurationProjectile : configurationProjectiles)
    {
        if (configurations.find(configurationProjectile->configuration->id) != configurations.end())
            configurationProjectile->configuration = configurations[configurationProjectile->configuration->id];
        if (projectiles.find(configurationProjectile->projectile->id) != projectiles.end())
            configurationProjectile->projectile = projectiles[configurationProjectile->projectile->id];
    }
}

void StorageImpl::_loadConfigurationProjectilesArrays()
{
}

void StorageImpl::_saveConfigurationProjectiles() const
{
    db->execute("BEGIN;");
    db->execute("delete from ConfigurationProjectiles;");
    const std::string query = "insert into ConfigurationProjectiles values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &configurationProjectile : configurationProjectiles)
    {
        auto &v = configurationProjectile;
        ret = sqlite3_bind_int(stmt, 1, v->configuration->id);
        ret = sqlite3_bind_int(stmt, 2, v->projectile->id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadConfigurationWeapons()
{
    int ret = 0;
    const std::string query = "select * from ConfigurationWeapons;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = configurationWeapons.create();
        v->configuration->id = (stmt, 0);
        v->weapon->id = (stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        configurationWeapons.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadConfigurationWeaponsPtrs()
{
    for (auto &configurationWeapon : configurationWeapons)
    {
        if (configurations.find(configurationWeapon->configuration->id) != configurations.end())
            configurationWeapon->configuration = configurations[configurationWeapon->configuration->id];
        if (weapons.find(configurationWeapon->weapon->id) != weapons.end())
            configurationWeapon->weapon = weapons[configurationWeapon->weapon->id];
    }
}

void StorageImpl::_loadConfigurationWeaponsArrays()
{
}

void StorageImpl::_saveConfigurationWeapons() const
{
    db->execute("BEGIN;");
    db->execute("delete from ConfigurationWeapons;");
    const std::string query = "insert into ConfigurationWeapons values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &configurationWeapon : configurationWeapons)
    {
        auto &v = configurationWeapon;
        ret = sqlite3_bind_int(stmt, 1, v->configuration->id);
        ret = sqlite3_bind_int(stmt, 2, v->weapon->id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadEquipments()
{
    int ret = 0;
    const std::string query = "select * from Equipments;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = equipments.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name->id = (stmt, 3);
        v->type = sqlite3_column_int(stmt, 4);
        v->standard = sqlite3_column_int(stmt, 5);
        v->weight = (float)sqlite3_column_double(stmt, 6);
        v->durability = (float)sqlite3_column_double(stmt, 7);
        v->power = (float)sqlite3_column_double(stmt, 8);
        v->value1 = (float)sqlite3_column_double(stmt, 9);
        v->value2 = (float)sqlite3_column_double(stmt, 10);
        v->value3 = (float)sqlite3_column_double(stmt, 11);
        v->manual = sqlite3_column_int(stmt, 12);
        v->price = (float)sqlite3_column_double(stmt, 13);
        v->notrade = sqlite3_column_int(stmt, 14);
        equipments.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadEquipmentsPtrs()
{
    for (auto &equipment : equipments)
    {
        if (strings.find(equipment->name->id) != strings.end())
            equipment->name = strings[equipment->name->id];
    }
}

void StorageImpl::_loadEquipmentsArrays()
{
}

void StorageImpl::_saveEquipments() const
{
    db->execute("BEGIN;");
    db->execute("delete from Equipments;");
    const std::string query = "insert into Equipments values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &equipment : equipments)
    {
        auto &v = equipment.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->name->id);
        ret = sqlite3_bind_int(stmt, 5, v->type);
        ret = sqlite3_bind_int(stmt, 6, v->standard);
        ret = sqlite3_bind_double(stmt, 7, v->weight);
        ret = sqlite3_bind_double(stmt, 8, v->durability);
        ret = sqlite3_bind_double(stmt, 9, v->power);
        ret = sqlite3_bind_double(stmt, 10, v->value1);
        ret = sqlite3_bind_double(stmt, 11, v->value2);
        ret = sqlite3_bind_double(stmt, 12, v->value3);
        ret = sqlite3_bind_int(stmt, 13, v->manual);
        ret = sqlite3_bind_double(stmt, 14, v->price);
        ret = sqlite3_bind_int(stmt, 15, v->notrade);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadGliders()
{
    int ret = 0;
    const std::string query = "select * from Gliders;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = gliders.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name->id = (stmt, 3);
        v->standard = sqlite3_column_int(stmt, 4);
        v->weight = (float)sqlite3_column_double(stmt, 5);
        v->maxweight = (float)sqlite3_column_double(stmt, 6);
        v->armor = (float)sqlite3_column_double(stmt, 7);
        v->price = (float)sqlite3_column_double(stmt, 8);
        v->restore = (float)sqlite3_column_double(stmt, 9);
        v->power = (float)sqlite3_column_double(stmt, 10);
        v->special = sqlite3_column_int(stmt, 11);
        v->rotatespeed = (float)sqlite3_column_double(stmt, 12);
        v->resfront = (float)sqlite3_column_double(stmt, 13);
        v->resstop = (float)sqlite3_column_double(stmt, 14);
        v->resside = (float)sqlite3_column_double(stmt, 15);
        v->stabfront = (float)sqlite3_column_double(stmt, 16);
        v->stabside = (float)sqlite3_column_double(stmt, 17);
        v->careen = (float)sqlite3_column_double(stmt, 18);
        v->delta_t = (float)sqlite3_column_double(stmt, 19);
        v->turbulence = (float)sqlite3_column_double(stmt, 20);
        gliders.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadGlidersPtrs()
{
    for (auto &glider : gliders)
    {
        if (strings.find(glider->name->id) != strings.end())
            glider->name = strings[glider->name->id];
    }
}

void StorageImpl::_loadGlidersArrays()
{
}

void StorageImpl::_saveGliders() const
{
    db->execute("BEGIN;");
    db->execute("delete from Gliders;");
    const std::string query = "insert into Gliders values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &glider : gliders)
    {
        auto &v = glider.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->name->id);
        ret = sqlite3_bind_int(stmt, 5, v->standard);
        ret = sqlite3_bind_double(stmt, 6, v->weight);
        ret = sqlite3_bind_double(stmt, 7, v->maxweight);
        ret = sqlite3_bind_double(stmt, 8, v->armor);
        ret = sqlite3_bind_double(stmt, 9, v->price);
        ret = sqlite3_bind_double(stmt, 10, v->restore);
        ret = sqlite3_bind_double(stmt, 11, v->power);
        ret = sqlite3_bind_int(stmt, 12, v->special);
        ret = sqlite3_bind_double(stmt, 13, v->rotatespeed);
        ret = sqlite3_bind_double(stmt, 14, v->resfront);
        ret = sqlite3_bind_double(stmt, 15, v->resstop);
        ret = sqlite3_bind_double(stmt, 16, v->resside);
        ret = sqlite3_bind_double(stmt, 17, v->stabfront);
        ret = sqlite3_bind_double(stmt, 18, v->stabside);
        ret = sqlite3_bind_double(stmt, 19, v->careen);
        ret = sqlite3_bind_double(stmt, 20, v->delta_t);
        ret = sqlite3_bind_double(stmt, 21, v->turbulence);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadGoods()
{
    int ret = 0;
    const std::string query = "select * from Goods;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = goods.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->resource_drop = (const char *)sqlite3_column_text(stmt, 3);
        v->name->id = (stmt, 4);
        v->price = (float)sqlite3_column_double(stmt, 5);
        v->weight = (float)sqlite3_column_double(stmt, 6);
        v->notrade = sqlite3_column_int(stmt, 7);
        v->type = sqlite3_column_int(stmt, 8);
        goods.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadGoodsPtrs()
{
    for (auto &good : goods)
    {
        if (strings.find(good->name->id) != strings.end())
            good->name = strings[good->name->id];
    }
}

void StorageImpl::_loadGoodsArrays()
{
}

void StorageImpl::_saveGoods() const
{
    db->execute("BEGIN;");
    db->execute("delete from Goods;");
    const std::string query = "insert into Goods values (?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &good : goods)
    {
        auto &v = good.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 4, std::to_string(v->resource_drop).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 5, v->name->id);
        ret = sqlite3_bind_double(stmt, 6, v->price);
        ret = sqlite3_bind_double(stmt, 7, v->weight);
        ret = sqlite3_bind_int(stmt, 8, v->notrade);
        ret = sqlite3_bind_int(stmt, 9, v->type);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadGroups()
{
    int ret = 0;
    const std::string query = "select * from Groups;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = groups.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->name->id = (stmt, 2);
        groups.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadGroupsPtrs()
{
    for (auto &group : groups)
    {
        if (strings.find(group->name->id) != strings.end())
            group->name = strings[group->name->id];
    }
}

void StorageImpl::_loadGroupsArrays()
{
    for (auto &group : groups)
    {
        for (auto &groupMechanoid : groupMechanoids)
            if (group->id == groupMechanoid->group->id)
                group->mechanoids->insert(groupMechanoid);
    }
}

void StorageImpl::_saveGroups() const
{
    db->execute("BEGIN;");
    db->execute("delete from Groups;");
    const std::string query = "insert into Groups values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &group : groups)
    {
        auto &v = group.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->name->id);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadGroupMechanoids()
{
    int ret = 0;
    const std::string query = "select * from GroupMechanoids;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = groupMechanoids.create();
        v->group->id = (stmt, 0);
        v->mechanoid->id = (stmt, 1);
        groupMechanoids.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadGroupMechanoidsPtrs()
{
    for (auto &groupMechanoid : groupMechanoids)
    {
        if (groups.find(groupMechanoid->group->id) != groups.end())
            groupMechanoid->group = groups[groupMechanoid->group->id];
        if (mechanoids.find(groupMechanoid->mechanoid->id) != mechanoids.end())
            groupMechanoid->mechanoid = mechanoids[groupMechanoid->mechanoid->id];
    }
}

void StorageImpl::_loadGroupMechanoidsArrays()
{
}

void StorageImpl::_saveGroupMechanoids() const
{
    db->execute("BEGIN;");
    db->execute("delete from GroupMechanoids;");
    const std::string query = "insert into GroupMechanoids values (?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &groupMechanoid : groupMechanoids)
    {
        auto &v = groupMechanoid;
        ret = sqlite3_bind_int(stmt, 1, v->group->id);
        ret = sqlite3_bind_int(stmt, 2, v->mechanoid->id);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMaps()
{
    int ret = 0;
    const std::string query = "select * from Maps;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = maps.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name->id = (stmt, 3);
        v->h_min = (float)sqlite3_column_double(stmt, 4);
        v->h_max = (float)sqlite3_column_double(stmt, 5);
        v->kx = (float)sqlite3_column_double(stmt, 6);
        v->bx = (float)sqlite3_column_double(stmt, 7);
        v->ky = (float)sqlite3_column_double(stmt, 8);
        v->by = (float)sqlite3_column_double(stmt, 9);
        maps.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapsPtrs()
{
    for (auto &map : maps)
    {
        if (strings.find(map->name->id) != strings.end())
            map->name = strings[map->name->id];
    }
}

void StorageImpl::_loadMapsArrays()
{
    for (auto &map : maps)
    {
        for (auto &mapBuilding : mapBuildings)
            if (map->id == mapBuilding->map->id)
                map->buildings->insert(mapBuilding);
        for (auto &mapGood : mapGoods)
            if (map->id == mapGood->map->id)
                map->goods->insert(mapGood);
        for (auto &mapObject : mapObjects)
            if (map->id == mapObject->map->id)
                map->objects->insert(mapObject);
    }
}

void StorageImpl::_saveMaps() const
{
    db->execute("BEGIN;");
    db->execute("delete from Maps;");
    const std::string query = "insert into Maps values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &map : maps)
    {
        auto &v = map.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->name->id);
        ret = sqlite3_bind_double(stmt, 5, v->h_min);
        ret = sqlite3_bind_double(stmt, 6, v->h_max);
        ret = sqlite3_bind_double(stmt, 7, v->kx);
        ret = sqlite3_bind_double(stmt, 8, v->bx);
        ret = sqlite3_bind_double(stmt, 9, v->ky);
        ret = sqlite3_bind_double(stmt, 10, v->by);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildings()
{
    int ret = 0;
    const std::string query = "select * from MapBuildings;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildings.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->name->id = (stmt, 2);
        v->map->id = (stmt, 3);
        v->building->id = (stmt, 4);
        v->x = (float)sqlite3_column_double(stmt, 5);
        v->y = (float)sqlite3_column_double(stmt, 6);
        v->z = (float)sqlite3_column_double(stmt, 7);
        v->roll = (float)sqlite3_column_double(stmt, 8);
        v->pitch = (float)sqlite3_column_double(stmt, 9);
        v->yaw = (float)sqlite3_column_double(stmt, 10);
        v->scale = (float)sqlite3_column_double(stmt, 11);
        v->scale_x = (float)sqlite3_column_double(stmt, 12);
        v->scale_y = (float)sqlite3_column_double(stmt, 13);
        v->scale_z = (float)sqlite3_column_double(stmt, 14);
        v->interactive = sqlite3_column_int(stmt, 15);
        mapBuildings.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingsPtrs()
{
    for (auto &mapBuilding : mapBuildings)
    {
        if (strings.find(mapBuilding->name->id) != strings.end())
            mapBuilding->name = strings[mapBuilding->name->id];
        if (maps.find(mapBuilding->map->id) != maps.end())
            mapBuilding->map = maps[mapBuilding->map->id];
        if (buildings.find(mapBuilding->building->id) != buildings.end())
            mapBuilding->building = buildings[mapBuilding->building->id];
    }
}

void StorageImpl::_loadMapBuildingsArrays()
{
    for (auto &mapBuilding : mapBuildings)
    {
        for (auto &mapBuildingEquipment : mapBuildingEquipments)
            if (mapBuilding->id == mapBuildingEquipment->map_building->id)
                mapBuilding->equipments->insert(mapBuildingEquipment);
        for (auto &mapBuildingGlider : mapBuildingGliders)
            if (mapBuilding->id == mapBuildingGlider->map_building->id)
                mapBuilding->gliders->insert(mapBuildingGlider);
        for (auto &mapBuildingGood : mapBuildingGoods)
            if (mapBuilding->id == mapBuildingGood->map_building->id)
                mapBuilding->goods->insert(mapBuildingGood);
        for (auto &mapBuildingModificator : mapBuildingModificators)
            if (mapBuilding->id == mapBuildingModificator->map_building->id)
                mapBuilding->modificators->insert(mapBuildingModificator);
        for (auto &mapBuildingProjectile : mapBuildingProjectiles)
            if (mapBuilding->id == mapBuildingProjectile->map_building->id)
                mapBuilding->projectiles->insert(mapBuildingProjectile);
        for (auto &mapBuildingWeapon : mapBuildingWeapons)
            if (mapBuilding->id == mapBuildingWeapon->map_building->id)
                mapBuilding->weapons->insert(mapBuildingWeapon);
    }
}

void StorageImpl::_saveMapBuildings() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildings;");
    const std::string query = "insert into MapBuildings values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuilding : mapBuildings)
    {
        auto &v = mapBuilding.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->name->id);
        ret = sqlite3_bind_int(stmt, 4, v->map->id);
        ret = sqlite3_bind_int(stmt, 5, v->building->id);
        ret = sqlite3_bind_double(stmt, 6, v->x);
        ret = sqlite3_bind_double(stmt, 7, v->y);
        ret = sqlite3_bind_double(stmt, 8, v->z);
        ret = sqlite3_bind_double(stmt, 9, v->roll);
        ret = sqlite3_bind_double(stmt, 10, v->pitch);
        ret = sqlite3_bind_double(stmt, 11, v->yaw);
        ret = sqlite3_bind_double(stmt, 12, v->scale);
        ret = sqlite3_bind_double(stmt, 13, v->scale_x);
        ret = sqlite3_bind_double(stmt, 14, v->scale_y);
        ret = sqlite3_bind_double(stmt, 15, v->scale_z);
        ret = sqlite3_bind_int(stmt, 16, v->interactive);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingEquipments()
{
    int ret = 0;
    const std::string query = "select * from MapBuildingEquipments;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingEquipments.create();
        v->map_building->id = (stmt, 0);
        v->equipment->id = (stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingEquipments.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingEquipmentsPtrs()
{
    for (auto &mapBuildingEquipment : mapBuildingEquipments)
    {
        if (mapBuildings.find(mapBuildingEquipment->map_building->id) != mapBuildings.end())
            mapBuildingEquipment->map_building = mapBuildings[mapBuildingEquipment->map_building->id];
        if (equipments.find(mapBuildingEquipment->equipment->id) != equipments.end())
            mapBuildingEquipment->equipment = equipments[mapBuildingEquipment->equipment->id];
    }
}

void StorageImpl::_loadMapBuildingEquipmentsArrays()
{
}

void StorageImpl::_saveMapBuildingEquipments() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingEquipments;");
    const std::string query = "insert into MapBuildingEquipments values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingEquipment : mapBuildingEquipments)
    {
        auto &v = mapBuildingEquipment;
        ret = sqlite3_bind_int(stmt, 1, v->map_building->id);
        ret = sqlite3_bind_int(stmt, 2, v->equipment->id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingGliders()
{
    int ret = 0;
    const std::string query = "select * from MapBuildingGliders;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingGliders.create();
        v->map_building->id = (stmt, 0);
        v->glider->id = (stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingGliders.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingGlidersPtrs()
{
    for (auto &mapBuildingGlider : mapBuildingGliders)
    {
        if (mapBuildings.find(mapBuildingGlider->map_building->id) != mapBuildings.end())
            mapBuildingGlider->map_building = mapBuildings[mapBuildingGlider->map_building->id];
        if (gliders.find(mapBuildingGlider->glider->id) != gliders.end())
            mapBuildingGlider->glider = gliders[mapBuildingGlider->glider->id];
    }
}

void StorageImpl::_loadMapBuildingGlidersArrays()
{
}

void StorageImpl::_saveMapBuildingGliders() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingGliders;");
    const std::string query = "insert into MapBuildingGliders values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingGlider : mapBuildingGliders)
    {
        auto &v = mapBuildingGlider;
        ret = sqlite3_bind_int(stmt, 1, v->map_building->id);
        ret = sqlite3_bind_int(stmt, 2, v->glider->id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingGoods()
{
    int ret = 0;
    const std::string query = "select * from MapBuildingGoods;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingGoods.create();
        v->map_building->id = (stmt, 0);
        v->good->id = (stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingGoods.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingGoodsPtrs()
{
    for (auto &mapBuildingGood : mapBuildingGoods)
    {
        if (mapBuildings.find(mapBuildingGood->map_building->id) != mapBuildings.end())
            mapBuildingGood->map_building = mapBuildings[mapBuildingGood->map_building->id];
        if (goods.find(mapBuildingGood->good->id) != goods.end())
            mapBuildingGood->good = goods[mapBuildingGood->good->id];
    }
}

void StorageImpl::_loadMapBuildingGoodsArrays()
{
}

void StorageImpl::_saveMapBuildingGoods() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingGoods;");
    const std::string query = "insert into MapBuildingGoods values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingGood : mapBuildingGoods)
    {
        auto &v = mapBuildingGood;
        ret = sqlite3_bind_int(stmt, 1, v->map_building->id);
        ret = sqlite3_bind_int(stmt, 2, v->good->id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingModificators()
{
    int ret = 0;
    const std::string query = "select * from MapBuildingModificators;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingModificators.create();
        v->map_building->id = (stmt, 0);
        v->modificator->id = (stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingModificators.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingModificatorsPtrs()
{
    for (auto &mapBuildingModificator : mapBuildingModificators)
    {
        if (mapBuildings.find(mapBuildingModificator->map_building->id) != mapBuildings.end())
            mapBuildingModificator->map_building = mapBuildings[mapBuildingModificator->map_building->id];
        if (modificators.find(mapBuildingModificator->modificator->id) != modificators.end())
            mapBuildingModificator->modificator = modificators[mapBuildingModificator->modificator->id];
    }
}

void StorageImpl::_loadMapBuildingModificatorsArrays()
{
}

void StorageImpl::_saveMapBuildingModificators() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingModificators;");
    const std::string query = "insert into MapBuildingModificators values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingModificator : mapBuildingModificators)
    {
        auto &v = mapBuildingModificator;
        ret = sqlite3_bind_int(stmt, 1, v->map_building->id);
        ret = sqlite3_bind_int(stmt, 2, v->modificator->id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingProjectiles()
{
    int ret = 0;
    const std::string query = "select * from MapBuildingProjectiles;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingProjectiles.create();
        v->map_building->id = (stmt, 0);
        v->projectile->id = (stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingProjectiles.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingProjectilesPtrs()
{
    for (auto &mapBuildingProjectile : mapBuildingProjectiles)
    {
        if (mapBuildings.find(mapBuildingProjectile->map_building->id) != mapBuildings.end())
            mapBuildingProjectile->map_building = mapBuildings[mapBuildingProjectile->map_building->id];
        if (projectiles.find(mapBuildingProjectile->projectile->id) != projectiles.end())
            mapBuildingProjectile->projectile = projectiles[mapBuildingProjectile->projectile->id];
    }
}

void StorageImpl::_loadMapBuildingProjectilesArrays()
{
}

void StorageImpl::_saveMapBuildingProjectiles() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingProjectiles;");
    const std::string query = "insert into MapBuildingProjectiles values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingProjectile : mapBuildingProjectiles)
    {
        auto &v = mapBuildingProjectile;
        ret = sqlite3_bind_int(stmt, 1, v->map_building->id);
        ret = sqlite3_bind_int(stmt, 2, v->projectile->id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingWeapons()
{
    int ret = 0;
    const std::string query = "select * from MapBuildingWeapons;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingWeapons.create();
        v->map_building->id = (stmt, 0);
        v->weapon->id = (stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingWeapons.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingWeaponsPtrs()
{
    for (auto &mapBuildingWeapon : mapBuildingWeapons)
    {
        if (mapBuildings.find(mapBuildingWeapon->map_building->id) != mapBuildings.end())
            mapBuildingWeapon->map_building = mapBuildings[mapBuildingWeapon->map_building->id];
        if (weapons.find(mapBuildingWeapon->weapon->id) != weapons.end())
            mapBuildingWeapon->weapon = weapons[mapBuildingWeapon->weapon->id];
    }
}

void StorageImpl::_loadMapBuildingWeaponsArrays()
{
}

void StorageImpl::_saveMapBuildingWeapons() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingWeapons;");
    const std::string query = "insert into MapBuildingWeapons values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingWeapon : mapBuildingWeapons)
    {
        auto &v = mapBuildingWeapon;
        ret = sqlite3_bind_int(stmt, 1, v->map_building->id);
        ret = sqlite3_bind_int(stmt, 2, v->weapon->id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapGoods()
{
    int ret = 0;
    const std::string query = "select * from MapGoods;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapGoods.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->map->id = (stmt, 2);
        v->good->id = (stmt, 3);
        v->x = (float)sqlite3_column_double(stmt, 4);
        v->y = (float)sqlite3_column_double(stmt, 5);
        v->z = (float)sqlite3_column_double(stmt, 6);
        v->roll = (float)sqlite3_column_double(stmt, 7);
        v->pitch = (float)sqlite3_column_double(stmt, 8);
        v->yaw = (float)sqlite3_column_double(stmt, 9);
        v->scale = (float)sqlite3_column_double(stmt, 10);
        v->scale_x = (float)sqlite3_column_double(stmt, 11);
        v->scale_y = (float)sqlite3_column_double(stmt, 12);
        v->scale_z = (float)sqlite3_column_double(stmt, 13);
        mapGoods.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapGoodsPtrs()
{
    for (auto &mapGood : mapGoods)
    {
        if (maps.find(mapGood->map->id) != maps.end())
            mapGood->map = maps[mapGood->map->id];
        if (goods.find(mapGood->good->id) != goods.end())
            mapGood->good = goods[mapGood->good->id];
    }
}

void StorageImpl::_loadMapGoodsArrays()
{
}

void StorageImpl::_saveMapGoods() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapGoods;");
    const std::string query = "insert into MapGoods values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapGood : mapGoods)
    {
        auto &v = mapGood.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->map->id);
        ret = sqlite3_bind_int(stmt, 4, v->good->id);
        ret = sqlite3_bind_double(stmt, 5, v->x);
        ret = sqlite3_bind_double(stmt, 6, v->y);
        ret = sqlite3_bind_double(stmt, 7, v->z);
        ret = sqlite3_bind_double(stmt, 8, v->roll);
        ret = sqlite3_bind_double(stmt, 9, v->pitch);
        ret = sqlite3_bind_double(stmt, 10, v->yaw);
        ret = sqlite3_bind_double(stmt, 11, v->scale);
        ret = sqlite3_bind_double(stmt, 12, v->scale_x);
        ret = sqlite3_bind_double(stmt, 13, v->scale_y);
        ret = sqlite3_bind_double(stmt, 14, v->scale_z);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapObjects()
{
    int ret = 0;
    const std::string query = "select * from MapObjects;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapObjects.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->map->id = (stmt, 2);
        v->object->id = (stmt, 3);
        v->x = (float)sqlite3_column_double(stmt, 4);
        v->y = (float)sqlite3_column_double(stmt, 5);
        v->z = (float)sqlite3_column_double(stmt, 6);
        v->roll = (float)sqlite3_column_double(stmt, 7);
        v->pitch = (float)sqlite3_column_double(stmt, 8);
        v->yaw = (float)sqlite3_column_double(stmt, 9);
        v->scale = (float)sqlite3_column_double(stmt, 10);
        v->scale_x = (float)sqlite3_column_double(stmt, 11);
        v->scale_y = (float)sqlite3_column_double(stmt, 12);
        v->scale_z = (float)sqlite3_column_double(stmt, 13);
        mapObjects.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapObjectsPtrs()
{
    for (auto &mapObject : mapObjects)
    {
        if (maps.find(mapObject->map->id) != maps.end())
            mapObject->map = maps[mapObject->map->id];
        if (objects.find(mapObject->object->id) != objects.end())
            mapObject->object = objects[mapObject->object->id];
    }
}

void StorageImpl::_loadMapObjectsArrays()
{
}

void StorageImpl::_saveMapObjects() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapObjects;");
    const std::string query = "insert into MapObjects values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapObject : mapObjects)
    {
        auto &v = mapObject.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->map->id);
        ret = sqlite3_bind_int(stmt, 4, v->object->id);
        ret = sqlite3_bind_double(stmt, 5, v->x);
        ret = sqlite3_bind_double(stmt, 6, v->y);
        ret = sqlite3_bind_double(stmt, 7, v->z);
        ret = sqlite3_bind_double(stmt, 8, v->roll);
        ret = sqlite3_bind_double(stmt, 9, v->pitch);
        ret = sqlite3_bind_double(stmt, 10, v->yaw);
        ret = sqlite3_bind_double(stmt, 11, v->scale);
        ret = sqlite3_bind_double(stmt, 12, v->scale_x);
        ret = sqlite3_bind_double(stmt, 13, v->scale_y);
        ret = sqlite3_bind_double(stmt, 14, v->scale_z);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMechanoids()
{
    int ret = 0;
    const std::string query = "select * from Mechanoids;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mechanoids.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->name->id = (stmt, 2);
        v->modification->id = (stmt, 3);
        v->map->id = (stmt, 4);
        v->clan->id = (stmt, 5);
        v->building->id = (stmt, 6);
        v->configuration->id = (stmt, 7);
        v->group->id = (stmt, 8);
        v->generation = sqlite3_column_int(stmt, 9);
        v->money = (float)sqlite3_column_double(stmt, 10);
        v->rating = (float)sqlite3_column_double(stmt, 11);
        v->rating_fight = (float)sqlite3_column_double(stmt, 12);
        v->rating_courier = (float)sqlite3_column_double(stmt, 13);
        v->rating_trade = (float)sqlite3_column_double(stmt, 14);
        v->x = (float)sqlite3_column_double(stmt, 15);
        v->y = (float)sqlite3_column_double(stmt, 16);
        v->z = (float)sqlite3_column_double(stmt, 17);
        v->roll = (float)sqlite3_column_double(stmt, 18);
        v->pitch = (float)sqlite3_column_double(stmt, 19);
        v->yaw = (float)sqlite3_column_double(stmt, 20);
        mechanoids.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMechanoidsPtrs()
{
    for (auto &mechanoid : mechanoids)
    {
        if (strings.find(mechanoid->name->id) != strings.end())
            mechanoid->name = strings[mechanoid->name->id];
        if (modifications.find(mechanoid->modification->id) != modifications.end())
            mechanoid->modification = modifications[mechanoid->modification->id];
        if (modificationMaps.find(mechanoid->map->id) != modificationMaps.end())
            mechanoid->map = modificationMaps[mechanoid->map->id];
        if (clans.find(mechanoid->clan->id) != clans.end())
            mechanoid->clan = clans[mechanoid->clan->id];
        if (mapBuildings.find(mechanoid->building->id) != mapBuildings.end())
            mechanoid->building = mapBuildings[mechanoid->building->id];
        if (configurations.find(mechanoid->configuration->id) != configurations.end())
            mechanoid->configuration = configurations[mechanoid->configuration->id];
        if (groups.find(mechanoid->group->id) != groups.end())
            mechanoid->group = groups[mechanoid->group->id];
    }
}

void StorageImpl::_loadMechanoidsArrays()
{
    for (auto &mechanoid : mechanoids)
    {
        for (auto &mechanoidQuest : mechanoidQuests)
            if (mechanoid->id == mechanoidQuest->mechanoid->id)
                mechanoid->quests->insert(mechanoidQuest);
    }
}

void StorageImpl::_saveMechanoids() const
{
    db->execute("BEGIN;");
    db->execute("delete from Mechanoids;");
    const std::string query = "insert into Mechanoids values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mechanoid : mechanoids)
    {
        auto &v = mechanoid.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->name->id);
        ret = sqlite3_bind_int(stmt, 4, v->modification->id);
        ret = sqlite3_bind_int(stmt, 5, v->map->id);
        ret = sqlite3_bind_int(stmt, 6, v->clan->id);
        ret = sqlite3_bind_int(stmt, 7, v->building->id);
        ret = sqlite3_bind_int(stmt, 8, v->configuration->id);
        ret = sqlite3_bind_int(stmt, 9, v->group->id);
        ret = sqlite3_bind_int(stmt, 10, v->generation);
        ret = sqlite3_bind_double(stmt, 11, v->money);
        ret = sqlite3_bind_double(stmt, 12, v->rating);
        ret = sqlite3_bind_double(stmt, 13, v->rating_fight);
        ret = sqlite3_bind_double(stmt, 14, v->rating_courier);
        ret = sqlite3_bind_double(stmt, 15, v->rating_trade);
        ret = sqlite3_bind_double(stmt, 16, v->x);
        ret = sqlite3_bind_double(stmt, 17, v->y);
        ret = sqlite3_bind_double(stmt, 18, v->z);
        ret = sqlite3_bind_double(stmt, 19, v->roll);
        ret = sqlite3_bind_double(stmt, 20, v->pitch);
        ret = sqlite3_bind_double(stmt, 21, v->yaw);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMechanoidQuests()
{
    int ret = 0;
    const std::string query = "select * from MechanoidQuests;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mechanoidQuests.create();
        v->mechanoid->id = (stmt, 0);
        v->quest->id = (stmt, 1);
        v->state = sqlite3_column_int(stmt, 2);
        mechanoidQuests.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMechanoidQuestsPtrs()
{
    for (auto &mechanoidQuest : mechanoidQuests)
    {
        if (mechanoids.find(mechanoidQuest->mechanoid->id) != mechanoids.end())
            mechanoidQuest->mechanoid = mechanoids[mechanoidQuest->mechanoid->id];
        if (quests.find(mechanoidQuest->quest->id) != quests.end())
            mechanoidQuest->quest = quests[mechanoidQuest->quest->id];
    }
}

void StorageImpl::_loadMechanoidQuestsArrays()
{
}

void StorageImpl::_saveMechanoidQuests() const
{
    db->execute("BEGIN;");
    db->execute("delete from MechanoidQuests;");
    const std::string query = "insert into MechanoidQuests values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mechanoidQuest : mechanoidQuests)
    {
        auto &v = mechanoidQuest;
        ret = sqlite3_bind_int(stmt, 1, v->mechanoid->id);
        ret = sqlite3_bind_int(stmt, 2, v->quest->id);
        ret = sqlite3_bind_int(stmt, 3, v->state);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadModifications()
{
    int ret = 0;
    const std::string query = "select * from Modifications;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = modifications.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->name->id = (stmt, 1);
        v->directory = (const char *)sqlite3_column_text(stmt, 2);
        v->author = (const char *)sqlite3_column_text(stmt, 3);
        v->date_created = (const char *)sqlite3_column_text(stmt, 4);
        v->date_modified = (const char *)sqlite3_column_text(stmt, 5);
        v->comment = (const char *)sqlite3_column_text(stmt, 6);
        v->version = (const char *)sqlite3_column_text(stmt, 7);
        v->script_language = (const char *)sqlite3_column_text(stmt, 8);
        v->script_main = (const char *)sqlite3_column_text(stmt, 9);
        v->player_mechanoid->id = (stmt, 10);
        v->cooperative_player_configuration->id = (stmt, 11);
        modifications.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadModificationsPtrs()
{
    for (auto &modification : modifications)
    {
        if (strings.find(modification->name->id) != strings.end())
            modification->name = strings[modification->name->id];
        if (mechanoids.find(modification->player_mechanoid->id) != mechanoids.end())
            modification->player_mechanoid = mechanoids[modification->player_mechanoid->id];
        if (configurations.find(modification->cooperative_player_configuration->id) != configurations.end())
            modification->cooperative_player_configuration = configurations[modification->cooperative_player_configuration->id];
    }
}

void StorageImpl::_loadModificationsArrays()
{
    for (auto &modification : modifications)
    {
        for (auto &modificationMap : modificationMaps)
            if (modification->id == modificationMap->modification->id)
                modification->maps->insert(modificationMap);
        for (auto &clan : clans)
            if (modification->id == clan->modification->id)
                modification->clans->insert(clan);
        for (auto &mechanoid : mechanoids)
            if (modification->id == mechanoid->modification->id)
                modification->mechanoids->insert(mechanoid);
    }
}

void StorageImpl::_saveModifications() const
{
    db->execute("BEGIN;");
    db->execute("delete from Modifications;");
    const std::string query = "insert into Modifications values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &modification : modifications)
    {
        auto &v = modification.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_int(stmt, 2, v->name->id);
        ret = sqlite3_bind_text(stmt, 3, std::to_string(v->directory).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 4, std::to_string(v->author).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 5, std::to_string(v->date_created).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 6, std::to_string(v->date_modified).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 7, std::to_string(v->comment).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 8, std::to_string(v->version).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 9, std::to_string(v->script_language).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 10, std::to_string(v->script_main).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 11, v->player_mechanoid->id);
        ret = sqlite3_bind_int(stmt, 12, v->cooperative_player_configuration->id);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadModificationMaps()
{
    int ret = 0;
    const std::string query = "select * from ModificationMaps;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = modificationMaps.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->modification->id = (stmt, 1);
        v->map->id = (stmt, 2);
        modificationMaps.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadModificationMapsPtrs()
{
    for (auto &modificationMap : modificationMaps)
    {
        if (modifications.find(modificationMap->modification->id) != modifications.end())
            modificationMap->modification = modifications[modificationMap->modification->id];
        if (maps.find(modificationMap->map->id) != maps.end())
            modificationMap->map = maps[modificationMap->map->id];
    }
}

void StorageImpl::_loadModificationMapsArrays()
{
}

void StorageImpl::_saveModificationMaps() const
{
    db->execute("BEGIN;");
    db->execute("delete from ModificationMaps;");
    const std::string query = "insert into ModificationMaps values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &modificationMap : modificationMaps)
    {
        auto &v = modificationMap.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_int(stmt, 2, v->modification->id);
        ret = sqlite3_bind_int(stmt, 3, v->map->id);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadModificators()
{
    int ret = 0;
    const std::string query = "select * from Modificators;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = modificators.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name->id = (stmt, 3);
        v->probability = (float)sqlite3_column_double(stmt, 4);
        v->price = (float)sqlite3_column_double(stmt, 5);
        v->k_price = (float)sqlite3_column_double(stmt, 6);
        v->k_param1 = (float)sqlite3_column_double(stmt, 7);
        v->k_param2 = (float)sqlite3_column_double(stmt, 8);
        v->unicum_id = sqlite3_column_int(stmt, 9);
        v->mask = sqlite3_column_int(stmt, 10);
        modificators.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadModificatorsPtrs()
{
    for (auto &modificator : modificators)
    {
        if (strings.find(modificator->name->id) != strings.end())
            modificator->name = strings[modificator->name->id];
    }
}

void StorageImpl::_loadModificatorsArrays()
{
}

void StorageImpl::_saveModificators() const
{
    db->execute("BEGIN;");
    db->execute("delete from Modificators;");
    const std::string query = "insert into Modificators values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &modificator : modificators)
    {
        auto &v = modificator.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->name->id);
        ret = sqlite3_bind_double(stmt, 5, v->probability);
        ret = sqlite3_bind_double(stmt, 6, v->price);
        ret = sqlite3_bind_double(stmt, 7, v->k_price);
        ret = sqlite3_bind_double(stmt, 8, v->k_param1);
        ret = sqlite3_bind_double(stmt, 9, v->k_param2);
        ret = sqlite3_bind_int(stmt, 10, v->unicum_id);
        ret = sqlite3_bind_int(stmt, 11, v->mask);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadObjects()
{
    int ret = 0;
    const std::string query = "select * from Objects;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = objects.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name->id = (stmt, 3);
        v->type = sqlite3_column_int(stmt, 4);
        v->scale = (float)sqlite3_column_double(stmt, 5);
        v->scale_x = (float)sqlite3_column_double(stmt, 6);
        v->scale_y = (float)sqlite3_column_double(stmt, 7);
        v->scale_z = (float)sqlite3_column_double(stmt, 8);
        objects.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadObjectsPtrs()
{
    for (auto &object : objects)
    {
        if (strings.find(object->name->id) != strings.end())
            object->name = strings[object->name->id];
    }
}

void StorageImpl::_loadObjectsArrays()
{
}

void StorageImpl::_saveObjects() const
{
    db->execute("BEGIN;");
    db->execute("delete from Objects;");
    const std::string query = "insert into Objects values (?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &object : objects)
    {
        auto &v = object.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->name->id);
        ret = sqlite3_bind_int(stmt, 5, v->type);
        ret = sqlite3_bind_double(stmt, 6, v->scale);
        ret = sqlite3_bind_double(stmt, 7, v->scale_x);
        ret = sqlite3_bind_double(stmt, 8, v->scale_y);
        ret = sqlite3_bind_double(stmt, 9, v->scale_z);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadPlayers()
{
    int ret = 0;
    const std::string query = "select * from Players;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = players.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->mechanoid->id = (stmt, 1);
        players.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadPlayersPtrs()
{
    for (auto &player : players)
    {
        if (mechanoids.find(player->mechanoid->id) != mechanoids.end())
            player->mechanoid = mechanoids[player->mechanoid->id];
    }
}

void StorageImpl::_loadPlayersArrays()
{
}

void StorageImpl::_savePlayers() const
{
    db->execute("BEGIN;");
    db->execute("delete from Players;");
    const std::string query = "insert into Players values (?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &player : players)
    {
        auto &v = player.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_int(stmt, 2, v->mechanoid->id);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadProjectiles()
{
    int ret = 0;
    const std::string query = "select * from Projectiles;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = projectiles.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name->id = (stmt, 3);
        v->type = sqlite3_column_int(stmt, 4);
        v->subtype = sqlite3_column_int(stmt, 5);
        v->weight = (float)sqlite3_column_double(stmt, 6);
        v->damage = (float)sqlite3_column_double(stmt, 7);
        v->T = (float)sqlite3_column_double(stmt, 8);
        v->speed = (float)sqlite3_column_double(stmt, 9);
        v->scale = (float)sqlite3_column_double(stmt, 10);
        v->numstate = sqlite3_column_int(stmt, 11);
        v->rotate = (float)sqlite3_column_double(stmt, 12);
        v->life_time = (float)sqlite3_column_double(stmt, 13);
        v->detonation_delay = (float)sqlite3_column_double(stmt, 14);
        v->distance_detonation = (float)sqlite3_column_double(stmt, 15);
        v->strength = (float)sqlite3_column_double(stmt, 16);
        v->price = (float)sqlite3_column_double(stmt, 17);
        v->notrade = sqlite3_column_int(stmt, 18);
        projectiles.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadProjectilesPtrs()
{
    for (auto &projectile : projectiles)
    {
        if (strings.find(projectile->name->id) != strings.end())
            projectile->name = strings[projectile->name->id];
    }
}

void StorageImpl::_loadProjectilesArrays()
{
}

void StorageImpl::_saveProjectiles() const
{
    db->execute("BEGIN;");
    db->execute("delete from Projectiles;");
    const std::string query = "insert into Projectiles values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &projectile : projectiles)
    {
        auto &v = projectile.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->name->id);
        ret = sqlite3_bind_int(stmt, 5, v->type);
        ret = sqlite3_bind_int(stmt, 6, v->subtype);
        ret = sqlite3_bind_double(stmt, 7, v->weight);
        ret = sqlite3_bind_double(stmt, 8, v->damage);
        ret = sqlite3_bind_double(stmt, 9, v->T);
        ret = sqlite3_bind_double(stmt, 10, v->speed);
        ret = sqlite3_bind_double(stmt, 11, v->scale);
        ret = sqlite3_bind_int(stmt, 12, v->numstate);
        ret = sqlite3_bind_double(stmt, 13, v->rotate);
        ret = sqlite3_bind_double(stmt, 14, v->life_time);
        ret = sqlite3_bind_double(stmt, 15, v->detonation_delay);
        ret = sqlite3_bind_double(stmt, 16, v->distance_detonation);
        ret = sqlite3_bind_double(stmt, 17, v->strength);
        ret = sqlite3_bind_double(stmt, 18, v->price);
        ret = sqlite3_bind_int(stmt, 19, v->notrade);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuests()
{
    int ret = 0;
    const std::string query = "select * from Quests;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = quests.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->name->id = (stmt, 1);
        v->title->id = (stmt, 2);
        v->description->id = (stmt, 3);
        v->time = sqlite3_column_int(stmt, 4);
        quests.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestsPtrs()
{
    for (auto &quest : quests)
    {
        if (strings.find(quest->name->id) != strings.end())
            quest->name = strings[quest->name->id];
        if (strings.find(quest->title->id) != strings.end())
            quest->title = strings[quest->title->id];
        if (strings.find(quest->description->id) != strings.end())
            quest->description = strings[quest->description->id];
    }
}

void StorageImpl::_loadQuestsArrays()
{
    for (auto &quest : quests)
    {
        for (auto &questReward : questRewards)
            if (quest->id == questReward->quest->id)
                quest->rewards->insert(questReward);
    }
}

void StorageImpl::_saveQuests() const
{
    db->execute("BEGIN;");
    db->execute("delete from Quests;");
    const std::string query = "insert into Quests values (?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &quest : quests)
    {
        auto &v = quest.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_int(stmt, 2, v->name->id);
        ret = sqlite3_bind_int(stmt, 3, v->title->id);
        ret = sqlite3_bind_int(stmt, 4, v->description->id);
        ret = sqlite3_bind_int(stmt, 5, v->time);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewards()
{
    int ret = 0;
    const std::string query = "select * from QuestRewards;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewards.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->quest->id = (stmt, 2);
        v->money = (float)sqlite3_column_double(stmt, 3);
        v->rating = (float)sqlite3_column_double(stmt, 4);
        questRewards.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardsPtrs()
{
    for (auto &questReward : questRewards)
    {
        if (quests.find(questReward->quest->id) != quests.end())
            questReward->quest = quests[questReward->quest->id];
    }
}

void StorageImpl::_loadQuestRewardsArrays()
{
    for (auto &questReward : questRewards)
    {
        for (auto &questRewardEquipment : questRewardEquipments)
            if (questReward->id == questRewardEquipment->quest_reward->id)
                questReward->equipments->insert(questRewardEquipment);
        for (auto &questRewardGlider : questRewardGliders)
            if (questReward->id == questRewardGlider->quest_reward->id)
                questReward->gliders->insert(questRewardGlider);
        for (auto &questRewardGood : questRewardGoods)
            if (questReward->id == questRewardGood->quest_reward->id)
                questReward->goods->insert(questRewardGood);
        for (auto &questRewardModificator : questRewardModificators)
            if (questReward->id == questRewardModificator->quest_reward->id)
                questReward->modificators->insert(questRewardModificator);
        for (auto &questRewardProjectile : questRewardProjectiles)
            if (questReward->id == questRewardProjectile->quest_reward->id)
                questReward->projectiles->insert(questRewardProjectile);
        for (auto &questRewardReputation : questRewardReputations)
            if (questReward->id == questRewardReputation->quest_reward->id)
                questReward->reputations->insert(questRewardReputation);
        for (auto &questRewardWeapon : questRewardWeapons)
            if (questReward->id == questRewardWeapon->quest_reward->id)
                questReward->weapons->insert(questRewardWeapon);
    }
}

void StorageImpl::_saveQuestRewards() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewards;");
    const std::string query = "insert into QuestRewards values (?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questReward : questRewards)
    {
        auto &v = questReward.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->quest->id);
        ret = sqlite3_bind_double(stmt, 4, v->money);
        ret = sqlite3_bind_double(stmt, 5, v->rating);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardEquipments()
{
    int ret = 0;
    const std::string query = "select * from QuestRewardEquipments;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardEquipments.create();
        v->quest_reward->id = (stmt, 0);
        v->equipment->id = (stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardEquipments.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardEquipmentsPtrs()
{
    for (auto &questRewardEquipment : questRewardEquipments)
    {
        if (questRewards.find(questRewardEquipment->quest_reward->id) != questRewards.end())
            questRewardEquipment->quest_reward = questRewards[questRewardEquipment->quest_reward->id];
        if (equipments.find(questRewardEquipment->equipment->id) != equipments.end())
            questRewardEquipment->equipment = equipments[questRewardEquipment->equipment->id];
    }
}

void StorageImpl::_loadQuestRewardEquipmentsArrays()
{
}

void StorageImpl::_saveQuestRewardEquipments() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardEquipments;");
    const std::string query = "insert into QuestRewardEquipments values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardEquipment : questRewardEquipments)
    {
        auto &v = questRewardEquipment;
        ret = sqlite3_bind_int(stmt, 1, v->quest_reward->id);
        ret = sqlite3_bind_int(stmt, 2, v->equipment->id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardGliders()
{
    int ret = 0;
    const std::string query = "select * from QuestRewardGliders;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardGliders.create();
        v->quest_reward->id = (stmt, 0);
        v->glider->id = (stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardGliders.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardGlidersPtrs()
{
    for (auto &questRewardGlider : questRewardGliders)
    {
        if (questRewards.find(questRewardGlider->quest_reward->id) != questRewards.end())
            questRewardGlider->quest_reward = questRewards[questRewardGlider->quest_reward->id];
        if (gliders.find(questRewardGlider->glider->id) != gliders.end())
            questRewardGlider->glider = gliders[questRewardGlider->glider->id];
    }
}

void StorageImpl::_loadQuestRewardGlidersArrays()
{
}

void StorageImpl::_saveQuestRewardGliders() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardGliders;");
    const std::string query = "insert into QuestRewardGliders values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardGlider : questRewardGliders)
    {
        auto &v = questRewardGlider;
        ret = sqlite3_bind_int(stmt, 1, v->quest_reward->id);
        ret = sqlite3_bind_int(stmt, 2, v->glider->id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardGoods()
{
    int ret = 0;
    const std::string query = "select * from QuestRewardGoods;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardGoods.create();
        v->quest_reward->id = (stmt, 0);
        v->good->id = (stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardGoods.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardGoodsPtrs()
{
    for (auto &questRewardGood : questRewardGoods)
    {
        if (questRewards.find(questRewardGood->quest_reward->id) != questRewards.end())
            questRewardGood->quest_reward = questRewards[questRewardGood->quest_reward->id];
        if (goods.find(questRewardGood->good->id) != goods.end())
            questRewardGood->good = goods[questRewardGood->good->id];
    }
}

void StorageImpl::_loadQuestRewardGoodsArrays()
{
}

void StorageImpl::_saveQuestRewardGoods() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardGoods;");
    const std::string query = "insert into QuestRewardGoods values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardGood : questRewardGoods)
    {
        auto &v = questRewardGood;
        ret = sqlite3_bind_int(stmt, 1, v->quest_reward->id);
        ret = sqlite3_bind_int(stmt, 2, v->good->id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardModificators()
{
    int ret = 0;
    const std::string query = "select * from QuestRewardModificators;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardModificators.create();
        v->quest_reward->id = (stmt, 0);
        v->modificator->id = (stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardModificators.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardModificatorsPtrs()
{
    for (auto &questRewardModificator : questRewardModificators)
    {
        if (questRewards.find(questRewardModificator->quest_reward->id) != questRewards.end())
            questRewardModificator->quest_reward = questRewards[questRewardModificator->quest_reward->id];
        if (modificators.find(questRewardModificator->modificator->id) != modificators.end())
            questRewardModificator->modificator = modificators[questRewardModificator->modificator->id];
    }
}

void StorageImpl::_loadQuestRewardModificatorsArrays()
{
}

void StorageImpl::_saveQuestRewardModificators() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardModificators;");
    const std::string query = "insert into QuestRewardModificators values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardModificator : questRewardModificators)
    {
        auto &v = questRewardModificator;
        ret = sqlite3_bind_int(stmt, 1, v->quest_reward->id);
        ret = sqlite3_bind_int(stmt, 2, v->modificator->id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardProjectiles()
{
    int ret = 0;
    const std::string query = "select * from QuestRewardProjectiles;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardProjectiles.create();
        v->quest_reward->id = (stmt, 0);
        v->projectile->id = (stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardProjectiles.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardProjectilesPtrs()
{
    for (auto &questRewardProjectile : questRewardProjectiles)
    {
        if (questRewards.find(questRewardProjectile->quest_reward->id) != questRewards.end())
            questRewardProjectile->quest_reward = questRewards[questRewardProjectile->quest_reward->id];
        if (projectiles.find(questRewardProjectile->projectile->id) != projectiles.end())
            questRewardProjectile->projectile = projectiles[questRewardProjectile->projectile->id];
    }
}

void StorageImpl::_loadQuestRewardProjectilesArrays()
{
}

void StorageImpl::_saveQuestRewardProjectiles() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardProjectiles;");
    const std::string query = "insert into QuestRewardProjectiles values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardProjectile : questRewardProjectiles)
    {
        auto &v = questRewardProjectile;
        ret = sqlite3_bind_int(stmt, 1, v->quest_reward->id);
        ret = sqlite3_bind_int(stmt, 2, v->projectile->id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardReputations()
{
    int ret = 0;
    const std::string query = "select * from QuestRewardReputations;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardReputations.create();
        v->quest_reward->id = (stmt, 0);
        v->clan->id = (stmt, 1);
        v->quantity = (float)sqlite3_column_double(stmt, 2);
        questRewardReputations.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardReputationsPtrs()
{
    for (auto &questRewardReputation : questRewardReputations)
    {
        if (questRewards.find(questRewardReputation->quest_reward->id) != questRewards.end())
            questRewardReputation->quest_reward = questRewards[questRewardReputation->quest_reward->id];
        if (clans.find(questRewardReputation->clan->id) != clans.end())
            questRewardReputation->clan = clans[questRewardReputation->clan->id];
    }
}

void StorageImpl::_loadQuestRewardReputationsArrays()
{
}

void StorageImpl::_saveQuestRewardReputations() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardReputations;");
    const std::string query = "insert into QuestRewardReputations values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardReputation : questRewardReputations)
    {
        auto &v = questRewardReputation;
        ret = sqlite3_bind_int(stmt, 1, v->quest_reward->id);
        ret = sqlite3_bind_int(stmt, 2, v->clan->id);
        ret = sqlite3_bind_double(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardWeapons()
{
    int ret = 0;
    const std::string query = "select * from QuestRewardWeapons;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardWeapons.create();
        v->quest_reward->id = (stmt, 0);
        v->weapon->id = (stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardWeapons.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardWeaponsPtrs()
{
    for (auto &questRewardWeapon : questRewardWeapons)
    {
        if (questRewards.find(questRewardWeapon->quest_reward->id) != questRewards.end())
            questRewardWeapon->quest_reward = questRewards[questRewardWeapon->quest_reward->id];
        if (weapons.find(questRewardWeapon->weapon->id) != weapons.end())
            questRewardWeapon->weapon = weapons[questRewardWeapon->weapon->id];
    }
}

void StorageImpl::_loadQuestRewardWeaponsArrays()
{
}

void StorageImpl::_saveQuestRewardWeapons() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardWeapons;");
    const std::string query = "insert into QuestRewardWeapons values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardWeapon : questRewardWeapons)
    {
        auto &v = questRewardWeapon;
        ret = sqlite3_bind_int(stmt, 1, v->quest_reward->id);
        ret = sqlite3_bind_int(stmt, 2, v->weapon->id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadScriptVariables()
{
    int ret = 0;
    const std::string query = "select * from ScriptVariables;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = scriptVariables.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->variable = (const char *)sqlite3_column_text(stmt, 1);
        v->value_int = sqlite3_column_int(stmt, 2);
        v->value_float = (float)sqlite3_column_double(stmt, 3);
        v->value_text = (const char *)sqlite3_column_text(stmt, 4);
        scriptVariables.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadScriptVariablesPtrs()
{
}

void StorageImpl::_loadScriptVariablesArrays()
{
}

void StorageImpl::_saveScriptVariables() const
{
    db->execute("BEGIN;");
    db->execute("delete from ScriptVariables;");
    const std::string query = "insert into ScriptVariables values (?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &scriptVariable : scriptVariables)
    {
        auto &v = scriptVariable.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->variable).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->value_int);
        ret = sqlite3_bind_double(stmt, 4, v->value_float);
        ret = sqlite3_bind_text(stmt, 5, std::to_string(v->value_text).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadSettings()
{
    int ret = 0;
    const std::string query = "select * from Settings;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = settings.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->player->id = (stmt, 2);
        v->value_int = sqlite3_column_int(stmt, 3);
        v->value_float = (float)sqlite3_column_double(stmt, 4);
        v->value_text = (const char *)sqlite3_column_text(stmt, 5);
        v->value_blob = Blob(sqlite3_column_blob(stmt, 6), sqlite3_column_bytes(stmt, 6));
        settings.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadSettingsPtrs()
{
    for (auto &setting : settings)
    {
        if (players.find(setting->player->id) != players.end())
            setting->player = players[setting->player->id];
    }
}

void StorageImpl::_loadSettingsArrays()
{
}

void StorageImpl::_saveSettings() const
{
    db->execute("BEGIN;");
    db->execute("delete from Settings;");
    const std::string query = "insert into Settings values (?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &setting : settings)
    {
        auto &v = setting.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->player->id);
        ret = sqlite3_bind_int(stmt, 4, v->value_int);
        ret = sqlite3_bind_double(stmt, 5, v->value_float);
        ret = sqlite3_bind_text(stmt, 6, std::to_string(v->value_text).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_blob(stmt, 7, v->value_blob.getRawData(), v->value_blob.getLength(), SQLITE_TRANSIENT);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadStrings()
{
    int ret = 0;
    const std::string query = "select * from Strings;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = strings.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->table->id = (stmt, 2);
        v->ru = (const char *)sqlite3_column_text(stmt, 3);
        v->en = (const char *)sqlite3_column_text(stmt, 4);
        strings.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadStringsPtrs()
{
    for (auto &string : strings)
    {
        if (tables.find(string->table->id) != tables.end())
            string->table = tables[string->table->id];
    }
}

void StorageImpl::_loadStringsArrays()
{
}

void StorageImpl::_saveStrings() const
{
    db->execute("BEGIN;");
    db->execute("delete from Strings;");
    const std::string query = "insert into Strings values (?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &string : strings)
    {
        auto &v = string.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->table->id);
        ret = sqlite3_bind_text(stmt, 4, std::to_string(v->ru).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 5, std::to_string(v->en).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadTables()
{
    int ret = 0;
    const std::string query = "select * from Tables;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = tables.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text = (const char *)sqlite3_column_text(stmt, 1);
        tables.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadTablesPtrs()
{
}

void StorageImpl::_loadTablesArrays()
{
}

void StorageImpl::_saveTables() const
{
    db->execute("BEGIN;");
    db->execute("delete from Tables;");
    const std::string query = "insert into Tables values (?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &table : tables)
    {
        auto &v = table.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadWeapons()
{
    int ret = 0;
    const std::string query = "select * from Weapons;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = weapons.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name->id = (stmt, 3);
        v->projectile->id = (stmt, 4);
        v->type = sqlite3_column_int(stmt, 5);
        v->standard = sqlite3_column_int(stmt, 6);
        v->weight = (float)sqlite3_column_double(stmt, 7);
        v->power = (float)sqlite3_column_double(stmt, 8);
        v->firerate = (float)sqlite3_column_double(stmt, 9);
        v->damage = (float)sqlite3_column_double(stmt, 10);
        v->price = (float)sqlite3_column_double(stmt, 11);
        v->fx = (float)sqlite3_column_double(stmt, 12);
        v->shoottype = sqlite3_column_int(stmt, 13);
        v->shootscale = (float)sqlite3_column_double(stmt, 14);
        v->xstate = sqlite3_column_int(stmt, 15);
        v->rcolor = (float)sqlite3_column_double(stmt, 16);
        v->gcolor = (float)sqlite3_column_double(stmt, 17);
        v->bcolor = (float)sqlite3_column_double(stmt, 18);
        v->typearms = sqlite3_column_int(stmt, 19);
        v->tfire = (float)sqlite3_column_double(stmt, 20);
        v->vtype = sqlite3_column_int(stmt, 21);
        v->spare = (float)sqlite3_column_double(stmt, 22);
        v->reconstruction = (float)sqlite3_column_double(stmt, 23);
        v->maxdistance = (float)sqlite3_column_double(stmt, 24);
        v->angle = (float)sqlite3_column_double(stmt, 25);
        v->fxtime = (float)sqlite3_column_double(stmt, 26);
        v->damagetype = sqlite3_column_int(stmt, 27);
        v->fxmodeltime = (float)sqlite3_column_double(stmt, 28);
        v->inside_mul = (float)sqlite3_column_double(stmt, 29);
        v->inside_x = (float)sqlite3_column_double(stmt, 30);
        v->inside_y = (float)sqlite3_column_double(stmt, 31);
        v->inside_z = (float)sqlite3_column_double(stmt, 32);
        v->notrade = sqlite3_column_int(stmt, 33);
        weapons.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadWeaponsPtrs()
{
    for (auto &weapon : weapons)
    {
        if (strings.find(weapon->name->id) != strings.end())
            weapon->name = strings[weapon->name->id];
        if (projectiles.find(weapon->projectile->id) != projectiles.end())
            weapon->projectile = projectiles[weapon->projectile->id];
    }
}

void StorageImpl::_loadWeaponsArrays()
{
}

void StorageImpl::_saveWeapons() const
{
    db->execute("BEGIN;");
    db->execute("delete from Weapons;");
    const std::string query = "insert into Weapons values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &weapon : weapons)
    {
        auto &v = weapon.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->name->id);
        ret = sqlite3_bind_int(stmt, 5, v->projectile->id);
        ret = sqlite3_bind_int(stmt, 6, v->type);
        ret = sqlite3_bind_int(stmt, 7, v->standard);
        ret = sqlite3_bind_double(stmt, 8, v->weight);
        ret = sqlite3_bind_double(stmt, 9, v->power);
        ret = sqlite3_bind_double(stmt, 10, v->firerate);
        ret = sqlite3_bind_double(stmt, 11, v->damage);
        ret = sqlite3_bind_double(stmt, 12, v->price);
        ret = sqlite3_bind_double(stmt, 13, v->fx);
        ret = sqlite3_bind_int(stmt, 14, v->shoottype);
        ret = sqlite3_bind_double(stmt, 15, v->shootscale);
        ret = sqlite3_bind_int(stmt, 16, v->xstate);
        ret = sqlite3_bind_double(stmt, 17, v->rcolor);
        ret = sqlite3_bind_double(stmt, 18, v->gcolor);
        ret = sqlite3_bind_double(stmt, 19, v->bcolor);
        ret = sqlite3_bind_int(stmt, 20, v->typearms);
        ret = sqlite3_bind_double(stmt, 21, v->tfire);
        ret = sqlite3_bind_int(stmt, 22, v->vtype);
        ret = sqlite3_bind_double(stmt, 23, v->spare);
        ret = sqlite3_bind_double(stmt, 24, v->reconstruction);
        ret = sqlite3_bind_double(stmt, 25, v->maxdistance);
        ret = sqlite3_bind_double(stmt, 26, v->angle);
        ret = sqlite3_bind_double(stmt, 27, v->fxtime);
        ret = sqlite3_bind_int(stmt, 28, v->damagetype);
        ret = sqlite3_bind_double(stmt, 29, v->fxmodeltime);
        ret = sqlite3_bind_double(stmt, 30, v->inside_mul);
        ret = sqlite3_bind_double(stmt, 31, v->inside_x);
        ret = sqlite3_bind_double(stmt, 32, v->inside_y);
        ret = sqlite3_bind_double(stmt, 33, v->inside_z);
        ret = sqlite3_bind_int(stmt, 34, v->notrade);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::create() const
{
    db->execute(Building::getSql());
    db->execute(Clan::getSql());
    db->execute(ClanReputation::getSql());
    db->execute(Configuration::getSql());
    db->execute(ConfigurationEquipment::getSql());
    db->execute(ConfigurationGood::getSql());
    db->execute(ConfigurationProjectile::getSql());
    db->execute(ConfigurationWeapon::getSql());
    db->execute(Equipment::getSql());
    db->execute(Glider::getSql());
    db->execute(Good::getSql());
    db->execute(Group::getSql());
    db->execute(GroupMechanoid::getSql());
    db->execute(Map::getSql());
    db->execute(MapBuilding::getSql());
    db->execute(MapBuildingEquipment::getSql());
    db->execute(MapBuildingGlider::getSql());
    db->execute(MapBuildingGood::getSql());
    db->execute(MapBuildingModificator::getSql());
    db->execute(MapBuildingProjectile::getSql());
    db->execute(MapBuildingWeapon::getSql());
    db->execute(MapGood::getSql());
    db->execute(MapObject::getSql());
    db->execute(Mechanoid::getSql());
    db->execute(MechanoidQuest::getSql());
    db->execute(Modification::getSql());
    db->execute(ModificationMap::getSql());
    db->execute(Modificator::getSql());
    db->execute(Object::getSql());
    db->execute(Player::getSql());
    db->execute(Projectile::getSql());
    db->execute(Quest::getSql());
    db->execute(QuestReward::getSql());
    db->execute(QuestRewardEquipment::getSql());
    db->execute(QuestRewardGlider::getSql());
    db->execute(QuestRewardGood::getSql());
    db->execute(QuestRewardModificator::getSql());
    db->execute(QuestRewardProjectile::getSql());
    db->execute(QuestRewardReputation::getSql());
    db->execute(QuestRewardWeapon::getSql());
    db->execute(ScriptVariable::getSql());
    db->execute(Setting::getSql());
    db->execute(String::getSql());
    db->execute(Table::getSql());
    db->execute(Weapon::getSql());
}

void StorageImpl::clear()
{
    buildings.clear();
    clans.clear();
    clanReputations.clear();
    configurations.clear();
    configurationEquipments.clear();
    configurationGoods.clear();
    configurationProjectiles.clear();
    configurationWeapons.clear();
    equipments.clear();
    gliders.clear();
    goods.clear();
    groups.clear();
    groupMechanoids.clear();
    maps.clear();
    mapBuildings.clear();
    mapBuildingEquipments.clear();
    mapBuildingGliders.clear();
    mapBuildingGoods.clear();
    mapBuildingModificators.clear();
    mapBuildingProjectiles.clear();
    mapBuildingWeapons.clear();
    mapGoods.clear();
    mapObjects.clear();
    mechanoids.clear();
    mechanoidQuests.clear();
    modifications.clear();
    modificationMaps.clear();
    modificators.clear();
    objects.clear();
    players.clear();
    projectiles.clear();
    quests.clear();
    questRewards.clear();
    questRewardEquipments.clear();
    questRewardGliders.clear();
    questRewardGoods.clear();
    questRewardModificators.clear();
    questRewardProjectiles.clear();
    questRewardReputations.clear();
    questRewardWeapons.clear();
    scriptVariables.clear();
    settings.clear();
    strings.clear();
    tables.clear();
    weapons.clear();
}

void StorageImpl::load(ProgressCallback callback)
{
    _loadBuildings();
    PROGRESS_CALLBACK(0.740741);
    _loadClans();
    PROGRESS_CALLBACK(1.481481);
    _loadClanReputations();
    PROGRESS_CALLBACK(2.222222);
    _loadConfigurations();
    PROGRESS_CALLBACK(2.962963);
    _loadConfigurationEquipments();
    PROGRESS_CALLBACK(3.703704);
    _loadConfigurationGoods();
    PROGRESS_CALLBACK(4.444444);
    _loadConfigurationProjectiles();
    PROGRESS_CALLBACK(5.185185);
    _loadConfigurationWeapons();
    PROGRESS_CALLBACK(5.925926);
    _loadEquipments();
    PROGRESS_CALLBACK(6.666667);
    _loadGliders();
    PROGRESS_CALLBACK(7.407407);
    _loadGoods();
    PROGRESS_CALLBACK(8.148148);
    _loadGroups();
    PROGRESS_CALLBACK(8.888889);
    _loadGroupMechanoids();
    PROGRESS_CALLBACK(9.629630);
    _loadMaps();
    PROGRESS_CALLBACK(10.370370);
    _loadMapBuildings();
    PROGRESS_CALLBACK(11.111111);
    _loadMapBuildingEquipments();
    PROGRESS_CALLBACK(11.851852);
    _loadMapBuildingGliders();
    PROGRESS_CALLBACK(12.592593);
    _loadMapBuildingGoods();
    PROGRESS_CALLBACK(13.333333);
    _loadMapBuildingModificators();
    PROGRESS_CALLBACK(14.074074);
    _loadMapBuildingProjectiles();
    PROGRESS_CALLBACK(14.814815);
    _loadMapBuildingWeapons();
    PROGRESS_CALLBACK(15.555556);
    _loadMapGoods();
    PROGRESS_CALLBACK(16.296296);
    _loadMapObjects();
    PROGRESS_CALLBACK(17.037037);
    _loadMechanoids();
    PROGRESS_CALLBACK(17.777778);
    _loadMechanoidQuests();
    PROGRESS_CALLBACK(18.518519);
    _loadModifications();
    PROGRESS_CALLBACK(19.259259);
    _loadModificationMaps();
    PROGRESS_CALLBACK(20.000000);
    _loadModificators();
    PROGRESS_CALLBACK(20.740741);
    _loadObjects();
    PROGRESS_CALLBACK(21.481481);
    _loadPlayers();
    PROGRESS_CALLBACK(22.222222);
    _loadProjectiles();
    PROGRESS_CALLBACK(22.962963);
    _loadQuests();
    PROGRESS_CALLBACK(23.703704);
    _loadQuestRewards();
    PROGRESS_CALLBACK(24.444444);
    _loadQuestRewardEquipments();
    PROGRESS_CALLBACK(25.185185);
    _loadQuestRewardGliders();
    PROGRESS_CALLBACK(25.925926);
    _loadQuestRewardGoods();
    PROGRESS_CALLBACK(26.666667);
    _loadQuestRewardModificators();
    PROGRESS_CALLBACK(27.407407);
    _loadQuestRewardProjectiles();
    PROGRESS_CALLBACK(28.148148);
    _loadQuestRewardReputations();
    PROGRESS_CALLBACK(28.888889);
    _loadQuestRewardWeapons();
    PROGRESS_CALLBACK(29.629630);
    _loadScriptVariables();
    PROGRESS_CALLBACK(30.370370);
    _loadSettings();
    PROGRESS_CALLBACK(31.111111);
    _loadStrings();
    PROGRESS_CALLBACK(31.851852);
    _loadTables();
    PROGRESS_CALLBACK(32.592593);
    _loadWeapons();
    PROGRESS_CALLBACK(33.333333);

    _loadBuildingsPtrs();
    PROGRESS_CALLBACK(34.074074);
    _loadClansPtrs();
    PROGRESS_CALLBACK(34.814815);
    _loadClanReputationsPtrs();
    PROGRESS_CALLBACK(35.555556);
    _loadConfigurationsPtrs();
    PROGRESS_CALLBACK(36.296296);
    _loadConfigurationEquipmentsPtrs();
    PROGRESS_CALLBACK(37.037037);
    _loadConfigurationGoodsPtrs();
    PROGRESS_CALLBACK(37.777778);
    _loadConfigurationProjectilesPtrs();
    PROGRESS_CALLBACK(38.518519);
    _loadConfigurationWeaponsPtrs();
    PROGRESS_CALLBACK(39.259259);
    _loadEquipmentsPtrs();
    PROGRESS_CALLBACK(40.000000);
    _loadGlidersPtrs();
    PROGRESS_CALLBACK(40.740741);
    _loadGoodsPtrs();
    PROGRESS_CALLBACK(41.481481);
    _loadGroupsPtrs();
    PROGRESS_CALLBACK(42.222222);
    _loadGroupMechanoidsPtrs();
    PROGRESS_CALLBACK(42.962963);
    _loadMapsPtrs();
    PROGRESS_CALLBACK(43.703704);
    _loadMapBuildingsPtrs();
    PROGRESS_CALLBACK(44.444444);
    _loadMapBuildingEquipmentsPtrs();
    PROGRESS_CALLBACK(45.185185);
    _loadMapBuildingGlidersPtrs();
    PROGRESS_CALLBACK(45.925926);
    _loadMapBuildingGoodsPtrs();
    PROGRESS_CALLBACK(46.666667);
    _loadMapBuildingModificatorsPtrs();
    PROGRESS_CALLBACK(47.407407);
    _loadMapBuildingProjectilesPtrs();
    PROGRESS_CALLBACK(48.148148);
    _loadMapBuildingWeaponsPtrs();
    PROGRESS_CALLBACK(48.888889);
    _loadMapGoodsPtrs();
    PROGRESS_CALLBACK(49.629630);
    _loadMapObjectsPtrs();
    PROGRESS_CALLBACK(50.370370);
    _loadMechanoidsPtrs();
    PROGRESS_CALLBACK(51.111111);
    _loadMechanoidQuestsPtrs();
    PROGRESS_CALLBACK(51.851852);
    _loadModificationsPtrs();
    PROGRESS_CALLBACK(52.592593);
    _loadModificationMapsPtrs();
    PROGRESS_CALLBACK(53.333333);
    _loadModificatorsPtrs();
    PROGRESS_CALLBACK(54.074074);
    _loadObjectsPtrs();
    PROGRESS_CALLBACK(54.814815);
    _loadPlayersPtrs();
    PROGRESS_CALLBACK(55.555556);
    _loadProjectilesPtrs();
    PROGRESS_CALLBACK(56.296296);
    _loadQuestsPtrs();
    PROGRESS_CALLBACK(57.037037);
    _loadQuestRewardsPtrs();
    PROGRESS_CALLBACK(57.777778);
    _loadQuestRewardEquipmentsPtrs();
    PROGRESS_CALLBACK(58.518519);
    _loadQuestRewardGlidersPtrs();
    PROGRESS_CALLBACK(59.259259);
    _loadQuestRewardGoodsPtrs();
    PROGRESS_CALLBACK(60.000000);
    _loadQuestRewardModificatorsPtrs();
    PROGRESS_CALLBACK(60.740741);
    _loadQuestRewardProjectilesPtrs();
    PROGRESS_CALLBACK(61.481481);
    _loadQuestRewardReputationsPtrs();
    PROGRESS_CALLBACK(62.222222);
    _loadQuestRewardWeaponsPtrs();
    PROGRESS_CALLBACK(62.962963);
    _loadScriptVariablesPtrs();
    PROGRESS_CALLBACK(63.703704);
    _loadSettingsPtrs();
    PROGRESS_CALLBACK(64.444444);
    _loadStringsPtrs();
    PROGRESS_CALLBACK(65.185185);
    _loadTablesPtrs();
    PROGRESS_CALLBACK(65.925926);
    _loadWeaponsPtrs();
    PROGRESS_CALLBACK(66.666667);

    _loadBuildingsArrays();
    PROGRESS_CALLBACK(67.407407);
    _loadClansArrays();
    PROGRESS_CALLBACK(68.148148);
    _loadClanReputationsArrays();
    PROGRESS_CALLBACK(68.888889);
    _loadConfigurationsArrays();
    PROGRESS_CALLBACK(69.629630);
    _loadConfigurationEquipmentsArrays();
    PROGRESS_CALLBACK(70.370370);
    _loadConfigurationGoodsArrays();
    PROGRESS_CALLBACK(71.111111);
    _loadConfigurationProjectilesArrays();
    PROGRESS_CALLBACK(71.851852);
    _loadConfigurationWeaponsArrays();
    PROGRESS_CALLBACK(72.592593);
    _loadEquipmentsArrays();
    PROGRESS_CALLBACK(73.333333);
    _loadGlidersArrays();
    PROGRESS_CALLBACK(74.074074);
    _loadGoodsArrays();
    PROGRESS_CALLBACK(74.814815);
    _loadGroupsArrays();
    PROGRESS_CALLBACK(75.555556);
    _loadGroupMechanoidsArrays();
    PROGRESS_CALLBACK(76.296296);
    _loadMapsArrays();
    PROGRESS_CALLBACK(77.037037);
    _loadMapBuildingsArrays();
    PROGRESS_CALLBACK(77.777778);
    _loadMapBuildingEquipmentsArrays();
    PROGRESS_CALLBACK(78.518519);
    _loadMapBuildingGlidersArrays();
    PROGRESS_CALLBACK(79.259259);
    _loadMapBuildingGoodsArrays();
    PROGRESS_CALLBACK(80.000000);
    _loadMapBuildingModificatorsArrays();
    PROGRESS_CALLBACK(80.740741);
    _loadMapBuildingProjectilesArrays();
    PROGRESS_CALLBACK(81.481481);
    _loadMapBuildingWeaponsArrays();
    PROGRESS_CALLBACK(82.222222);
    _loadMapGoodsArrays();
    PROGRESS_CALLBACK(82.962963);
    _loadMapObjectsArrays();
    PROGRESS_CALLBACK(83.703704);
    _loadMechanoidsArrays();
    PROGRESS_CALLBACK(84.444444);
    _loadMechanoidQuestsArrays();
    PROGRESS_CALLBACK(85.185185);
    _loadModificationsArrays();
    PROGRESS_CALLBACK(85.925926);
    _loadModificationMapsArrays();
    PROGRESS_CALLBACK(86.666667);
    _loadModificatorsArrays();
    PROGRESS_CALLBACK(87.407407);
    _loadObjectsArrays();
    PROGRESS_CALLBACK(88.148148);
    _loadPlayersArrays();
    PROGRESS_CALLBACK(88.888889);
    _loadProjectilesArrays();
    PROGRESS_CALLBACK(89.629630);
    _loadQuestsArrays();
    PROGRESS_CALLBACK(90.370370);
    _loadQuestRewardsArrays();
    PROGRESS_CALLBACK(91.111111);
    _loadQuestRewardEquipmentsArrays();
    PROGRESS_CALLBACK(91.851852);
    _loadQuestRewardGlidersArrays();
    PROGRESS_CALLBACK(92.592593);
    _loadQuestRewardGoodsArrays();
    PROGRESS_CALLBACK(93.333333);
    _loadQuestRewardModificatorsArrays();
    PROGRESS_CALLBACK(94.074074);
    _loadQuestRewardProjectilesArrays();
    PROGRESS_CALLBACK(94.814815);
    _loadQuestRewardReputationsArrays();
    PROGRESS_CALLBACK(95.555556);
    _loadQuestRewardWeaponsArrays();
    PROGRESS_CALLBACK(96.296296);
    _loadScriptVariablesArrays();
    PROGRESS_CALLBACK(97.037037);
    _loadSettingsArrays();
    PROGRESS_CALLBACK(97.777778);
    _loadStringsArrays();
    PROGRESS_CALLBACK(98.518519);
    _loadTablesArrays();
    PROGRESS_CALLBACK(99.259259);
    _loadWeaponsArrays();
    PROGRESS_CALLBACK(100.000000);
}

void StorageImpl::save(ProgressCallback callback) const
{
    _saveBuildings();
    PROGRESS_CALLBACK(2.222222);
    _saveClans();
    PROGRESS_CALLBACK(4.444444);
    _saveClanReputations();
    PROGRESS_CALLBACK(6.666667);
    _saveConfigurations();
    PROGRESS_CALLBACK(8.888889);
    _saveConfigurationEquipments();
    PROGRESS_CALLBACK(11.111111);
    _saveConfigurationGoods();
    PROGRESS_CALLBACK(13.333333);
    _saveConfigurationProjectiles();
    PROGRESS_CALLBACK(15.555556);
    _saveConfigurationWeapons();
    PROGRESS_CALLBACK(17.777778);
    _saveEquipments();
    PROGRESS_CALLBACK(20.000000);
    _saveGliders();
    PROGRESS_CALLBACK(22.222222);
    _saveGoods();
    PROGRESS_CALLBACK(24.444444);
    _saveGroups();
    PROGRESS_CALLBACK(26.666667);
    _saveGroupMechanoids();
    PROGRESS_CALLBACK(28.888889);
    _saveMaps();
    PROGRESS_CALLBACK(31.111111);
    _saveMapBuildings();
    PROGRESS_CALLBACK(33.333333);
    _saveMapBuildingEquipments();
    PROGRESS_CALLBACK(35.555556);
    _saveMapBuildingGliders();
    PROGRESS_CALLBACK(37.777778);
    _saveMapBuildingGoods();
    PROGRESS_CALLBACK(40.000000);
    _saveMapBuildingModificators();
    PROGRESS_CALLBACK(42.222222);
    _saveMapBuildingProjectiles();
    PROGRESS_CALLBACK(44.444444);
    _saveMapBuildingWeapons();
    PROGRESS_CALLBACK(46.666667);
    _saveMapGoods();
    PROGRESS_CALLBACK(48.888889);
    _saveMapObjects();
    PROGRESS_CALLBACK(51.111111);
    _saveMechanoids();
    PROGRESS_CALLBACK(53.333333);
    _saveMechanoidQuests();
    PROGRESS_CALLBACK(55.555556);
    _saveModifications();
    PROGRESS_CALLBACK(57.777778);
    _saveModificationMaps();
    PROGRESS_CALLBACK(60.000000);
    _saveModificators();
    PROGRESS_CALLBACK(62.222222);
    _saveObjects();
    PROGRESS_CALLBACK(64.444444);
    _savePlayers();
    PROGRESS_CALLBACK(66.666667);
    _saveProjectiles();
    PROGRESS_CALLBACK(68.888889);
    _saveQuests();
    PROGRESS_CALLBACK(71.111111);
    _saveQuestRewards();
    PROGRESS_CALLBACK(73.333333);
    _saveQuestRewardEquipments();
    PROGRESS_CALLBACK(75.555556);
    _saveQuestRewardGliders();
    PROGRESS_CALLBACK(77.777778);
    _saveQuestRewardGoods();
    PROGRESS_CALLBACK(80.000000);
    _saveQuestRewardModificators();
    PROGRESS_CALLBACK(82.222222);
    _saveQuestRewardProjectiles();
    PROGRESS_CALLBACK(84.444444);
    _saveQuestRewardReputations();
    PROGRESS_CALLBACK(86.666667);
    _saveQuestRewardWeapons();
    PROGRESS_CALLBACK(88.888889);
    _saveScriptVariables();
    PROGRESS_CALLBACK(91.111111);
    _saveSettings();
    PROGRESS_CALLBACK(93.333333);
    _saveStrings();
    PROGRESS_CALLBACK(95.555556);
    _saveTables();
    PROGRESS_CALLBACK(97.777778);
    _saveWeapons();
    PROGRESS_CALLBACK(100.000000);
}

Ptr<Building> StorageImpl::addBuilding()
{
    return buildings.createAtEnd();
}

void StorageImpl::deleteBuilding(IObjectBase *v)
{
    buildings.erase(v->id);
}

Ptr<Clan> StorageImpl::addClan()
{
    return clans.createAtEnd();
}

void StorageImpl::deleteClan(IObjectBase *v)
{
    clans.erase(v->id);
}

Ptr<ClanReputation> StorageImpl::addClanReputation(IObjectBase *parent)
{
    auto v = clanReputations.createAtEnd();
    Clan *clan = (Clan *)parent;
    clan->reputations->insert(v);
    v->clan1 = clans[clan->id];
    return v;
}

void StorageImpl::deleteClanReputation(IObjectBase *v)
{
    clanReputations.erase(v->id);
}

Ptr<Configuration> StorageImpl::addConfiguration()
{
    return configurations.createAtEnd();
}

void StorageImpl::deleteConfiguration(IObjectBase *v)
{
    configurations.erase(v->id);
}

Ptr<ConfigurationEquipment> StorageImpl::addConfigurationEquipment(IObjectBase *parent)
{
    auto v = configurationEquipments.createAtEnd();
    Configuration *configuration = (Configuration *)parent;
    configuration->equipments->insert(v);
    v->configuration = configurations[configuration->id];
    return v;
}

void StorageImpl::deleteConfigurationEquipment(IObjectBase *v)
{
    configurationEquipments.erase(v->id);
}

Ptr<ConfigurationGood> StorageImpl::addConfigurationGood(IObjectBase *parent)
{
    auto v = configurationGoods.createAtEnd();
    Configuration *configuration = (Configuration *)parent;
    configuration->goods->insert(v);
    v->configuration = configurations[configuration->id];
    return v;
}

void StorageImpl::deleteConfigurationGood(IObjectBase *v)
{
    configurationGoods.erase(v->id);
}

Ptr<ConfigurationProjectile> StorageImpl::addConfigurationProjectile(IObjectBase *parent)
{
    auto v = configurationProjectiles.createAtEnd();
    Configuration *configuration = (Configuration *)parent;
    configuration->projectiles->insert(v);
    v->configuration = configurations[configuration->id];
    return v;
}

void StorageImpl::deleteConfigurationProjectile(IObjectBase *v)
{
    configurationProjectiles.erase(v->id);
}

Ptr<ConfigurationWeapon> StorageImpl::addConfigurationWeapon(IObjectBase *parent)
{
    auto v = configurationWeapons.createAtEnd();
    Configuration *configuration = (Configuration *)parent;
    configuration->weapons->insert(v);
    v->configuration = configurations[configuration->id];
    return v;
}

void StorageImpl::deleteConfigurationWeapon(IObjectBase *v)
{
    configurationWeapons.erase(v->id);
}

Ptr<Equipment> StorageImpl::addEquipment()
{
    return equipments.createAtEnd();
}

void StorageImpl::deleteEquipment(IObjectBase *v)
{
    equipments.erase(v->id);
}

Ptr<Glider> StorageImpl::addGlider()
{
    return gliders.createAtEnd();
}

void StorageImpl::deleteGlider(IObjectBase *v)
{
    gliders.erase(v->id);
}

Ptr<Good> StorageImpl::addGood()
{
    return goods.createAtEnd();
}

void StorageImpl::deleteGood(IObjectBase *v)
{
    goods.erase(v->id);
}

Ptr<Group> StorageImpl::addGroup()
{
    return groups.createAtEnd();
}

void StorageImpl::deleteGroup(IObjectBase *v)
{
    groups.erase(v->id);
}

Ptr<GroupMechanoid> StorageImpl::addGroupMechanoid(IObjectBase *parent)
{
    auto v = groupMechanoids.createAtEnd();
    Group *group = (Group *)parent;
    group->mechanoids->insert(v);
    v->group = groups[group->id];
    return v;
}

void StorageImpl::deleteGroupMechanoid(IObjectBase *v)
{
    groupMechanoids.erase(v->id);
}

Ptr<Map> StorageImpl::addMap()
{
    return maps.createAtEnd();
}

void StorageImpl::deleteMap(IObjectBase *v)
{
    maps.erase(v->id);
}

Ptr<MapBuilding> StorageImpl::addMapBuilding(IObjectBase *parent)
{
    return mapBuildings.createAtEnd();
}

void StorageImpl::deleteMapBuilding(IObjectBase *v)
{
    mapBuildings.erase(v->id);
}

Ptr<MapBuildingEquipment> StorageImpl::addMapBuildingEquipment(IObjectBase *parent)
{
    auto v = mapBuildingEquipments.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->equipments->insert(v);
    v->map_building = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingEquipment(IObjectBase *v)
{
    mapBuildingEquipments.erase(v->id);
}

Ptr<MapBuildingGlider> StorageImpl::addMapBuildingGlider(IObjectBase *parent)
{
    auto v = mapBuildingGliders.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->gliders->insert(v);
    v->map_building = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingGlider(IObjectBase *v)
{
    mapBuildingGliders.erase(v->id);
}

Ptr<MapBuildingGood> StorageImpl::addMapBuildingGood(IObjectBase *parent)
{
    auto v = mapBuildingGoods.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->goods->insert(v);
    v->map_building = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingGood(IObjectBase *v)
{
    mapBuildingGoods.erase(v->id);
}

Ptr<MapBuildingModificator> StorageImpl::addMapBuildingModificator(IObjectBase *parent)
{
    auto v = mapBuildingModificators.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->modificators->insert(v);
    v->map_building = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingModificator(IObjectBase *v)
{
    mapBuildingModificators.erase(v->id);
}

Ptr<MapBuildingProjectile> StorageImpl::addMapBuildingProjectile(IObjectBase *parent)
{
    auto v = mapBuildingProjectiles.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->projectiles->insert(v);
    v->map_building = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingProjectile(IObjectBase *v)
{
    mapBuildingProjectiles.erase(v->id);
}

Ptr<MapBuildingWeapon> StorageImpl::addMapBuildingWeapon(IObjectBase *parent)
{
    auto v = mapBuildingWeapons.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->weapons->insert(v);
    v->map_building = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingWeapon(IObjectBase *v)
{
    mapBuildingWeapons.erase(v->id);
}

Ptr<MapGood> StorageImpl::addMapGood(IObjectBase *parent)
{
    return mapGoods.createAtEnd();
}

void StorageImpl::deleteMapGood(IObjectBase *v)
{
    mapGoods.erase(v->id);
}

Ptr<MapObject> StorageImpl::addMapObject(IObjectBase *parent)
{
    return mapObjects.createAtEnd();
}

void StorageImpl::deleteMapObject(IObjectBase *v)
{
    mapObjects.erase(v->id);
}

Ptr<Mechanoid> StorageImpl::addMechanoid()
{
    return mechanoids.createAtEnd();
}

void StorageImpl::deleteMechanoid(IObjectBase *v)
{
    mechanoids.erase(v->id);
}

Ptr<MechanoidQuest> StorageImpl::addMechanoidQuest(IObjectBase *parent)
{
    auto v = mechanoidQuests.createAtEnd();
    Mechanoid *mechanoid = (Mechanoid *)parent;
    mechanoid->quests->insert(v);
    v->mechanoid = mechanoids[mechanoid->id];
    return v;
}

void StorageImpl::deleteMechanoidQuest(IObjectBase *v)
{
    mechanoidQuests.erase(v->id);
}

Ptr<Modification> StorageImpl::addModification()
{
    return modifications.createAtEnd();
}

void StorageImpl::deleteModification(IObjectBase *v)
{
    modifications.erase(v->id);
}

Ptr<ModificationMap> StorageImpl::addModificationMap(IObjectBase *parent)
{
    return modificationMaps.createAtEnd();
}

void StorageImpl::deleteModificationMap(IObjectBase *v)
{
    modificationMaps.erase(v->id);
}

Ptr<Modificator> StorageImpl::addModificator()
{
    return modificators.createAtEnd();
}

void StorageImpl::deleteModificator(IObjectBase *v)
{
    modificators.erase(v->id);
}

Ptr<Object> StorageImpl::addObject()
{
    return objects.createAtEnd();
}

void StorageImpl::deleteObject(IObjectBase *v)
{
    objects.erase(v->id);
}

Ptr<Player> StorageImpl::addPlayer()
{
    return players.createAtEnd();
}

void StorageImpl::deletePlayer(IObjectBase *v)
{
    players.erase(v->id);
}

Ptr<Projectile> StorageImpl::addProjectile()
{
    return projectiles.createAtEnd();
}

void StorageImpl::deleteProjectile(IObjectBase *v)
{
    projectiles.erase(v->id);
}

Ptr<Quest> StorageImpl::addQuest()
{
    return quests.createAtEnd();
}

void StorageImpl::deleteQuest(IObjectBase *v)
{
    quests.erase(v->id);
}

Ptr<QuestReward> StorageImpl::addQuestReward(IObjectBase *parent)
{
    return questRewards.createAtEnd();
}

void StorageImpl::deleteQuestReward(IObjectBase *v)
{
    questRewards.erase(v->id);
}

Ptr<QuestRewardEquipment> StorageImpl::addQuestRewardEquipment(IObjectBase *parent)
{
    auto v = questRewardEquipments.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->equipments->insert(v);
    v->quest_reward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardEquipment(IObjectBase *v)
{
    questRewardEquipments.erase(v->id);
}

Ptr<QuestRewardGlider> StorageImpl::addQuestRewardGlider(IObjectBase *parent)
{
    auto v = questRewardGliders.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->gliders->insert(v);
    v->quest_reward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardGlider(IObjectBase *v)
{
    questRewardGliders.erase(v->id);
}

Ptr<QuestRewardGood> StorageImpl::addQuestRewardGood(IObjectBase *parent)
{
    auto v = questRewardGoods.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->goods->insert(v);
    v->quest_reward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardGood(IObjectBase *v)
{
    questRewardGoods.erase(v->id);
}

Ptr<QuestRewardModificator> StorageImpl::addQuestRewardModificator(IObjectBase *parent)
{
    auto v = questRewardModificators.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->modificators->insert(v);
    v->quest_reward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardModificator(IObjectBase *v)
{
    questRewardModificators.erase(v->id);
}

Ptr<QuestRewardProjectile> StorageImpl::addQuestRewardProjectile(IObjectBase *parent)
{
    auto v = questRewardProjectiles.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->projectiles->insert(v);
    v->quest_reward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardProjectile(IObjectBase *v)
{
    questRewardProjectiles.erase(v->id);
}

Ptr<QuestRewardReputation> StorageImpl::addQuestRewardReputation(IObjectBase *parent)
{
    auto v = questRewardReputations.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->reputations->insert(v);
    v->quest_reward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardReputation(IObjectBase *v)
{
    questRewardReputations.erase(v->id);
}

Ptr<QuestRewardWeapon> StorageImpl::addQuestRewardWeapon(IObjectBase *parent)
{
    auto v = questRewardWeapons.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->weapons->insert(v);
    v->quest_reward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardWeapon(IObjectBase *v)
{
    questRewardWeapons.erase(v->id);
}

Ptr<ScriptVariable> StorageImpl::addScriptVariable()
{
    return scriptVariables.createAtEnd();
}

void StorageImpl::deleteScriptVariable(IObjectBase *v)
{
    scriptVariables.erase(v->id);
}

Ptr<Setting> StorageImpl::addSetting()
{
    return settings.createAtEnd();
}

void StorageImpl::deleteSetting(IObjectBase *v)
{
    settings.erase(v->id);
}

Ptr<String> StorageImpl::addString()
{
    return strings.createAtEnd();
}

void StorageImpl::deleteString(IObjectBase *v)
{
    strings.erase(v->id);
}

Ptr<Table> StorageImpl::addTable()
{
    return tables.createAtEnd();
}

void StorageImpl::deleteTable(IObjectBase *v)
{
    tables.erase(v->id);
}

Ptr<Weapon> StorageImpl::addWeapon()
{
    return weapons.createAtEnd();
}

void StorageImpl::deleteWeapon(IObjectBase *v)
{
    weapons.erase(v->id);
}

Ptr<IObjectBase> StorageImpl::addRecord(IObjectBase *parent)
{
    Ptr<IObjectBase> p;
    EObjectType type = parent->getType();
    switch (type)
    {
    case EObjectType::Building:
        p = addBuilding();
        break;
    case EObjectType::Clan:
        p = addClan();
        break;
    case EObjectType::ClanReputation:
        p = addClanReputation(parent);
        break;
    case EObjectType::Configuration:
        p = addConfiguration();
        break;
    case EObjectType::ConfigurationEquipment:
        p = addConfigurationEquipment(parent);
        break;
    case EObjectType::ConfigurationGood:
        p = addConfigurationGood(parent);
        break;
    case EObjectType::ConfigurationProjectile:
        p = addConfigurationProjectile(parent);
        break;
    case EObjectType::ConfigurationWeapon:
        p = addConfigurationWeapon(parent);
        break;
    case EObjectType::Equipment:
        p = addEquipment();
        break;
    case EObjectType::Glider:
        p = addGlider();
        break;
    case EObjectType::Good:
        p = addGood();
        break;
    case EObjectType::Group:
        p = addGroup();
        break;
    case EObjectType::GroupMechanoid:
        p = addGroupMechanoid(parent);
        break;
    case EObjectType::Map:
        p = addMap();
        break;
    case EObjectType::MapBuilding:
        p = addMapBuilding(parent);
        break;
    case EObjectType::MapBuildingEquipment:
        p = addMapBuildingEquipment(parent);
        break;
    case EObjectType::MapBuildingGlider:
        p = addMapBuildingGlider(parent);
        break;
    case EObjectType::MapBuildingGood:
        p = addMapBuildingGood(parent);
        break;
    case EObjectType::MapBuildingModificator:
        p = addMapBuildingModificator(parent);
        break;
    case EObjectType::MapBuildingProjectile:
        p = addMapBuildingProjectile(parent);
        break;
    case EObjectType::MapBuildingWeapon:
        p = addMapBuildingWeapon(parent);
        break;
    case EObjectType::MapGood:
        p = addMapGood(parent);
        break;
    case EObjectType::MapObject:
        p = addMapObject(parent);
        break;
    case EObjectType::Mechanoid:
        p = addMechanoid();
        break;
    case EObjectType::MechanoidQuest:
        p = addMechanoidQuest(parent);
        break;
    case EObjectType::Modification:
        p = addModification();
        break;
    case EObjectType::ModificationMap:
        p = addModificationMap(parent);
        break;
    case EObjectType::Modificator:
        p = addModificator();
        break;
    case EObjectType::Object:
        p = addObject();
        break;
    case EObjectType::Player:
        p = addPlayer();
        break;
    case EObjectType::Projectile:
        p = addProjectile();
        break;
    case EObjectType::Quest:
        p = addQuest();
        break;
    case EObjectType::QuestReward:
        p = addQuestReward(parent);
        break;
    case EObjectType::QuestRewardEquipment:
        p = addQuestRewardEquipment(parent);
        break;
    case EObjectType::QuestRewardGlider:
        p = addQuestRewardGlider(parent);
        break;
    case EObjectType::QuestRewardGood:
        p = addQuestRewardGood(parent);
        break;
    case EObjectType::QuestRewardModificator:
        p = addQuestRewardModificator(parent);
        break;
    case EObjectType::QuestRewardProjectile:
        p = addQuestRewardProjectile(parent);
        break;
    case EObjectType::QuestRewardReputation:
        p = addQuestRewardReputation(parent);
        break;
    case EObjectType::QuestRewardWeapon:
        p = addQuestRewardWeapon(parent);
        break;
    case EObjectType::ScriptVariable:
        p = addScriptVariable();
        break;
    case EObjectType::Setting:
        p = addSetting();
        break;
    case EObjectType::String:
        p = addString();
        break;
    case EObjectType::Table:
        p = addTable();
        break;
    case EObjectType::Weapon:
        p = addWeapon();
        break;
    default:
        break;
    }
    return p;
}

void StorageImpl::deleteRecord(IObjectBase *data)
{
    EObjectType type = data->getType();
    switch (type)
    {
    case EObjectType::Building:
        deleteBuilding(data);
        break;
    case EObjectType::Clan:
        deleteClan(data);
        break;
    case EObjectType::ClanReputation:
        deleteClanReputation(data);
        break;
    case EObjectType::Configuration:
        deleteConfiguration(data);
        break;
    case EObjectType::ConfigurationEquipment:
        deleteConfigurationEquipment(data);
        break;
    case EObjectType::ConfigurationGood:
        deleteConfigurationGood(data);
        break;
    case EObjectType::ConfigurationProjectile:
        deleteConfigurationProjectile(data);
        break;
    case EObjectType::ConfigurationWeapon:
        deleteConfigurationWeapon(data);
        break;
    case EObjectType::Equipment:
        deleteEquipment(data);
        break;
    case EObjectType::Glider:
        deleteGlider(data);
        break;
    case EObjectType::Good:
        deleteGood(data);
        break;
    case EObjectType::Group:
        deleteGroup(data);
        break;
    case EObjectType::GroupMechanoid:
        deleteGroupMechanoid(data);
        break;
    case EObjectType::Map:
        deleteMap(data);
        break;
    case EObjectType::MapBuilding:
        deleteMapBuilding(data);
        break;
    case EObjectType::MapBuildingEquipment:
        deleteMapBuildingEquipment(data);
        break;
    case EObjectType::MapBuildingGlider:
        deleteMapBuildingGlider(data);
        break;
    case EObjectType::MapBuildingGood:
        deleteMapBuildingGood(data);
        break;
    case EObjectType::MapBuildingModificator:
        deleteMapBuildingModificator(data);
        break;
    case EObjectType::MapBuildingProjectile:
        deleteMapBuildingProjectile(data);
        break;
    case EObjectType::MapBuildingWeapon:
        deleteMapBuildingWeapon(data);
        break;
    case EObjectType::MapGood:
        deleteMapGood(data);
        break;
    case EObjectType::MapObject:
        deleteMapObject(data);
        break;
    case EObjectType::Mechanoid:
        deleteMechanoid(data);
        break;
    case EObjectType::MechanoidQuest:
        deleteMechanoidQuest(data);
        break;
    case EObjectType::Modification:
        deleteModification(data);
        break;
    case EObjectType::ModificationMap:
        deleteModificationMap(data);
        break;
    case EObjectType::Modificator:
        deleteModificator(data);
        break;
    case EObjectType::Object:
        deleteObject(data);
        break;
    case EObjectType::Player:
        deletePlayer(data);
        break;
    case EObjectType::Projectile:
        deleteProjectile(data);
        break;
    case EObjectType::Quest:
        deleteQuest(data);
        break;
    case EObjectType::QuestReward:
        deleteQuestReward(data);
        break;
    case EObjectType::QuestRewardEquipment:
        deleteQuestRewardEquipment(data);
        break;
    case EObjectType::QuestRewardGlider:
        deleteQuestRewardGlider(data);
        break;
    case EObjectType::QuestRewardGood:
        deleteQuestRewardGood(data);
        break;
    case EObjectType::QuestRewardModificator:
        deleteQuestRewardModificator(data);
        break;
    case EObjectType::QuestRewardProjectile:
        deleteQuestRewardProjectile(data);
        break;
    case EObjectType::QuestRewardReputation:
        deleteQuestRewardReputation(data);
        break;
    case EObjectType::QuestRewardWeapon:
        deleteQuestRewardWeapon(data);
        break;
    case EObjectType::ScriptVariable:
        deleteScriptVariable(data);
        break;
    case EObjectType::Setting:
        deleteSetting(data);
        break;
    case EObjectType::String:
        deleteString(data);
        break;
    case EObjectType::Table:
        deleteTable(data);
        break;
    case EObjectType::Weapon:
        deleteWeapon(data);
        break;
    default:
        break;
    }
}

Ptr<TreeItem> StorageImpl::printTree() const
{
    Ptr<TreeItem> root = std::make_shared<TreeItem>();
    Ptr<TreeItem> item;
    Ptr<TreeItem> tmp;

    return root;
}

Ptr<TreeItem> StorageImpl::addRecord(TreeItem *item)
{
    Ptr<TreeItem> tmp;
    switch (item->type)
    {
    case EObjectType::Building:
        item->children.push_back(tmp = addBuilding()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Clan:
        item->children.push_back(tmp = addClan()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::ClanReputation:
        item->children.push_back(tmp = addClanReputation(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Configuration:
        item->children.push_back(tmp = addConfiguration()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::ConfigurationEquipment:
        item->children.push_back(tmp = addConfigurationEquipment(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::ConfigurationGood:
        item->children.push_back(tmp = addConfigurationGood(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::ConfigurationProjectile:
        item->children.push_back(tmp = addConfigurationProjectile(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::ConfigurationWeapon:
        item->children.push_back(tmp = addConfigurationWeapon(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Equipment:
        item->children.push_back(tmp = addEquipment()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Glider:
        item->children.push_back(tmp = addGlider()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Good:
        item->children.push_back(tmp = addGood()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Group:
        item->children.push_back(tmp = addGroup()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::GroupMechanoid:
        item->children.push_back(tmp = addGroupMechanoid(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Map:
        item->children.push_back(tmp = addMap()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapBuilding:
        item->children.push_back(tmp = addMapBuilding(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapBuildingEquipment:
        item->children.push_back(tmp = addMapBuildingEquipment(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapBuildingGlider:
        item->children.push_back(tmp = addMapBuildingGlider(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapBuildingGood:
        item->children.push_back(tmp = addMapBuildingGood(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapBuildingModificator:
        item->children.push_back(tmp = addMapBuildingModificator(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapBuildingProjectile:
        item->children.push_back(tmp = addMapBuildingProjectile(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapBuildingWeapon:
        item->children.push_back(tmp = addMapBuildingWeapon(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapGood:
        item->children.push_back(tmp = addMapGood(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapObject:
        item->children.push_back(tmp = addMapObject(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Mechanoid:
        item->children.push_back(tmp = addMechanoid()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MechanoidQuest:
        item->children.push_back(tmp = addMechanoidQuest(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Modification:
        item->children.push_back(tmp = addModification()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::ModificationMap:
        item->children.push_back(tmp = addModificationMap(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Modificator:
        item->children.push_back(tmp = addModificator()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Object:
        item->children.push_back(tmp = addObject()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Player:
        item->children.push_back(tmp = addPlayer()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Projectile:
        item->children.push_back(tmp = addProjectile()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Quest:
        item->children.push_back(tmp = addQuest()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::QuestReward:
        item->children.push_back(tmp = addQuestReward(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::QuestRewardEquipment:
        item->children.push_back(tmp = addQuestRewardEquipment(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::QuestRewardGlider:
        item->children.push_back(tmp = addQuestRewardGlider(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::QuestRewardGood:
        item->children.push_back(tmp = addQuestRewardGood(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::QuestRewardModificator:
        item->children.push_back(tmp = addQuestRewardModificator(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::QuestRewardProjectile:
        item->children.push_back(tmp = addQuestRewardProjectile(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::QuestRewardReputation:
        item->children.push_back(tmp = addQuestRewardReputation(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::QuestRewardWeapon:
        item->children.push_back(tmp = addQuestRewardWeapon(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::ScriptVariable:
        item->children.push_back(tmp = addScriptVariable()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Setting:
        item->children.push_back(tmp = addSetting()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::String:
        item->children.push_back(tmp = addString()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Table:
        item->children.push_back(tmp = addTable()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Weapon:
        item->children.push_back(tmp = addWeapon()->printTree());
        tmp->parent = item;
        break;
    default:
        break;
    }
    return tmp;
}

void StorageImpl::deleteRecord(TreeItem *item)
{
    if (!item || !item->object)
        return;
    switch (item->type)
    {
    case EObjectType::Building:
        deleteBuilding(item->object);
        break;
    case EObjectType::Clan:
        deleteClan(item->object);
        break;
    case EObjectType::ClanReputation:
        deleteClanReputation(item->object);
        break;
    case EObjectType::Configuration:
        deleteConfiguration(item->object);
        break;
    case EObjectType::ConfigurationEquipment:
        deleteConfigurationEquipment(item->object);
        break;
    case EObjectType::ConfigurationGood:
        deleteConfigurationGood(item->object);
        break;
    case EObjectType::ConfigurationProjectile:
        deleteConfigurationProjectile(item->object);
        break;
    case EObjectType::ConfigurationWeapon:
        deleteConfigurationWeapon(item->object);
        break;
    case EObjectType::Equipment:
        deleteEquipment(item->object);
        break;
    case EObjectType::Glider:
        deleteGlider(item->object);
        break;
    case EObjectType::Good:
        deleteGood(item->object);
        break;
    case EObjectType::Group:
        deleteGroup(item->object);
        break;
    case EObjectType::GroupMechanoid:
        deleteGroupMechanoid(item->object);
        break;
    case EObjectType::Map:
        deleteMap(item->object);
        break;
    case EObjectType::MapBuilding:
        deleteMapBuilding(item->object);
        break;
    case EObjectType::MapBuildingEquipment:
        deleteMapBuildingEquipment(item->object);
        break;
    case EObjectType::MapBuildingGlider:
        deleteMapBuildingGlider(item->object);
        break;
    case EObjectType::MapBuildingGood:
        deleteMapBuildingGood(item->object);
        break;
    case EObjectType::MapBuildingModificator:
        deleteMapBuildingModificator(item->object);
        break;
    case EObjectType::MapBuildingProjectile:
        deleteMapBuildingProjectile(item->object);
        break;
    case EObjectType::MapBuildingWeapon:
        deleteMapBuildingWeapon(item->object);
        break;
    case EObjectType::MapGood:
        deleteMapGood(item->object);
        break;
    case EObjectType::MapObject:
        deleteMapObject(item->object);
        break;
    case EObjectType::Mechanoid:
        deleteMechanoid(item->object);
        break;
    case EObjectType::MechanoidQuest:
        deleteMechanoidQuest(item->object);
        break;
    case EObjectType::Modification:
        deleteModification(item->object);
        break;
    case EObjectType::ModificationMap:
        deleteModificationMap(item->object);
        break;
    case EObjectType::Modificator:
        deleteModificator(item->object);
        break;
    case EObjectType::Object:
        deleteObject(item->object);
        break;
    case EObjectType::Player:
        deletePlayer(item->object);
        break;
    case EObjectType::Projectile:
        deleteProjectile(item->object);
        break;
    case EObjectType::Quest:
        deleteQuest(item->object);
        break;
    case EObjectType::QuestReward:
        deleteQuestReward(item->object);
        break;
    case EObjectType::QuestRewardEquipment:
        deleteQuestRewardEquipment(item->object);
        break;
    case EObjectType::QuestRewardGlider:
        deleteQuestRewardGlider(item->object);
        break;
    case EObjectType::QuestRewardGood:
        deleteQuestRewardGood(item->object);
        break;
    case EObjectType::QuestRewardModificator:
        deleteQuestRewardModificator(item->object);
        break;
    case EObjectType::QuestRewardProjectile:
        deleteQuestRewardProjectile(item->object);
        break;
    case EObjectType::QuestRewardReputation:
        deleteQuestRewardReputation(item->object);
        break;
    case EObjectType::QuestRewardWeapon:
        deleteQuestRewardWeapon(item->object);
        break;
    case EObjectType::ScriptVariable:
        deleteScriptVariable(item->object);
        break;
    case EObjectType::Setting:
        deleteSetting(item->object);
        break;
    case EObjectType::String:
        deleteString(item->object);
        break;
    case EObjectType::Table:
        deleteTable(item->object);
        break;
    case EObjectType::Weapon:
        deleteWeapon(item->object);
        break;
    default:
        break;
    }
}

OrderedObjectMap StorageImpl::getOrderedMap(EObjectType type, std::function<bool(IObjectBase *)> f) const
{
    switch (type)
    {
    case EObjectType::Building:
        return ::getOrderedMap(buildings, f);
    case EObjectType::Clan:
        return ::getOrderedMap(clans, f);
    case EObjectType::ClanReputation:
        return ::getOrderedMap(clanReputations, f);
    case EObjectType::Configuration:
        return ::getOrderedMap(configurations, f);
    case EObjectType::ConfigurationEquipment:
        return ::getOrderedMap(configurationEquipments, f);
    case EObjectType::ConfigurationGood:
        return ::getOrderedMap(configurationGoods, f);
    case EObjectType::ConfigurationProjectile:
        return ::getOrderedMap(configurationProjectiles, f);
    case EObjectType::ConfigurationWeapon:
        return ::getOrderedMap(configurationWeapons, f);
    case EObjectType::Equipment:
        return ::getOrderedMap(equipments, f);
    case EObjectType::Glider:
        return ::getOrderedMap(gliders, f);
    case EObjectType::Good:
        return ::getOrderedMap(goods, f);
    case EObjectType::Group:
        return ::getOrderedMap(groups, f);
    case EObjectType::GroupMechanoid:
        return ::getOrderedMap(groupMechanoids, f);
    case EObjectType::Map:
        return ::getOrderedMap(maps, f);
    case EObjectType::MapBuilding:
        return ::getOrderedMap(mapBuildings, f);
    case EObjectType::MapBuildingEquipment:
        return ::getOrderedMap(mapBuildingEquipments, f);
    case EObjectType::MapBuildingGlider:
        return ::getOrderedMap(mapBuildingGliders, f);
    case EObjectType::MapBuildingGood:
        return ::getOrderedMap(mapBuildingGoods, f);
    case EObjectType::MapBuildingModificator:
        return ::getOrderedMap(mapBuildingModificators, f);
    case EObjectType::MapBuildingProjectile:
        return ::getOrderedMap(mapBuildingProjectiles, f);
    case EObjectType::MapBuildingWeapon:
        return ::getOrderedMap(mapBuildingWeapons, f);
    case EObjectType::MapGood:
        return ::getOrderedMap(mapGoods, f);
    case EObjectType::MapObject:
        return ::getOrderedMap(mapObjects, f);
    case EObjectType::Mechanoid:
        return ::getOrderedMap(mechanoids, f);
    case EObjectType::MechanoidQuest:
        return ::getOrderedMap(mechanoidQuests, f);
    case EObjectType::Modification:
        return ::getOrderedMap(modifications, f);
    case EObjectType::ModificationMap:
        return ::getOrderedMap(modificationMaps, f);
    case EObjectType::Modificator:
        return ::getOrderedMap(modificators, f);
    case EObjectType::Object:
        return ::getOrderedMap(objects, f);
    case EObjectType::Player:
        return ::getOrderedMap(players, f);
    case EObjectType::Projectile:
        return ::getOrderedMap(projectiles, f);
    case EObjectType::Quest:
        return ::getOrderedMap(quests, f);
    case EObjectType::QuestReward:
        return ::getOrderedMap(questRewards, f);
    case EObjectType::QuestRewardEquipment:
        return ::getOrderedMap(questRewardEquipments, f);
    case EObjectType::QuestRewardGlider:
        return ::getOrderedMap(questRewardGliders, f);
    case EObjectType::QuestRewardGood:
        return ::getOrderedMap(questRewardGoods, f);
    case EObjectType::QuestRewardModificator:
        return ::getOrderedMap(questRewardModificators, f);
    case EObjectType::QuestRewardProjectile:
        return ::getOrderedMap(questRewardProjectiles, f);
    case EObjectType::QuestRewardReputation:
        return ::getOrderedMap(questRewardReputations, f);
    case EObjectType::QuestRewardWeapon:
        return ::getOrderedMap(questRewardWeapons, f);
    case EObjectType::ScriptVariable:
        return ::getOrderedMap(scriptVariables, f);
    case EObjectType::Setting:
        return ::getOrderedMap(settings, f);
    case EObjectType::String:
        return ::getOrderedMap(strings, f);
    case EObjectType::Table:
        return ::getOrderedMap(tables, f);
    case EObjectType::Weapon:
        return ::getOrderedMap(weapons, f);
    default:
        return OrderedObjectMap();
    }
}

