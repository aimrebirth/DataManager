/* DO NOT EDIT! This is an autogenerated file. */

void StorageImpl::_loadBuildings()
{
    const std::string query = "select * from Buildings;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = buildings.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->scale = (float)sqlite3_column_double(stmt, 3);
        v->scale_x = (float)sqlite3_column_double(stmt, 4);
        v->scale_y = (float)sqlite3_column_double(stmt, 5);
        v->scale_z = (float)sqlite3_column_double(stmt, 6);
        buildings.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadBuildingsPtrs()
{
}

void StorageImpl::_loadBuildingsArrays()
{
}

void StorageImpl::_saveBuildings() const
{
    db->execute("BEGIN;");
    db->execute("delete from Buildings;");
    const std::string query = "insert into Buildings values (?, ?, ?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &building : buildings)
    {
        auto &v = building.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_double(stmt, 4, v->scale);
        sqlite3_bind_double(stmt, 5, v->scale_x);
        sqlite3_bind_double(stmt, 6, v->scale_y);
        sqlite3_bind_double(stmt, 7, v->scale_z);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadClans()
{
    const std::string query = "select * from Clans;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = clans.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name = sqlite3_column_int(stmt, 3);
        v->member_name = sqlite3_column_int(stmt, 4);
        v->modification = sqlite3_column_int(stmt, 5);
        v->bonusexp = sqlite3_column_int(stmt, 6);
        v->bonusrepair = sqlite3_column_int(stmt, 7);
        v->bonustrade = sqlite3_column_int(stmt, 8);
        v->helpness = sqlite3_column_int(stmt, 9);
        v->Volatile = (float)sqlite3_column_double(stmt, 10);
        v->noblivion = (float)sqlite3_column_double(stmt, 11);
        v->playereffect = (float)sqlite3_column_double(stmt, 12);
        v->color = sqlite3_column_int(stmt, 13);
        clans.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadClansPtrs()
{
    for (auto &clan : clans)
    {
        auto name = strings.find(clan->name.id);
        if (name != strings.end())
            clan->name = *name;

        auto member_name = strings.find(clan->member_name.id);
        if (member_name != strings.end())
            clan->member_name = *member_name;

        auto modification = modifications.find(clan->modification.id);
        if (modification != modifications.end())
            clan->modification = *modification;
    }
}

void StorageImpl::_loadClansArrays()
{
    for (auto &clan : clans)
    {
        for (auto &mechanoid : mechanoids)
            if (clan->id == mechanoid->clan.id)
                clan->mechanoids->insert(mechanoid);
        for (auto &clanReputation : clanReputations)
            if (clan->id == clanReputation->clan1.id)
                clan->reputations->insert(clanReputation);
    }
}

void StorageImpl::_saveClans() const
{
    db->execute("BEGIN;");
    db->execute("delete from Clans;");
    const std::string query = "insert into Clans values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &clan : clans)
    {
        auto &v = clan.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 4, v->name.id);
        sqlite3_bind_int(stmt, 5, v->member_name.id);
        sqlite3_bind_int(stmt, 6, v->modification.id);
        sqlite3_bind_int(stmt, 7, v->bonusexp);
        sqlite3_bind_int(stmt, 8, v->bonusrepair);
        sqlite3_bind_int(stmt, 9, v->bonustrade);
        sqlite3_bind_int(stmt, 10, v->helpness);
        sqlite3_bind_double(stmt, 11, v->Volatile);
        sqlite3_bind_double(stmt, 12, v->noblivion);
        sqlite3_bind_double(stmt, 13, v->playereffect);
        sqlite3_bind_int(stmt, 14, v->color);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadClanReputations()
{
    const std::string query = "select * from ClanReputations;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = clanReputations.create();
        v->clan1 = sqlite3_column_int(stmt, 0);
        v->clan2 = sqlite3_column_int(stmt, 1);
        v->reputation = (float)sqlite3_column_double(stmt, 2);
        clanReputations.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadClanReputationsPtrs()
{
    for (auto &clanReputation : clanReputations)
    {
        auto clan1 = clans.find(clanReputation->clan1.id);
        if (clan1 != clans.end())
            clanReputation->clan1 = *clan1;

        auto clan2 = clans.find(clanReputation->clan2.id);
        if (clan2 != clans.end())
            clanReputation->clan2 = *clan2;
    }
}

void StorageImpl::_loadClanReputationsArrays()
{
}

void StorageImpl::_saveClanReputations() const
{
    db->execute("BEGIN;");
    db->execute("delete from ClanReputations;");
    const std::string query = "insert into ClanReputations values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &clanReputation : clanReputations)
    {
        auto &v = clanReputation;
        sqlite3_bind_int(stmt, 1, v->clan1.id);
        sqlite3_bind_int(stmt, 2, v->clan2.id);
        sqlite3_bind_double(stmt, 3, v->reputation);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadConfigurations()
{
    const std::string query = "select * from Configurations;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = configurations.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->name = sqlite3_column_int(stmt, 2);
        v->glider = sqlite3_column_int(stmt, 3);
        configurations.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadConfigurationsPtrs()
{
    for (auto &configuration : configurations)
    {
        auto name = strings.find(configuration->name.id);
        if (name != strings.end())
            configuration->name = *name;

        auto glider = gliders.find(configuration->glider.id);
        if (glider != gliders.end())
            configuration->glider = *glider;
    }
}

void StorageImpl::_loadConfigurationsArrays()
{
    for (auto &configuration : configurations)
    {
        for (auto &configurationEquipment : configurationEquipments)
            if (configuration->id == configurationEquipment->configuration.id)
                configuration->equipments->insert(configurationEquipment);
        for (auto &configurationGood : configurationGoods)
            if (configuration->id == configurationGood->configuration.id)
                configuration->goods->insert(configurationGood);
        for (auto &configurationProjectile : configurationProjectiles)
            if (configuration->id == configurationProjectile->configuration.id)
                configuration->projectiles->insert(configurationProjectile);
        for (auto &configurationWeapon : configurationWeapons)
            if (configuration->id == configurationWeapon->configuration.id)
                configuration->weapons->insert(configurationWeapon);
    }
}

void StorageImpl::_saveConfigurations() const
{
    db->execute("BEGIN;");
    db->execute("delete from Configurations;");
    const std::string query = "insert into Configurations values (?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &configuration : configurations)
    {
        auto &v = configuration.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 3, v->name.id);
        sqlite3_bind_int(stmt, 4, v->glider.id);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadConfigurationEquipments()
{
    const std::string query = "select * from ConfigurationEquipments;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = configurationEquipments.create();
        v->configuration = sqlite3_column_int(stmt, 0);
        v->equipment = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        configurationEquipments.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadConfigurationEquipmentsPtrs()
{
    for (auto &configurationEquipment : configurationEquipments)
    {
        auto configuration = configurations.find(configurationEquipment->configuration.id);
        if (configuration != configurations.end())
            configurationEquipment->configuration = *configuration;

        auto equipment = equipments.find(configurationEquipment->equipment.id);
        if (equipment != equipments.end())
            configurationEquipment->equipment = *equipment;
    }
}

void StorageImpl::_loadConfigurationEquipmentsArrays()
{
}

void StorageImpl::_saveConfigurationEquipments() const
{
    db->execute("BEGIN;");
    db->execute("delete from ConfigurationEquipments;");
    const std::string query = "insert into ConfigurationEquipments values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &configurationEquipment : configurationEquipments)
    {
        auto &v = configurationEquipment;
        sqlite3_bind_int(stmt, 1, v->configuration.id);
        sqlite3_bind_int(stmt, 2, v->equipment.id);
        sqlite3_bind_int(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadConfigurationGoods()
{
    const std::string query = "select * from ConfigurationGoods;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = configurationGoods.create();
        v->configuration = sqlite3_column_int(stmt, 0);
        v->good = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        configurationGoods.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadConfigurationGoodsPtrs()
{
    for (auto &configurationGood : configurationGoods)
    {
        auto configuration = configurations.find(configurationGood->configuration.id);
        if (configuration != configurations.end())
            configurationGood->configuration = *configuration;

        auto good = goods.find(configurationGood->good.id);
        if (good != goods.end())
            configurationGood->good = *good;
    }
}

void StorageImpl::_loadConfigurationGoodsArrays()
{
}

void StorageImpl::_saveConfigurationGoods() const
{
    db->execute("BEGIN;");
    db->execute("delete from ConfigurationGoods;");
    const std::string query = "insert into ConfigurationGoods values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &configurationGood : configurationGoods)
    {
        auto &v = configurationGood;
        sqlite3_bind_int(stmt, 1, v->configuration.id);
        sqlite3_bind_int(stmt, 2, v->good.id);
        sqlite3_bind_int(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadConfigurationProjectiles()
{
    const std::string query = "select * from ConfigurationProjectiles;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = configurationProjectiles.create();
        v->configuration = sqlite3_column_int(stmt, 0);
        v->projectile = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        configurationProjectiles.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadConfigurationProjectilesPtrs()
{
    for (auto &configurationProjectile : configurationProjectiles)
    {
        auto configuration = configurations.find(configurationProjectile->configuration.id);
        if (configuration != configurations.end())
            configurationProjectile->configuration = *configuration;

        auto projectile = projectiles.find(configurationProjectile->projectile.id);
        if (projectile != projectiles.end())
            configurationProjectile->projectile = *projectile;
    }
}

void StorageImpl::_loadConfigurationProjectilesArrays()
{
}

void StorageImpl::_saveConfigurationProjectiles() const
{
    db->execute("BEGIN;");
    db->execute("delete from ConfigurationProjectiles;");
    const std::string query = "insert into ConfigurationProjectiles values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &configurationProjectile : configurationProjectiles)
    {
        auto &v = configurationProjectile;
        sqlite3_bind_int(stmt, 1, v->configuration.id);
        sqlite3_bind_int(stmt, 2, v->projectile.id);
        sqlite3_bind_int(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadConfigurationWeapons()
{
    const std::string query = "select * from ConfigurationWeapons;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = configurationWeapons.create();
        v->configuration = sqlite3_column_int(stmt, 0);
        v->weapon = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        configurationWeapons.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadConfigurationWeaponsPtrs()
{
    for (auto &configurationWeapon : configurationWeapons)
    {
        auto configuration = configurations.find(configurationWeapon->configuration.id);
        if (configuration != configurations.end())
            configurationWeapon->configuration = *configuration;

        auto weapon = weapons.find(configurationWeapon->weapon.id);
        if (weapon != weapons.end())
            configurationWeapon->weapon = *weapon;
    }
}

void StorageImpl::_loadConfigurationWeaponsArrays()
{
}

void StorageImpl::_saveConfigurationWeapons() const
{
    db->execute("BEGIN;");
    db->execute("delete from ConfigurationWeapons;");
    const std::string query = "insert into ConfigurationWeapons values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &configurationWeapon : configurationWeapons)
    {
        auto &v = configurationWeapon;
        sqlite3_bind_int(stmt, 1, v->configuration.id);
        sqlite3_bind_int(stmt, 2, v->weapon.id);
        sqlite3_bind_int(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadEquipments()
{
    const std::string query = "select * from Equipments;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = equipments.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name = sqlite3_column_int(stmt, 3);
        v->type = sqlite3_column_int(stmt, 4);
        v->standard = sqlite3_column_int(stmt, 5);
        v->weight = (float)sqlite3_column_double(stmt, 6);
        v->durability = (float)sqlite3_column_double(stmt, 7);
        v->power = (float)sqlite3_column_double(stmt, 8);
        v->value1 = (float)sqlite3_column_double(stmt, 9);
        v->value2 = (float)sqlite3_column_double(stmt, 10);
        v->value3 = (float)sqlite3_column_double(stmt, 11);
        v->manual = !!sqlite3_column_int(stmt, 12);
        v->price = (float)sqlite3_column_double(stmt, 13);
        v->notrade = !!sqlite3_column_int(stmt, 14);
        equipments.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadEquipmentsPtrs()
{
    for (auto &equipment : equipments)
    {
        auto name = strings.find(equipment->name.id);
        if (name != strings.end())
            equipment->name = *name;
    }
}

void StorageImpl::_loadEquipmentsArrays()
{
}

void StorageImpl::_saveEquipments() const
{
    db->execute("BEGIN;");
    db->execute("delete from Equipments;");
    const std::string query = "insert into Equipments values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &equipment : equipments)
    {
        auto &v = equipment.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 4, v->name.id);
        sqlite3_bind_int(stmt, 5, v->type);
        sqlite3_bind_int(stmt, 6, v->standard);
        sqlite3_bind_double(stmt, 7, v->weight);
        sqlite3_bind_double(stmt, 8, v->durability);
        sqlite3_bind_double(stmt, 9, v->power);
        sqlite3_bind_double(stmt, 10, v->value1);
        sqlite3_bind_double(stmt, 11, v->value2);
        sqlite3_bind_double(stmt, 12, v->value3);
        sqlite3_bind_int(stmt, 13, v->manual);
        sqlite3_bind_double(stmt, 14, v->price);
        sqlite3_bind_int(stmt, 15, v->notrade);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadGliders()
{
    const std::string query = "select * from Gliders;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = gliders.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name = sqlite3_column_int(stmt, 3);
        v->standard = sqlite3_column_int(stmt, 4);
        v->weight = (float)sqlite3_column_double(stmt, 5);
        v->maxweight = (float)sqlite3_column_double(stmt, 6);
        v->armor = (float)sqlite3_column_double(stmt, 7);
        v->price = (float)sqlite3_column_double(stmt, 8);
        v->restore = (float)sqlite3_column_double(stmt, 9);
        v->power = (float)sqlite3_column_double(stmt, 10);
        v->special = !!sqlite3_column_int(stmt, 11);
        v->rotatespeed = (float)sqlite3_column_double(stmt, 12);
        v->resfront = (float)sqlite3_column_double(stmt, 13);
        v->resstop = (float)sqlite3_column_double(stmt, 14);
        v->resside = (float)sqlite3_column_double(stmt, 15);
        v->stabfront = (float)sqlite3_column_double(stmt, 16);
        v->stabside = (float)sqlite3_column_double(stmt, 17);
        v->careen = (float)sqlite3_column_double(stmt, 18);
        v->delta_t = (float)sqlite3_column_double(stmt, 19);
        v->turbulence = (float)sqlite3_column_double(stmt, 20);
        gliders.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadGlidersPtrs()
{
    for (auto &glider : gliders)
    {
        auto name = strings.find(glider->name.id);
        if (name != strings.end())
            glider->name = *name;
    }
}

void StorageImpl::_loadGlidersArrays()
{
}

void StorageImpl::_saveGliders() const
{
    db->execute("BEGIN;");
    db->execute("delete from Gliders;");
    const std::string query = "insert into Gliders values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &glider : gliders)
    {
        auto &v = glider.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 4, v->name.id);
        sqlite3_bind_int(stmt, 5, v->standard);
        sqlite3_bind_double(stmt, 6, v->weight);
        sqlite3_bind_double(stmt, 7, v->maxweight);
        sqlite3_bind_double(stmt, 8, v->armor);
        sqlite3_bind_double(stmt, 9, v->price);
        sqlite3_bind_double(stmt, 10, v->restore);
        sqlite3_bind_double(stmt, 11, v->power);
        sqlite3_bind_int(stmt, 12, v->special);
        sqlite3_bind_double(stmt, 13, v->rotatespeed);
        sqlite3_bind_double(stmt, 14, v->resfront);
        sqlite3_bind_double(stmt, 15, v->resstop);
        sqlite3_bind_double(stmt, 16, v->resside);
        sqlite3_bind_double(stmt, 17, v->stabfront);
        sqlite3_bind_double(stmt, 18, v->stabside);
        sqlite3_bind_double(stmt, 19, v->careen);
        sqlite3_bind_double(stmt, 20, v->delta_t);
        sqlite3_bind_double(stmt, 21, v->turbulence);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadGoods()
{
    const std::string query = "select * from Goods;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = goods.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->resource_drop = (const char *)sqlite3_column_text(stmt, 3);
        v->name = sqlite3_column_int(stmt, 4);
        v->price = (float)sqlite3_column_double(stmt, 5);
        v->weight = (float)sqlite3_column_double(stmt, 6);
        v->notrade = !!sqlite3_column_int(stmt, 7);
        v->type = sqlite3_column_int(stmt, 8);
        goods.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadGoodsPtrs()
{
    for (auto &good : goods)
    {
        auto name = strings.find(good->name.id);
        if (name != strings.end())
            good->name = *name;
    }
}

void StorageImpl::_loadGoodsArrays()
{
}

void StorageImpl::_saveGoods() const
{
    db->execute("BEGIN;");
    db->execute("delete from Goods;");
    const std::string query = "insert into Goods values (?, ?, ?, ?, ?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &good : goods)
    {
        auto &v = good.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 4, std::to_string(v->resource_drop).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 5, v->name.id);
        sqlite3_bind_double(stmt, 6, v->price);
        sqlite3_bind_double(stmt, 7, v->weight);
        sqlite3_bind_int(stmt, 8, v->notrade);
        sqlite3_bind_int(stmt, 9, v->type);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadGroups()
{
    const std::string query = "select * from Groups;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = groups.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->name = sqlite3_column_int(stmt, 2);
        groups.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadGroupsPtrs()
{
    for (auto &group : groups)
    {
        auto name = strings.find(group->name.id);
        if (name != strings.end())
            group->name = *name;
    }
}

void StorageImpl::_loadGroupsArrays()
{
    for (auto &group : groups)
    {
        for (auto &groupMechanoid : groupMechanoids)
            if (group->id == groupMechanoid->group.id)
                group->mechanoids->insert(groupMechanoid);
    }
}

void StorageImpl::_saveGroups() const
{
    db->execute("BEGIN;");
    db->execute("delete from Groups;");
    const std::string query = "insert into Groups values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &group : groups)
    {
        auto &v = group.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 3, v->name.id);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadGroupMechanoids()
{
    const std::string query = "select * from GroupMechanoids;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = groupMechanoids.create();
        v->group = sqlite3_column_int(stmt, 0);
        v->mechanoid = sqlite3_column_int(stmt, 1);
        groupMechanoids.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadGroupMechanoidsPtrs()
{
    for (auto &groupMechanoid : groupMechanoids)
    {
        auto group = groups.find(groupMechanoid->group.id);
        if (group != groups.end())
            groupMechanoid->group = *group;

        auto mechanoid = mechanoids.find(groupMechanoid->mechanoid.id);
        if (mechanoid != mechanoids.end())
            groupMechanoid->mechanoid = *mechanoid;
    }
}

void StorageImpl::_loadGroupMechanoidsArrays()
{
}

void StorageImpl::_saveGroupMechanoids() const
{
    db->execute("BEGIN;");
    db->execute("delete from GroupMechanoids;");
    const std::string query = "insert into GroupMechanoids values (?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &groupMechanoid : groupMechanoids)
    {
        auto &v = groupMechanoid;
        sqlite3_bind_int(stmt, 1, v->group.id);
        sqlite3_bind_int(stmt, 2, v->mechanoid.id);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMaps()
{
    const std::string query = "select * from Maps;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = maps.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name = sqlite3_column_int(stmt, 3);
        v->h_min = (float)sqlite3_column_double(stmt, 4);
        v->h_max = (float)sqlite3_column_double(stmt, 5);
        v->kx = (float)sqlite3_column_double(stmt, 6);
        v->bx = (float)sqlite3_column_double(stmt, 7);
        v->ky = (float)sqlite3_column_double(stmt, 8);
        v->by = (float)sqlite3_column_double(stmt, 9);
        maps.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapsPtrs()
{
    for (auto &map : maps)
    {
        auto name = strings.find(map->name.id);
        if (name != strings.end())
            map->name = *name;
    }
}

void StorageImpl::_loadMapsArrays()
{
    for (auto &map : maps)
    {
        for (auto &mapBuilding : mapBuildings)
            if (map->id == mapBuilding->map.id)
                map->buildings->insert(mapBuilding);
        for (auto &mapGood : mapGoods)
            if (map->id == mapGood->map.id)
                map->goods->insert(mapGood);
        for (auto &mapObject : mapObjects)
            if (map->id == mapObject->map.id)
                map->objects->insert(mapObject);
    }
}

void StorageImpl::_saveMaps() const
{
    db->execute("BEGIN;");
    db->execute("delete from Maps;");
    const std::string query = "insert into Maps values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &map : maps)
    {
        auto &v = map.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 4, v->name.id);
        sqlite3_bind_double(stmt, 5, v->h_min);
        sqlite3_bind_double(stmt, 6, v->h_max);
        sqlite3_bind_double(stmt, 7, v->kx);
        sqlite3_bind_double(stmt, 8, v->bx);
        sqlite3_bind_double(stmt, 9, v->ky);
        sqlite3_bind_double(stmt, 10, v->by);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildings()
{
    const std::string query = "select * from MapBuildings;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildings.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->name = sqlite3_column_int(stmt, 2);
        v->map = sqlite3_column_int(stmt, 3);
        v->building = sqlite3_column_int(stmt, 4);
        v->x = (float)sqlite3_column_double(stmt, 5);
        v->y = (float)sqlite3_column_double(stmt, 6);
        v->z = (float)sqlite3_column_double(stmt, 7);
        v->roll = (float)sqlite3_column_double(stmt, 8);
        v->pitch = (float)sqlite3_column_double(stmt, 9);
        v->yaw = (float)sqlite3_column_double(stmt, 10);
        v->scale = (float)sqlite3_column_double(stmt, 11);
        v->scale_x = (float)sqlite3_column_double(stmt, 12);
        v->scale_y = (float)sqlite3_column_double(stmt, 13);
        v->scale_z = (float)sqlite3_column_double(stmt, 14);
        v->interactive = !!sqlite3_column_int(stmt, 15);
        mapBuildings.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingsPtrs()
{
    for (auto &mapBuilding : mapBuildings)
    {
        auto name = strings.find(mapBuilding->name.id);
        if (name != strings.end())
            mapBuilding->name = *name;

        auto map = maps.find(mapBuilding->map.id);
        if (map != maps.end())
            mapBuilding->map = *map;

        auto building = buildings.find(mapBuilding->building.id);
        if (building != buildings.end())
            mapBuilding->building = *building;
    }
}

void StorageImpl::_loadMapBuildingsArrays()
{
    for (auto &mapBuilding : mapBuildings)
    {
        for (auto &mapBuildingEquipment : mapBuildingEquipments)
            if (mapBuilding->id == mapBuildingEquipment->map_building.id)
                mapBuilding->equipments->insert(mapBuildingEquipment);
        for (auto &mapBuildingGlider : mapBuildingGliders)
            if (mapBuilding->id == mapBuildingGlider->map_building.id)
                mapBuilding->gliders->insert(mapBuildingGlider);
        for (auto &mapBuildingGood : mapBuildingGoods)
            if (mapBuilding->id == mapBuildingGood->map_building.id)
                mapBuilding->goods->insert(mapBuildingGood);
        for (auto &mapBuildingModificator : mapBuildingModificators)
            if (mapBuilding->id == mapBuildingModificator->map_building.id)
                mapBuilding->modificators->insert(mapBuildingModificator);
        for (auto &mapBuildingProjectile : mapBuildingProjectiles)
            if (mapBuilding->id == mapBuildingProjectile->map_building.id)
                mapBuilding->projectiles->insert(mapBuildingProjectile);
        for (auto &mapBuildingWeapon : mapBuildingWeapons)
            if (mapBuilding->id == mapBuildingWeapon->map_building.id)
                mapBuilding->weapons->insert(mapBuildingWeapon);
    }
}

void StorageImpl::_saveMapBuildings() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildings;");
    const std::string query = "insert into MapBuildings values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuilding : mapBuildings)
    {
        auto &v = mapBuilding.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 3, v->name.id);
        sqlite3_bind_int(stmt, 4, v->map.id);
        sqlite3_bind_int(stmt, 5, v->building.id);
        sqlite3_bind_double(stmt, 6, v->x);
        sqlite3_bind_double(stmt, 7, v->y);
        sqlite3_bind_double(stmt, 8, v->z);
        sqlite3_bind_double(stmt, 9, v->roll);
        sqlite3_bind_double(stmt, 10, v->pitch);
        sqlite3_bind_double(stmt, 11, v->yaw);
        sqlite3_bind_double(stmt, 12, v->scale);
        sqlite3_bind_double(stmt, 13, v->scale_x);
        sqlite3_bind_double(stmt, 14, v->scale_y);
        sqlite3_bind_double(stmt, 15, v->scale_z);
        sqlite3_bind_int(stmt, 16, v->interactive);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingEquipments()
{
    const std::string query = "select * from MapBuildingEquipments;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingEquipments.create();
        v->map_building = sqlite3_column_int(stmt, 0);
        v->equipment = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingEquipments.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingEquipmentsPtrs()
{
    for (auto &mapBuildingEquipment : mapBuildingEquipments)
    {
        auto map_building = mapBuildings.find(mapBuildingEquipment->map_building.id);
        if (map_building != mapBuildings.end())
            mapBuildingEquipment->map_building = *map_building;

        auto equipment = equipments.find(mapBuildingEquipment->equipment.id);
        if (equipment != equipments.end())
            mapBuildingEquipment->equipment = *equipment;
    }
}

void StorageImpl::_loadMapBuildingEquipmentsArrays()
{
}

void StorageImpl::_saveMapBuildingEquipments() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingEquipments;");
    const std::string query = "insert into MapBuildingEquipments values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingEquipment : mapBuildingEquipments)
    {
        auto &v = mapBuildingEquipment;
        sqlite3_bind_int(stmt, 1, v->map_building.id);
        sqlite3_bind_int(stmt, 2, v->equipment.id);
        sqlite3_bind_int(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingGliders()
{
    const std::string query = "select * from MapBuildingGliders;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingGliders.create();
        v->map_building = sqlite3_column_int(stmt, 0);
        v->glider = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingGliders.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingGlidersPtrs()
{
    for (auto &mapBuildingGlider : mapBuildingGliders)
    {
        auto map_building = mapBuildings.find(mapBuildingGlider->map_building.id);
        if (map_building != mapBuildings.end())
            mapBuildingGlider->map_building = *map_building;

        auto glider = gliders.find(mapBuildingGlider->glider.id);
        if (glider != gliders.end())
            mapBuildingGlider->glider = *glider;
    }
}

void StorageImpl::_loadMapBuildingGlidersArrays()
{
}

void StorageImpl::_saveMapBuildingGliders() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingGliders;");
    const std::string query = "insert into MapBuildingGliders values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingGlider : mapBuildingGliders)
    {
        auto &v = mapBuildingGlider;
        sqlite3_bind_int(stmt, 1, v->map_building.id);
        sqlite3_bind_int(stmt, 2, v->glider.id);
        sqlite3_bind_int(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingGoods()
{
    const std::string query = "select * from MapBuildingGoods;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingGoods.create();
        v->map_building = sqlite3_column_int(stmt, 0);
        v->good = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingGoods.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingGoodsPtrs()
{
    for (auto &mapBuildingGood : mapBuildingGoods)
    {
        auto map_building = mapBuildings.find(mapBuildingGood->map_building.id);
        if (map_building != mapBuildings.end())
            mapBuildingGood->map_building = *map_building;

        auto good = goods.find(mapBuildingGood->good.id);
        if (good != goods.end())
            mapBuildingGood->good = *good;
    }
}

void StorageImpl::_loadMapBuildingGoodsArrays()
{
}

void StorageImpl::_saveMapBuildingGoods() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingGoods;");
    const std::string query = "insert into MapBuildingGoods values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingGood : mapBuildingGoods)
    {
        auto &v = mapBuildingGood;
        sqlite3_bind_int(stmt, 1, v->map_building.id);
        sqlite3_bind_int(stmt, 2, v->good.id);
        sqlite3_bind_int(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingModificators()
{
    const std::string query = "select * from MapBuildingModificators;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingModificators.create();
        v->map_building = sqlite3_column_int(stmt, 0);
        v->modificator = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingModificators.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingModificatorsPtrs()
{
    for (auto &mapBuildingModificator : mapBuildingModificators)
    {
        auto map_building = mapBuildings.find(mapBuildingModificator->map_building.id);
        if (map_building != mapBuildings.end())
            mapBuildingModificator->map_building = *map_building;

        auto modificator = modificators.find(mapBuildingModificator->modificator.id);
        if (modificator != modificators.end())
            mapBuildingModificator->modificator = *modificator;
    }
}

void StorageImpl::_loadMapBuildingModificatorsArrays()
{
}

void StorageImpl::_saveMapBuildingModificators() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingModificators;");
    const std::string query = "insert into MapBuildingModificators values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingModificator : mapBuildingModificators)
    {
        auto &v = mapBuildingModificator;
        sqlite3_bind_int(stmt, 1, v->map_building.id);
        sqlite3_bind_int(stmt, 2, v->modificator.id);
        sqlite3_bind_int(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingProjectiles()
{
    const std::string query = "select * from MapBuildingProjectiles;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingProjectiles.create();
        v->map_building = sqlite3_column_int(stmt, 0);
        v->projectile = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingProjectiles.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingProjectilesPtrs()
{
    for (auto &mapBuildingProjectile : mapBuildingProjectiles)
    {
        auto map_building = mapBuildings.find(mapBuildingProjectile->map_building.id);
        if (map_building != mapBuildings.end())
            mapBuildingProjectile->map_building = *map_building;

        auto projectile = projectiles.find(mapBuildingProjectile->projectile.id);
        if (projectile != projectiles.end())
            mapBuildingProjectile->projectile = *projectile;
    }
}

void StorageImpl::_loadMapBuildingProjectilesArrays()
{
}

void StorageImpl::_saveMapBuildingProjectiles() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingProjectiles;");
    const std::string query = "insert into MapBuildingProjectiles values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingProjectile : mapBuildingProjectiles)
    {
        auto &v = mapBuildingProjectile;
        sqlite3_bind_int(stmt, 1, v->map_building.id);
        sqlite3_bind_int(stmt, 2, v->projectile.id);
        sqlite3_bind_int(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingWeapons()
{
    const std::string query = "select * from MapBuildingWeapons;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingWeapons.create();
        v->map_building = sqlite3_column_int(stmt, 0);
        v->weapon = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingWeapons.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingWeaponsPtrs()
{
    for (auto &mapBuildingWeapon : mapBuildingWeapons)
    {
        auto map_building = mapBuildings.find(mapBuildingWeapon->map_building.id);
        if (map_building != mapBuildings.end())
            mapBuildingWeapon->map_building = *map_building;

        auto weapon = weapons.find(mapBuildingWeapon->weapon.id);
        if (weapon != weapons.end())
            mapBuildingWeapon->weapon = *weapon;
    }
}

void StorageImpl::_loadMapBuildingWeaponsArrays()
{
}

void StorageImpl::_saveMapBuildingWeapons() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingWeapons;");
    const std::string query = "insert into MapBuildingWeapons values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingWeapon : mapBuildingWeapons)
    {
        auto &v = mapBuildingWeapon;
        sqlite3_bind_int(stmt, 1, v->map_building.id);
        sqlite3_bind_int(stmt, 2, v->weapon.id);
        sqlite3_bind_int(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapGoods()
{
    const std::string query = "select * from MapGoods;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapGoods.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->map = sqlite3_column_int(stmt, 2);
        v->good = sqlite3_column_int(stmt, 3);
        v->x = (float)sqlite3_column_double(stmt, 4);
        v->y = (float)sqlite3_column_double(stmt, 5);
        v->z = (float)sqlite3_column_double(stmt, 6);
        v->roll = (float)sqlite3_column_double(stmt, 7);
        v->pitch = (float)sqlite3_column_double(stmt, 8);
        v->yaw = (float)sqlite3_column_double(stmt, 9);
        v->scale = (float)sqlite3_column_double(stmt, 10);
        v->scale_x = (float)sqlite3_column_double(stmt, 11);
        v->scale_y = (float)sqlite3_column_double(stmt, 12);
        v->scale_z = (float)sqlite3_column_double(stmt, 13);
        mapGoods.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapGoodsPtrs()
{
    for (auto &mapGood : mapGoods)
    {
        auto map = maps.find(mapGood->map.id);
        if (map != maps.end())
            mapGood->map = *map;

        auto good = goods.find(mapGood->good.id);
        if (good != goods.end())
            mapGood->good = *good;
    }
}

void StorageImpl::_loadMapGoodsArrays()
{
}

void StorageImpl::_saveMapGoods() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapGoods;");
    const std::string query = "insert into MapGoods values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapGood : mapGoods)
    {
        auto &v = mapGood.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 3, v->map.id);
        sqlite3_bind_int(stmt, 4, v->good.id);
        sqlite3_bind_double(stmt, 5, v->x);
        sqlite3_bind_double(stmt, 6, v->y);
        sqlite3_bind_double(stmt, 7, v->z);
        sqlite3_bind_double(stmt, 8, v->roll);
        sqlite3_bind_double(stmt, 9, v->pitch);
        sqlite3_bind_double(stmt, 10, v->yaw);
        sqlite3_bind_double(stmt, 11, v->scale);
        sqlite3_bind_double(stmt, 12, v->scale_x);
        sqlite3_bind_double(stmt, 13, v->scale_y);
        sqlite3_bind_double(stmt, 14, v->scale_z);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapObjects()
{
    const std::string query = "select * from MapObjects;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapObjects.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->map = sqlite3_column_int(stmt, 2);
        v->object = sqlite3_column_int(stmt, 3);
        v->x = (float)sqlite3_column_double(stmt, 4);
        v->y = (float)sqlite3_column_double(stmt, 5);
        v->z = (float)sqlite3_column_double(stmt, 6);
        v->roll = (float)sqlite3_column_double(stmt, 7);
        v->pitch = (float)sqlite3_column_double(stmt, 8);
        v->yaw = (float)sqlite3_column_double(stmt, 9);
        v->scale = (float)sqlite3_column_double(stmt, 10);
        v->scale_x = (float)sqlite3_column_double(stmt, 11);
        v->scale_y = (float)sqlite3_column_double(stmt, 12);
        v->scale_z = (float)sqlite3_column_double(stmt, 13);
        mapObjects.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapObjectsPtrs()
{
    for (auto &mapObject : mapObjects)
    {
        auto map = maps.find(mapObject->map.id);
        if (map != maps.end())
            mapObject->map = *map;

        auto object = objects.find(mapObject->object.id);
        if (object != objects.end())
            mapObject->object = *object;
    }
}

void StorageImpl::_loadMapObjectsArrays()
{
}

void StorageImpl::_saveMapObjects() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapObjects;");
    const std::string query = "insert into MapObjects values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapObject : mapObjects)
    {
        auto &v = mapObject.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 3, v->map.id);
        sqlite3_bind_int(stmt, 4, v->object.id);
        sqlite3_bind_double(stmt, 5, v->x);
        sqlite3_bind_double(stmt, 6, v->y);
        sqlite3_bind_double(stmt, 7, v->z);
        sqlite3_bind_double(stmt, 8, v->roll);
        sqlite3_bind_double(stmt, 9, v->pitch);
        sqlite3_bind_double(stmt, 10, v->yaw);
        sqlite3_bind_double(stmt, 11, v->scale);
        sqlite3_bind_double(stmt, 12, v->scale_x);
        sqlite3_bind_double(stmt, 13, v->scale_y);
        sqlite3_bind_double(stmt, 14, v->scale_z);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMechanoids()
{
    const std::string query = "select * from Mechanoids;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mechanoids.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->name = sqlite3_column_int(stmt, 2);
        v->modification = sqlite3_column_int(stmt, 3);
        v->map = sqlite3_column_int(stmt, 4);
        v->clan = sqlite3_column_int(stmt, 5);
        v->building = sqlite3_column_int(stmt, 6);
        v->configuration = sqlite3_column_int(stmt, 7);
        v->group = sqlite3_column_int(stmt, 8);
        v->generation = sqlite3_column_int(stmt, 9);
        v->money = (float)sqlite3_column_double(stmt, 10);
        v->rating = (float)sqlite3_column_double(stmt, 11);
        v->rating_fight = (float)sqlite3_column_double(stmt, 12);
        v->rating_courier = (float)sqlite3_column_double(stmt, 13);
        v->rating_trade = (float)sqlite3_column_double(stmt, 14);
        v->x = (float)sqlite3_column_double(stmt, 15);
        v->y = (float)sqlite3_column_double(stmt, 16);
        v->z = (float)sqlite3_column_double(stmt, 17);
        v->roll = (float)sqlite3_column_double(stmt, 18);
        v->pitch = (float)sqlite3_column_double(stmt, 19);
        v->yaw = (float)sqlite3_column_double(stmt, 20);
        mechanoids.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadMechanoidsPtrs()
{
    for (auto &mechanoid : mechanoids)
    {
        auto name = strings.find(mechanoid->name.id);
        if (name != strings.end())
            mechanoid->name = *name;

        auto modification = modifications.find(mechanoid->modification.id);
        if (modification != modifications.end())
            mechanoid->modification = *modification;

        auto map = modificationMaps.find(mechanoid->map.id);
        if (map != modificationMaps.end())
            mechanoid->map = *map;

        auto clan = clans.find(mechanoid->clan.id);
        if (clan != clans.end())
            mechanoid->clan = *clan;

        auto building = mapBuildings.find(mechanoid->building.id);
        if (building != mapBuildings.end())
            mechanoid->building = *building;

        auto configuration = configurations.find(mechanoid->configuration.id);
        if (configuration != configurations.end())
            mechanoid->configuration = *configuration;

        auto group = groups.find(mechanoid->group.id);
        if (group != groups.end())
            mechanoid->group = *group;
    }
}

void StorageImpl::_loadMechanoidsArrays()
{
    for (auto &mechanoid : mechanoids)
    {
        for (auto &mechanoidQuest : mechanoidQuests)
            if (mechanoid->id == mechanoidQuest->mechanoid.id)
                mechanoid->quests->insert(mechanoidQuest);
    }
}

void StorageImpl::_saveMechanoids() const
{
    db->execute("BEGIN;");
    db->execute("delete from Mechanoids;");
    const std::string query = "insert into Mechanoids values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mechanoid : mechanoids)
    {
        auto &v = mechanoid.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 3, v->name.id);
        sqlite3_bind_int(stmt, 4, v->modification.id);
        sqlite3_bind_int(stmt, 5, v->map.id);
        sqlite3_bind_int(stmt, 6, v->clan.id);
        sqlite3_bind_int(stmt, 7, v->building.id);
        sqlite3_bind_int(stmt, 8, v->configuration.id);
        sqlite3_bind_int(stmt, 9, v->group.id);
        sqlite3_bind_int(stmt, 10, v->generation);
        sqlite3_bind_double(stmt, 11, v->money);
        sqlite3_bind_double(stmt, 12, v->rating);
        sqlite3_bind_double(stmt, 13, v->rating_fight);
        sqlite3_bind_double(stmt, 14, v->rating_courier);
        sqlite3_bind_double(stmt, 15, v->rating_trade);
        sqlite3_bind_double(stmt, 16, v->x);
        sqlite3_bind_double(stmt, 17, v->y);
        sqlite3_bind_double(stmt, 18, v->z);
        sqlite3_bind_double(stmt, 19, v->roll);
        sqlite3_bind_double(stmt, 20, v->pitch);
        sqlite3_bind_double(stmt, 21, v->yaw);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMechanoidQuests()
{
    const std::string query = "select * from MechanoidQuests;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mechanoidQuests.create();
        v->mechanoid = sqlite3_column_int(stmt, 0);
        v->quest = sqlite3_column_int(stmt, 1);
        v->state = sqlite3_column_int(stmt, 2);
        mechanoidQuests.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadMechanoidQuestsPtrs()
{
    for (auto &mechanoidQuest : mechanoidQuests)
    {
        auto mechanoid = mechanoids.find(mechanoidQuest->mechanoid.id);
        if (mechanoid != mechanoids.end())
            mechanoidQuest->mechanoid = *mechanoid;

        auto quest = quests.find(mechanoidQuest->quest.id);
        if (quest != quests.end())
            mechanoidQuest->quest = *quest;
    }
}

void StorageImpl::_loadMechanoidQuestsArrays()
{
}

void StorageImpl::_saveMechanoidQuests() const
{
    db->execute("BEGIN;");
    db->execute("delete from MechanoidQuests;");
    const std::string query = "insert into MechanoidQuests values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mechanoidQuest : mechanoidQuests)
    {
        auto &v = mechanoidQuest;
        sqlite3_bind_int(stmt, 1, v->mechanoid.id);
        sqlite3_bind_int(stmt, 2, v->quest.id);
        sqlite3_bind_int(stmt, 3, v->state);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadModifications()
{
    const std::string query = "select * from Modifications;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = modifications.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->name = sqlite3_column_int(stmt, 1);
        v->directory = (const char *)sqlite3_column_text(stmt, 2);
        v->author = (const char *)sqlite3_column_text(stmt, 3);
        v->date_created = (const char *)sqlite3_column_text(stmt, 4);
        v->date_modified = (const char *)sqlite3_column_text(stmt, 5);
        v->comment = (const char *)sqlite3_column_text(stmt, 6);
        v->version = (const char *)sqlite3_column_text(stmt, 7);
        v->script_language = (const char *)sqlite3_column_text(stmt, 8);
        v->script_main = (const char *)sqlite3_column_text(stmt, 9);
        v->player_mechanoid = sqlite3_column_int(stmt, 10);
        v->cooperative_player_configuration = sqlite3_column_int(stmt, 11);
        modifications.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadModificationsPtrs()
{
    for (auto &modification : modifications)
    {
        auto name = strings.find(modification->name.id);
        if (name != strings.end())
            modification->name = *name;

        auto player_mechanoid = mechanoids.find(modification->player_mechanoid.id);
        if (player_mechanoid != mechanoids.end())
            modification->player_mechanoid = *player_mechanoid;

        auto cooperative_player_configuration = configurations.find(modification->cooperative_player_configuration.id);
        if (cooperative_player_configuration != configurations.end())
            modification->cooperative_player_configuration = *cooperative_player_configuration;
    }
}

void StorageImpl::_loadModificationsArrays()
{
    for (auto &modification : modifications)
    {
        for (auto &modificationMap : modificationMaps)
            if (modification->id == modificationMap->modification.id)
                modification->maps->insert(modificationMap);
        for (auto &clan : clans)
            if (modification->id == clan->modification.id)
                modification->clans->insert(clan);
        for (auto &mechanoid : mechanoids)
            if (modification->id == mechanoid->modification.id)
                modification->mechanoids->insert(mechanoid);
    }
}

void StorageImpl::_saveModifications() const
{
    db->execute("BEGIN;");
    db->execute("delete from Modifications;");
    const std::string query = "insert into Modifications values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &modification : modifications)
    {
        auto &v = modification.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_int(stmt, 2, v->name.id);
        sqlite3_bind_text(stmt, 3, std::to_string(v->directory).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 4, std::to_string(v->author).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 5, std::to_string(v->date_created).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 6, std::to_string(v->date_modified).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 7, std::to_string(v->comment).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 8, std::to_string(v->version).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 9, std::to_string(v->script_language).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 10, std::to_string(v->script_main).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 11, v->player_mechanoid.id);
        sqlite3_bind_int(stmt, 12, v->cooperative_player_configuration.id);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadModificationMaps()
{
    const std::string query = "select * from ModificationMaps;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = modificationMaps.create();
        v->modification = sqlite3_column_int(stmt, 0);
        v->map = sqlite3_column_int(stmt, 1);
        modificationMaps.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadModificationMapsPtrs()
{
    for (auto &modificationMap : modificationMaps)
    {
        auto modification = modifications.find(modificationMap->modification.id);
        if (modification != modifications.end())
            modificationMap->modification = *modification;

        auto map = maps.find(modificationMap->map.id);
        if (map != maps.end())
            modificationMap->map = *map;
    }
}

void StorageImpl::_loadModificationMapsArrays()
{
}

void StorageImpl::_saveModificationMaps() const
{
    db->execute("BEGIN;");
    db->execute("delete from ModificationMaps;");
    const std::string query = "insert into ModificationMaps values (?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &modificationMap : modificationMaps)
    {
        auto &v = modificationMap;
        sqlite3_bind_int(stmt, 1, v->modification.id);
        sqlite3_bind_int(stmt, 2, v->map.id);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadModificators()
{
    const std::string query = "select * from Modificators;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = modificators.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name = sqlite3_column_int(stmt, 3);
        v->probability = (float)sqlite3_column_double(stmt, 4);
        v->price = (float)sqlite3_column_double(stmt, 5);
        v->k_price = (float)sqlite3_column_double(stmt, 6);
        v->k_param1 = (float)sqlite3_column_double(stmt, 7);
        v->k_param2 = (float)sqlite3_column_double(stmt, 8);
        v->unicum_id = sqlite3_column_int(stmt, 9);
        v->mask = sqlite3_column_int(stmt, 10);
        modificators.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadModificatorsPtrs()
{
    for (auto &modificator : modificators)
    {
        auto name = strings.find(modificator->name.id);
        if (name != strings.end())
            modificator->name = *name;
    }
}

void StorageImpl::_loadModificatorsArrays()
{
}

void StorageImpl::_saveModificators() const
{
    db->execute("BEGIN;");
    db->execute("delete from Modificators;");
    const std::string query = "insert into Modificators values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &modificator : modificators)
    {
        auto &v = modificator.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 4, v->name.id);
        sqlite3_bind_double(stmt, 5, v->probability);
        sqlite3_bind_double(stmt, 6, v->price);
        sqlite3_bind_double(stmt, 7, v->k_price);
        sqlite3_bind_double(stmt, 8, v->k_param1);
        sqlite3_bind_double(stmt, 9, v->k_param2);
        sqlite3_bind_int(stmt, 10, v->unicum_id);
        sqlite3_bind_int(stmt, 11, v->mask);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadObjects()
{
    const std::string query = "select * from Objects;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = objects.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name = sqlite3_column_int(stmt, 3);
        v->type = sqlite3_column_int(stmt, 4);
        v->scale = (float)sqlite3_column_double(stmt, 5);
        v->scale_x = (float)sqlite3_column_double(stmt, 6);
        v->scale_y = (float)sqlite3_column_double(stmt, 7);
        v->scale_z = (float)sqlite3_column_double(stmt, 8);
        objects.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadObjectsPtrs()
{
    for (auto &object : objects)
    {
        auto name = strings.find(object->name.id);
        if (name != strings.end())
            object->name = *name;
    }
}

void StorageImpl::_loadObjectsArrays()
{
}

void StorageImpl::_saveObjects() const
{
    db->execute("BEGIN;");
    db->execute("delete from Objects;");
    const std::string query = "insert into Objects values (?, ?, ?, ?, ?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &object : objects)
    {
        auto &v = object.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 4, v->name.id);
        sqlite3_bind_int(stmt, 5, v->type);
        sqlite3_bind_double(stmt, 6, v->scale);
        sqlite3_bind_double(stmt, 7, v->scale_x);
        sqlite3_bind_double(stmt, 8, v->scale_y);
        sqlite3_bind_double(stmt, 9, v->scale_z);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadPlayers()
{
    const std::string query = "select * from Players;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = players.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->mechanoid = sqlite3_column_int(stmt, 1);
        players.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadPlayersPtrs()
{
    for (auto &player : players)
    {
        auto mechanoid = mechanoids.find(player->mechanoid.id);
        if (mechanoid != mechanoids.end())
            player->mechanoid = *mechanoid;
    }
}

void StorageImpl::_loadPlayersArrays()
{
}

void StorageImpl::_savePlayers() const
{
    db->execute("BEGIN;");
    db->execute("delete from Players;");
    const std::string query = "insert into Players values (?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &player : players)
    {
        auto &v = player.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_int(stmt, 2, v->mechanoid.id);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadProjectiles()
{
    const std::string query = "select * from Projectiles;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = projectiles.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name = sqlite3_column_int(stmt, 3);
        v->type = sqlite3_column_int(stmt, 4);
        v->subtype = sqlite3_column_int(stmt, 5);
        v->weight = (float)sqlite3_column_double(stmt, 6);
        v->damage = (float)sqlite3_column_double(stmt, 7);
        v->T = (float)sqlite3_column_double(stmt, 8);
        v->speed = (float)sqlite3_column_double(stmt, 9);
        v->scale = (float)sqlite3_column_double(stmt, 10);
        v->numstate = sqlite3_column_int(stmt, 11);
        v->rotate = (float)sqlite3_column_double(stmt, 12);
        v->life_time = (float)sqlite3_column_double(stmt, 13);
        v->detonation_delay = (float)sqlite3_column_double(stmt, 14);
        v->distance_detonation = (float)sqlite3_column_double(stmt, 15);
        v->strength = (float)sqlite3_column_double(stmt, 16);
        v->price = (float)sqlite3_column_double(stmt, 17);
        v->notrade = !!sqlite3_column_int(stmt, 18);
        projectiles.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadProjectilesPtrs()
{
    for (auto &projectile : projectiles)
    {
        auto name = strings.find(projectile->name.id);
        if (name != strings.end())
            projectile->name = *name;
    }
}

void StorageImpl::_loadProjectilesArrays()
{
}

void StorageImpl::_saveProjectiles() const
{
    db->execute("BEGIN;");
    db->execute("delete from Projectiles;");
    const std::string query = "insert into Projectiles values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &projectile : projectiles)
    {
        auto &v = projectile.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 4, v->name.id);
        sqlite3_bind_int(stmt, 5, v->type);
        sqlite3_bind_int(stmt, 6, v->subtype);
        sqlite3_bind_double(stmt, 7, v->weight);
        sqlite3_bind_double(stmt, 8, v->damage);
        sqlite3_bind_double(stmt, 9, v->T);
        sqlite3_bind_double(stmt, 10, v->speed);
        sqlite3_bind_double(stmt, 11, v->scale);
        sqlite3_bind_int(stmt, 12, v->numstate);
        sqlite3_bind_double(stmt, 13, v->rotate);
        sqlite3_bind_double(stmt, 14, v->life_time);
        sqlite3_bind_double(stmt, 15, v->detonation_delay);
        sqlite3_bind_double(stmt, 16, v->distance_detonation);
        sqlite3_bind_double(stmt, 17, v->strength);
        sqlite3_bind_double(stmt, 18, v->price);
        sqlite3_bind_int(stmt, 19, v->notrade);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuests()
{
    const std::string query = "select * from Quests;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = quests.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->name = sqlite3_column_int(stmt, 1);
        v->title = sqlite3_column_int(stmt, 2);
        v->description = sqlite3_column_int(stmt, 3);
        v->time = sqlite3_column_int(stmt, 4);
        quests.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestsPtrs()
{
    for (auto &quest : quests)
    {
        auto name = strings.find(quest->name.id);
        if (name != strings.end())
            quest->name = *name;

        auto title = strings.find(quest->title.id);
        if (title != strings.end())
            quest->title = *title;

        auto description = strings.find(quest->description.id);
        if (description != strings.end())
            quest->description = *description;
    }
}

void StorageImpl::_loadQuestsArrays()
{
    for (auto &quest : quests)
    {
        for (auto &questReward : questRewards)
            if (quest->id == questReward->quest.id)
                quest->rewards->insert(questReward);
    }
}

void StorageImpl::_saveQuests() const
{
    db->execute("BEGIN;");
    db->execute("delete from Quests;");
    const std::string query = "insert into Quests values (?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &quest : quests)
    {
        auto &v = quest.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_int(stmt, 2, v->name.id);
        sqlite3_bind_int(stmt, 3, v->title.id);
        sqlite3_bind_int(stmt, 4, v->description.id);
        sqlite3_bind_int(stmt, 5, v->time);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewards()
{
    const std::string query = "select * from QuestRewards;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewards.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->quest = sqlite3_column_int(stmt, 2);
        v->money = (float)sqlite3_column_double(stmt, 3);
        v->rating = (float)sqlite3_column_double(stmt, 4);
        questRewards.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardsPtrs()
{
    for (auto &questReward : questRewards)
    {
        auto quest = quests.find(questReward->quest.id);
        if (quest != quests.end())
            questReward->quest = *quest;
    }
}

void StorageImpl::_loadQuestRewardsArrays()
{
    for (auto &questReward : questRewards)
    {
        for (auto &questRewardEquipment : questRewardEquipments)
            if (questReward->id == questRewardEquipment->quest_reward.id)
                questReward->equipments->insert(questRewardEquipment);
        for (auto &questRewardGlider : questRewardGliders)
            if (questReward->id == questRewardGlider->quest_reward.id)
                questReward->gliders->insert(questRewardGlider);
        for (auto &questRewardGood : questRewardGoods)
            if (questReward->id == questRewardGood->quest_reward.id)
                questReward->goods->insert(questRewardGood);
        for (auto &questRewardModificator : questRewardModificators)
            if (questReward->id == questRewardModificator->quest_reward.id)
                questReward->modificators->insert(questRewardModificator);
        for (auto &questRewardProjectile : questRewardProjectiles)
            if (questReward->id == questRewardProjectile->quest_reward.id)
                questReward->projectiles->insert(questRewardProjectile);
        for (auto &questRewardReputation : questRewardReputations)
            if (questReward->id == questRewardReputation->quest_reward.id)
                questReward->reputations->insert(questRewardReputation);
        for (auto &questRewardWeapon : questRewardWeapons)
            if (questReward->id == questRewardWeapon->quest_reward.id)
                questReward->weapons->insert(questRewardWeapon);
    }
}

void StorageImpl::_saveQuestRewards() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewards;");
    const std::string query = "insert into QuestRewards values (?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questReward : questRewards)
    {
        auto &v = questReward.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 3, v->quest.id);
        sqlite3_bind_double(stmt, 4, v->money);
        sqlite3_bind_double(stmt, 5, v->rating);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardEquipments()
{
    const std::string query = "select * from QuestRewardEquipments;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardEquipments.create();
        v->quest_reward = sqlite3_column_int(stmt, 0);
        v->equipment = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardEquipments.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardEquipmentsPtrs()
{
    for (auto &questRewardEquipment : questRewardEquipments)
    {
        auto quest_reward = questRewards.find(questRewardEquipment->quest_reward.id);
        if (quest_reward != questRewards.end())
            questRewardEquipment->quest_reward = *quest_reward;

        auto equipment = equipments.find(questRewardEquipment->equipment.id);
        if (equipment != equipments.end())
            questRewardEquipment->equipment = *equipment;
    }
}

void StorageImpl::_loadQuestRewardEquipmentsArrays()
{
}

void StorageImpl::_saveQuestRewardEquipments() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardEquipments;");
    const std::string query = "insert into QuestRewardEquipments values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardEquipment : questRewardEquipments)
    {
        auto &v = questRewardEquipment;
        sqlite3_bind_int(stmt, 1, v->quest_reward.id);
        sqlite3_bind_int(stmt, 2, v->equipment.id);
        sqlite3_bind_int(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardGliders()
{
    const std::string query = "select * from QuestRewardGliders;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardGliders.create();
        v->quest_reward = sqlite3_column_int(stmt, 0);
        v->glider = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardGliders.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardGlidersPtrs()
{
    for (auto &questRewardGlider : questRewardGliders)
    {
        auto quest_reward = questRewards.find(questRewardGlider->quest_reward.id);
        if (quest_reward != questRewards.end())
            questRewardGlider->quest_reward = *quest_reward;

        auto glider = gliders.find(questRewardGlider->glider.id);
        if (glider != gliders.end())
            questRewardGlider->glider = *glider;
    }
}

void StorageImpl::_loadQuestRewardGlidersArrays()
{
}

void StorageImpl::_saveQuestRewardGliders() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardGliders;");
    const std::string query = "insert into QuestRewardGliders values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardGlider : questRewardGliders)
    {
        auto &v = questRewardGlider;
        sqlite3_bind_int(stmt, 1, v->quest_reward.id);
        sqlite3_bind_int(stmt, 2, v->glider.id);
        sqlite3_bind_int(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardGoods()
{
    const std::string query = "select * from QuestRewardGoods;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardGoods.create();
        v->quest_reward = sqlite3_column_int(stmt, 0);
        v->good = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardGoods.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardGoodsPtrs()
{
    for (auto &questRewardGood : questRewardGoods)
    {
        auto quest_reward = questRewards.find(questRewardGood->quest_reward.id);
        if (quest_reward != questRewards.end())
            questRewardGood->quest_reward = *quest_reward;

        auto good = goods.find(questRewardGood->good.id);
        if (good != goods.end())
            questRewardGood->good = *good;
    }
}

void StorageImpl::_loadQuestRewardGoodsArrays()
{
}

void StorageImpl::_saveQuestRewardGoods() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardGoods;");
    const std::string query = "insert into QuestRewardGoods values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardGood : questRewardGoods)
    {
        auto &v = questRewardGood;
        sqlite3_bind_int(stmt, 1, v->quest_reward.id);
        sqlite3_bind_int(stmt, 2, v->good.id);
        sqlite3_bind_int(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardModificators()
{
    const std::string query = "select * from QuestRewardModificators;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardModificators.create();
        v->quest_reward = sqlite3_column_int(stmt, 0);
        v->modificator = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardModificators.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardModificatorsPtrs()
{
    for (auto &questRewardModificator : questRewardModificators)
    {
        auto quest_reward = questRewards.find(questRewardModificator->quest_reward.id);
        if (quest_reward != questRewards.end())
            questRewardModificator->quest_reward = *quest_reward;

        auto modificator = modificators.find(questRewardModificator->modificator.id);
        if (modificator != modificators.end())
            questRewardModificator->modificator = *modificator;
    }
}

void StorageImpl::_loadQuestRewardModificatorsArrays()
{
}

void StorageImpl::_saveQuestRewardModificators() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardModificators;");
    const std::string query = "insert into QuestRewardModificators values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardModificator : questRewardModificators)
    {
        auto &v = questRewardModificator;
        sqlite3_bind_int(stmt, 1, v->quest_reward.id);
        sqlite3_bind_int(stmt, 2, v->modificator.id);
        sqlite3_bind_int(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardProjectiles()
{
    const std::string query = "select * from QuestRewardProjectiles;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardProjectiles.create();
        v->quest_reward = sqlite3_column_int(stmt, 0);
        v->projectile = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardProjectiles.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardProjectilesPtrs()
{
    for (auto &questRewardProjectile : questRewardProjectiles)
    {
        auto quest_reward = questRewards.find(questRewardProjectile->quest_reward.id);
        if (quest_reward != questRewards.end())
            questRewardProjectile->quest_reward = *quest_reward;

        auto projectile = projectiles.find(questRewardProjectile->projectile.id);
        if (projectile != projectiles.end())
            questRewardProjectile->projectile = *projectile;
    }
}

void StorageImpl::_loadQuestRewardProjectilesArrays()
{
}

void StorageImpl::_saveQuestRewardProjectiles() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardProjectiles;");
    const std::string query = "insert into QuestRewardProjectiles values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardProjectile : questRewardProjectiles)
    {
        auto &v = questRewardProjectile;
        sqlite3_bind_int(stmt, 1, v->quest_reward.id);
        sqlite3_bind_int(stmt, 2, v->projectile.id);
        sqlite3_bind_int(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardReputations()
{
    const std::string query = "select * from QuestRewardReputations;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardReputations.create();
        v->quest_reward = sqlite3_column_int(stmt, 0);
        v->clan = sqlite3_column_int(stmt, 1);
        v->quantity = (float)sqlite3_column_double(stmt, 2);
        questRewardReputations.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardReputationsPtrs()
{
    for (auto &questRewardReputation : questRewardReputations)
    {
        auto quest_reward = questRewards.find(questRewardReputation->quest_reward.id);
        if (quest_reward != questRewards.end())
            questRewardReputation->quest_reward = *quest_reward;

        auto clan = clans.find(questRewardReputation->clan.id);
        if (clan != clans.end())
            questRewardReputation->clan = *clan;
    }
}

void StorageImpl::_loadQuestRewardReputationsArrays()
{
}

void StorageImpl::_saveQuestRewardReputations() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardReputations;");
    const std::string query = "insert into QuestRewardReputations values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardReputation : questRewardReputations)
    {
        auto &v = questRewardReputation;
        sqlite3_bind_int(stmt, 1, v->quest_reward.id);
        sqlite3_bind_int(stmt, 2, v->clan.id);
        sqlite3_bind_double(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardWeapons()
{
    const std::string query = "select * from QuestRewardWeapons;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardWeapons.create();
        v->quest_reward = sqlite3_column_int(stmt, 0);
        v->weapon = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardWeapons.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardWeaponsPtrs()
{
    for (auto &questRewardWeapon : questRewardWeapons)
    {
        auto quest_reward = questRewards.find(questRewardWeapon->quest_reward.id);
        if (quest_reward != questRewards.end())
            questRewardWeapon->quest_reward = *quest_reward;

        auto weapon = weapons.find(questRewardWeapon->weapon.id);
        if (weapon != weapons.end())
            questRewardWeapon->weapon = *weapon;
    }
}

void StorageImpl::_loadQuestRewardWeaponsArrays()
{
}

void StorageImpl::_saveQuestRewardWeapons() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardWeapons;");
    const std::string query = "insert into QuestRewardWeapons values (?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardWeapon : questRewardWeapons)
    {
        auto &v = questRewardWeapon;
        sqlite3_bind_int(stmt, 1, v->quest_reward.id);
        sqlite3_bind_int(stmt, 2, v->weapon.id);
        sqlite3_bind_int(stmt, 3, v->quantity);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadScriptVariables()
{
    const std::string query = "select * from ScriptVariables;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = scriptVariables.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->variable = (const char *)sqlite3_column_text(stmt, 1);
        v->value_int = sqlite3_column_int(stmt, 2);
        v->value_float = (float)sqlite3_column_double(stmt, 3);
        v->value_text = (const char *)sqlite3_column_text(stmt, 4);
        scriptVariables.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadScriptVariablesPtrs()
{
}

void StorageImpl::_loadScriptVariablesArrays()
{
}

void StorageImpl::_saveScriptVariables() const
{
    db->execute("BEGIN;");
    db->execute("delete from ScriptVariables;");
    const std::string query = "insert into ScriptVariables values (?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &scriptVariable : scriptVariables)
    {
        auto &v = scriptVariable.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->variable).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 3, v->value_int);
        sqlite3_bind_double(stmt, 4, v->value_float);
        sqlite3_bind_text(stmt, 5, std::to_string(v->value_text).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadSettings()
{
    const std::string query = "select * from Settings;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = settings.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->player = sqlite3_column_int(stmt, 2);
        v->value_int = sqlite3_column_int(stmt, 3);
        v->value_float = (float)sqlite3_column_double(stmt, 4);
        v->value_text = (const char *)sqlite3_column_text(stmt, 5);
        v->value_blob = Blob(sqlite3_column_blob(stmt, 6), sqlite3_column_bytes(stmt, 6));
        settings.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadSettingsPtrs()
{
    for (auto &setting : settings)
    {
        auto player = players.find(setting->player.id);
        if (player != players.end())
            setting->player = *player;
    }
}

void StorageImpl::_loadSettingsArrays()
{
}

void StorageImpl::_saveSettings() const
{
    db->execute("BEGIN;");
    db->execute("delete from Settings;");
    const std::string query = "insert into Settings values (?, ?, ?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &setting : settings)
    {
        auto &v = setting.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 3, v->player.id);
        sqlite3_bind_int(stmt, 4, v->value_int);
        sqlite3_bind_double(stmt, 5, v->value_float);
        sqlite3_bind_text(stmt, 6, std::to_string(v->value_text).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_blob(stmt, 7, v->value_blob.getRawData(), v->value_blob.getLength(), SQLITE_TRANSIENT);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadStrings()
{
    const std::string query = "select * from Strings;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = strings.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->table = sqlite3_column_int(stmt, 2);
        v->ru = (const char *)sqlite3_column_text(stmt, 3);
        v->en = (const char *)sqlite3_column_text(stmt, 4);
        strings.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadStringsPtrs()
{
    for (auto &string : strings)
    {
        auto table = tables.find(string->table.id);
        if (table != tables.end())
            string->table = *table;
    }
}

void StorageImpl::_loadStringsArrays()
{
}

void StorageImpl::_saveStrings() const
{
    db->execute("BEGIN;");
    db->execute("delete from Strings;");
    const std::string query = "insert into Strings values (?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &string : strings)
    {
        auto &v = string.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 3, v->table.id);
        sqlite3_bind_text(stmt, 4, std::to_string(v->ru).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 5, std::to_string(v->en).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadTables()
{
    const std::string query = "select * from Tables;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = tables.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text = (const char *)sqlite3_column_text(stmt, 1);
        tables.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadTablesPtrs()
{
}

void StorageImpl::_loadTablesArrays()
{
}

void StorageImpl::_saveTables() const
{
    db->execute("BEGIN;");
    db->execute("delete from Tables;");
    const std::string query = "insert into Tables values (?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &table : tables)
    {
        auto &v = table.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadWeapons()
{
    const std::string query = "select * from Weapons;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = weapons.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name = sqlite3_column_int(stmt, 3);
        v->projectile = sqlite3_column_int(stmt, 4);
        v->type = sqlite3_column_int(stmt, 5);
        v->standard = sqlite3_column_int(stmt, 6);
        v->weight = (float)sqlite3_column_double(stmt, 7);
        v->power = (float)sqlite3_column_double(stmt, 8);
        v->firerate = (float)sqlite3_column_double(stmt, 9);
        v->damage = (float)sqlite3_column_double(stmt, 10);
        v->price = (float)sqlite3_column_double(stmt, 11);
        v->fx = (float)sqlite3_column_double(stmt, 12);
        v->shoottype = sqlite3_column_int(stmt, 13);
        v->shootscale = (float)sqlite3_column_double(stmt, 14);
        v->xstate = sqlite3_column_int(stmt, 15);
        v->rcolor = (float)sqlite3_column_double(stmt, 16);
        v->gcolor = (float)sqlite3_column_double(stmt, 17);
        v->bcolor = (float)sqlite3_column_double(stmt, 18);
        v->typearms = sqlite3_column_int(stmt, 19);
        v->tfire = (float)sqlite3_column_double(stmt, 20);
        v->vtype = sqlite3_column_int(stmt, 21);
        v->spare = (float)sqlite3_column_double(stmt, 22);
        v->reconstruction = (float)sqlite3_column_double(stmt, 23);
        v->maxdistance = (float)sqlite3_column_double(stmt, 24);
        v->angle = (float)sqlite3_column_double(stmt, 25);
        v->fxtime = (float)sqlite3_column_double(stmt, 26);
        v->damagetype = sqlite3_column_int(stmt, 27);
        v->fxmodeltime = (float)sqlite3_column_double(stmt, 28);
        v->inside_mul = (float)sqlite3_column_double(stmt, 29);
        v->inside_x = (float)sqlite3_column_double(stmt, 30);
        v->inside_y = (float)sqlite3_column_double(stmt, 31);
        v->inside_z = (float)sqlite3_column_double(stmt, 32);
        v->notrade = !!sqlite3_column_int(stmt, 33);
        weapons.insert(v);
    }
    sqlite3_finalize(stmt);
}

void StorageImpl::_loadWeaponsPtrs()
{
    for (auto &weapon : weapons)
    {
        auto name = strings.find(weapon->name.id);
        if (name != strings.end())
            weapon->name = *name;

        auto projectile = projectiles.find(weapon->projectile.id);
        if (projectile != projectiles.end())
            weapon->projectile = *projectile;
    }
}

void StorageImpl::_loadWeaponsArrays()
{
}

void StorageImpl::_saveWeapons() const
{
    db->execute("BEGIN;");
    db->execute("delete from Weapons;");
    const std::string query = "insert into Weapons values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &weapon : weapons)
    {
        auto &v = weapon.second;
        sqlite3_bind_int(stmt, 1, v->id);
        sqlite3_bind_text(stmt, 2, std::to_string(v->text_id).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_text(stmt, 3, std::to_string(v->resource).c_str(), -1, SQLITE_TRANSIENT);
        sqlite3_bind_int(stmt, 4, v->name.id);
        sqlite3_bind_int(stmt, 5, v->projectile.id);
        sqlite3_bind_int(stmt, 6, v->type);
        sqlite3_bind_int(stmt, 7, v->standard);
        sqlite3_bind_double(stmt, 8, v->weight);
        sqlite3_bind_double(stmt, 9, v->power);
        sqlite3_bind_double(stmt, 10, v->firerate);
        sqlite3_bind_double(stmt, 11, v->damage);
        sqlite3_bind_double(stmt, 12, v->price);
        sqlite3_bind_double(stmt, 13, v->fx);
        sqlite3_bind_int(stmt, 14, v->shoottype);
        sqlite3_bind_double(stmt, 15, v->shootscale);
        sqlite3_bind_int(stmt, 16, v->xstate);
        sqlite3_bind_double(stmt, 17, v->rcolor);
        sqlite3_bind_double(stmt, 18, v->gcolor);
        sqlite3_bind_double(stmt, 19, v->bcolor);
        sqlite3_bind_int(stmt, 20, v->typearms);
        sqlite3_bind_double(stmt, 21, v->tfire);
        sqlite3_bind_int(stmt, 22, v->vtype);
        sqlite3_bind_double(stmt, 23, v->spare);
        sqlite3_bind_double(stmt, 24, v->reconstruction);
        sqlite3_bind_double(stmt, 25, v->maxdistance);
        sqlite3_bind_double(stmt, 26, v->angle);
        sqlite3_bind_double(stmt, 27, v->fxtime);
        sqlite3_bind_int(stmt, 28, v->damagetype);
        sqlite3_bind_double(stmt, 29, v->fxmodeltime);
        sqlite3_bind_double(stmt, 30, v->inside_mul);
        sqlite3_bind_double(stmt, 31, v->inside_x);
        sqlite3_bind_double(stmt, 32, v->inside_y);
        sqlite3_bind_double(stmt, 33, v->inside_z);
        sqlite3_bind_int(stmt, 34, v->notrade);
        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }
    sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::create() const
{
    db->execute(Building::getSql());
    db->execute(Clan::getSql());
    db->execute(ClanReputation::getSql());
    db->execute(Configuration::getSql());
    db->execute(ConfigurationEquipment::getSql());
    db->execute(ConfigurationGood::getSql());
    db->execute(ConfigurationProjectile::getSql());
    db->execute(ConfigurationWeapon::getSql());
    db->execute(Equipment::getSql());
    db->execute(Glider::getSql());
    db->execute(Good::getSql());
    db->execute(Group::getSql());
    db->execute(GroupMechanoid::getSql());
    db->execute(Map::getSql());
    db->execute(MapBuilding::getSql());
    db->execute(MapBuildingEquipment::getSql());
    db->execute(MapBuildingGlider::getSql());
    db->execute(MapBuildingGood::getSql());
    db->execute(MapBuildingModificator::getSql());
    db->execute(MapBuildingProjectile::getSql());
    db->execute(MapBuildingWeapon::getSql());
    db->execute(MapGood::getSql());
    db->execute(MapObject::getSql());
    db->execute(Mechanoid::getSql());
    db->execute(MechanoidQuest::getSql());
    db->execute(Modification::getSql());
    db->execute(ModificationMap::getSql());
    db->execute(Modificator::getSql());
    db->execute(Object::getSql());
    db->execute(Player::getSql());
    db->execute(Projectile::getSql());
    db->execute(Quest::getSql());
    db->execute(QuestReward::getSql());
    db->execute(QuestRewardEquipment::getSql());
    db->execute(QuestRewardGlider::getSql());
    db->execute(QuestRewardGood::getSql());
    db->execute(QuestRewardModificator::getSql());
    db->execute(QuestRewardProjectile::getSql());
    db->execute(QuestRewardReputation::getSql());
    db->execute(QuestRewardWeapon::getSql());
    db->execute(ScriptVariable::getSql());
    db->execute(Setting::getSql());
    db->execute(String::getSql());
    db->execute(Table::getSql());
    db->execute(Weapon::getSql());
}

void StorageImpl::clear()
{
    buildings.clear();
    clans.clear();
    clanReputations.clear();
    configurations.clear();
    configurationEquipments.clear();
    configurationGoods.clear();
    configurationProjectiles.clear();
    configurationWeapons.clear();
    equipments.clear();
    gliders.clear();
    goods.clear();
    groups.clear();
    groupMechanoids.clear();
    maps.clear();
    mapBuildings.clear();
    mapBuildingEquipments.clear();
    mapBuildingGliders.clear();
    mapBuildingGoods.clear();
    mapBuildingModificators.clear();
    mapBuildingProjectiles.clear();
    mapBuildingWeapons.clear();
    mapGoods.clear();
    mapObjects.clear();
    mechanoids.clear();
    mechanoidQuests.clear();
    modifications.clear();
    modificationMaps.clear();
    modificators.clear();
    objects.clear();
    players.clear();
    projectiles.clear();
    quests.clear();
    questRewards.clear();
    questRewardEquipments.clear();
    questRewardGliders.clear();
    questRewardGoods.clear();
    questRewardModificators.clear();
    questRewardProjectiles.clear();
    questRewardReputations.clear();
    questRewardWeapons.clear();
    scriptVariables.clear();
    settings.clear();
    strings.clear();
    tables.clear();
    weapons.clear();
}

void StorageImpl::load(ProgressCallback callback)
{
    _loadBuildings();
    PROGRESS_CALLBACK(0.740741);
    _loadClans();
    PROGRESS_CALLBACK(1.481481);
    _loadClanReputations();
    PROGRESS_CALLBACK(2.222222);
    _loadConfigurations();
    PROGRESS_CALLBACK(2.962963);
    _loadConfigurationEquipments();
    PROGRESS_CALLBACK(3.703704);
    _loadConfigurationGoods();
    PROGRESS_CALLBACK(4.444444);
    _loadConfigurationProjectiles();
    PROGRESS_CALLBACK(5.185185);
    _loadConfigurationWeapons();
    PROGRESS_CALLBACK(5.925926);
    _loadEquipments();
    PROGRESS_CALLBACK(6.666667);
    _loadGliders();
    PROGRESS_CALLBACK(7.407407);
    _loadGoods();
    PROGRESS_CALLBACK(8.148148);
    _loadGroups();
    PROGRESS_CALLBACK(8.888889);
    _loadGroupMechanoids();
    PROGRESS_CALLBACK(9.629630);
    _loadMaps();
    PROGRESS_CALLBACK(10.370370);
    _loadMapBuildings();
    PROGRESS_CALLBACK(11.111111);
    _loadMapBuildingEquipments();
    PROGRESS_CALLBACK(11.851852);
    _loadMapBuildingGliders();
    PROGRESS_CALLBACK(12.592593);
    _loadMapBuildingGoods();
    PROGRESS_CALLBACK(13.333333);
    _loadMapBuildingModificators();
    PROGRESS_CALLBACK(14.074074);
    _loadMapBuildingProjectiles();
    PROGRESS_CALLBACK(14.814815);
    _loadMapBuildingWeapons();
    PROGRESS_CALLBACK(15.555556);
    _loadMapGoods();
    PROGRESS_CALLBACK(16.296296);
    _loadMapObjects();
    PROGRESS_CALLBACK(17.037037);
    _loadMechanoids();
    PROGRESS_CALLBACK(17.777778);
    _loadMechanoidQuests();
    PROGRESS_CALLBACK(18.518519);
    _loadModifications();
    PROGRESS_CALLBACK(19.259259);
    _loadModificationMaps();
    PROGRESS_CALLBACK(20.000000);
    _loadModificators();
    PROGRESS_CALLBACK(20.740741);
    _loadObjects();
    PROGRESS_CALLBACK(21.481481);
    _loadPlayers();
    PROGRESS_CALLBACK(22.222222);
    _loadProjectiles();
    PROGRESS_CALLBACK(22.962963);
    _loadQuests();
    PROGRESS_CALLBACK(23.703704);
    _loadQuestRewards();
    PROGRESS_CALLBACK(24.444444);
    _loadQuestRewardEquipments();
    PROGRESS_CALLBACK(25.185185);
    _loadQuestRewardGliders();
    PROGRESS_CALLBACK(25.925926);
    _loadQuestRewardGoods();
    PROGRESS_CALLBACK(26.666667);
    _loadQuestRewardModificators();
    PROGRESS_CALLBACK(27.407407);
    _loadQuestRewardProjectiles();
    PROGRESS_CALLBACK(28.148148);
    _loadQuestRewardReputations();
    PROGRESS_CALLBACK(28.888889);
    _loadQuestRewardWeapons();
    PROGRESS_CALLBACK(29.629630);
    _loadScriptVariables();
    PROGRESS_CALLBACK(30.370370);
    _loadSettings();
    PROGRESS_CALLBACK(31.111111);
    _loadStrings();
    PROGRESS_CALLBACK(31.851852);
    _loadTables();
    PROGRESS_CALLBACK(32.592593);
    _loadWeapons();
    PROGRESS_CALLBACK(33.333333);

    _loadBuildingsPtrs();
    PROGRESS_CALLBACK(34.074074);
    _loadClansPtrs();
    PROGRESS_CALLBACK(34.814815);
    _loadClanReputationsPtrs();
    PROGRESS_CALLBACK(35.555556);
    _loadConfigurationsPtrs();
    PROGRESS_CALLBACK(36.296296);
    _loadConfigurationEquipmentsPtrs();
    PROGRESS_CALLBACK(37.037037);
    _loadConfigurationGoodsPtrs();
    PROGRESS_CALLBACK(37.777778);
    _loadConfigurationProjectilesPtrs();
    PROGRESS_CALLBACK(38.518519);
    _loadConfigurationWeaponsPtrs();
    PROGRESS_CALLBACK(39.259259);
    _loadEquipmentsPtrs();
    PROGRESS_CALLBACK(40.000000);
    _loadGlidersPtrs();
    PROGRESS_CALLBACK(40.740741);
    _loadGoodsPtrs();
    PROGRESS_CALLBACK(41.481481);
    _loadGroupsPtrs();
    PROGRESS_CALLBACK(42.222222);
    _loadGroupMechanoidsPtrs();
    PROGRESS_CALLBACK(42.962963);
    _loadMapsPtrs();
    PROGRESS_CALLBACK(43.703704);
    _loadMapBuildingsPtrs();
    PROGRESS_CALLBACK(44.444444);
    _loadMapBuildingEquipmentsPtrs();
    PROGRESS_CALLBACK(45.185185);
    _loadMapBuildingGlidersPtrs();
    PROGRESS_CALLBACK(45.925926);
    _loadMapBuildingGoodsPtrs();
    PROGRESS_CALLBACK(46.666667);
    _loadMapBuildingModificatorsPtrs();
    PROGRESS_CALLBACK(47.407407);
    _loadMapBuildingProjectilesPtrs();
    PROGRESS_CALLBACK(48.148148);
    _loadMapBuildingWeaponsPtrs();
    PROGRESS_CALLBACK(48.888889);
    _loadMapGoodsPtrs();
    PROGRESS_CALLBACK(49.629630);
    _loadMapObjectsPtrs();
    PROGRESS_CALLBACK(50.370370);
    _loadMechanoidsPtrs();
    PROGRESS_CALLBACK(51.111111);
    _loadMechanoidQuestsPtrs();
    PROGRESS_CALLBACK(51.851852);
    _loadModificationsPtrs();
    PROGRESS_CALLBACK(52.592593);
    _loadModificationMapsPtrs();
    PROGRESS_CALLBACK(53.333333);
    _loadModificatorsPtrs();
    PROGRESS_CALLBACK(54.074074);
    _loadObjectsPtrs();
    PROGRESS_CALLBACK(54.814815);
    _loadPlayersPtrs();
    PROGRESS_CALLBACK(55.555556);
    _loadProjectilesPtrs();
    PROGRESS_CALLBACK(56.296296);
    _loadQuestsPtrs();
    PROGRESS_CALLBACK(57.037037);
    _loadQuestRewardsPtrs();
    PROGRESS_CALLBACK(57.777778);
    _loadQuestRewardEquipmentsPtrs();
    PROGRESS_CALLBACK(58.518519);
    _loadQuestRewardGlidersPtrs();
    PROGRESS_CALLBACK(59.259259);
    _loadQuestRewardGoodsPtrs();
    PROGRESS_CALLBACK(60.000000);
    _loadQuestRewardModificatorsPtrs();
    PROGRESS_CALLBACK(60.740741);
    _loadQuestRewardProjectilesPtrs();
    PROGRESS_CALLBACK(61.481481);
    _loadQuestRewardReputationsPtrs();
    PROGRESS_CALLBACK(62.222222);
    _loadQuestRewardWeaponsPtrs();
    PROGRESS_CALLBACK(62.962963);
    _loadScriptVariablesPtrs();
    PROGRESS_CALLBACK(63.703704);
    _loadSettingsPtrs();
    PROGRESS_CALLBACK(64.444444);
    _loadStringsPtrs();
    PROGRESS_CALLBACK(65.185185);
    _loadTablesPtrs();
    PROGRESS_CALLBACK(65.925926);
    _loadWeaponsPtrs();
    PROGRESS_CALLBACK(66.666667);

    _loadBuildingsArrays();
    PROGRESS_CALLBACK(67.407407);
    _loadClansArrays();
    PROGRESS_CALLBACK(68.148148);
    _loadClanReputationsArrays();
    PROGRESS_CALLBACK(68.888889);
    _loadConfigurationsArrays();
    PROGRESS_CALLBACK(69.629630);
    _loadConfigurationEquipmentsArrays();
    PROGRESS_CALLBACK(70.370370);
    _loadConfigurationGoodsArrays();
    PROGRESS_CALLBACK(71.111111);
    _loadConfigurationProjectilesArrays();
    PROGRESS_CALLBACK(71.851852);
    _loadConfigurationWeaponsArrays();
    PROGRESS_CALLBACK(72.592593);
    _loadEquipmentsArrays();
    PROGRESS_CALLBACK(73.333333);
    _loadGlidersArrays();
    PROGRESS_CALLBACK(74.074074);
    _loadGoodsArrays();
    PROGRESS_CALLBACK(74.814815);
    _loadGroupsArrays();
    PROGRESS_CALLBACK(75.555556);
    _loadGroupMechanoidsArrays();
    PROGRESS_CALLBACK(76.296296);
    _loadMapsArrays();
    PROGRESS_CALLBACK(77.037037);
    _loadMapBuildingsArrays();
    PROGRESS_CALLBACK(77.777778);
    _loadMapBuildingEquipmentsArrays();
    PROGRESS_CALLBACK(78.518519);
    _loadMapBuildingGlidersArrays();
    PROGRESS_CALLBACK(79.259259);
    _loadMapBuildingGoodsArrays();
    PROGRESS_CALLBACK(80.000000);
    _loadMapBuildingModificatorsArrays();
    PROGRESS_CALLBACK(80.740741);
    _loadMapBuildingProjectilesArrays();
    PROGRESS_CALLBACK(81.481481);
    _loadMapBuildingWeaponsArrays();
    PROGRESS_CALLBACK(82.222222);
    _loadMapGoodsArrays();
    PROGRESS_CALLBACK(82.962963);
    _loadMapObjectsArrays();
    PROGRESS_CALLBACK(83.703704);
    _loadMechanoidsArrays();
    PROGRESS_CALLBACK(84.444444);
    _loadMechanoidQuestsArrays();
    PROGRESS_CALLBACK(85.185185);
    _loadModificationsArrays();
    PROGRESS_CALLBACK(85.925926);
    _loadModificationMapsArrays();
    PROGRESS_CALLBACK(86.666667);
    _loadModificatorsArrays();
    PROGRESS_CALLBACK(87.407407);
    _loadObjectsArrays();
    PROGRESS_CALLBACK(88.148148);
    _loadPlayersArrays();
    PROGRESS_CALLBACK(88.888889);
    _loadProjectilesArrays();
    PROGRESS_CALLBACK(89.629630);
    _loadQuestsArrays();
    PROGRESS_CALLBACK(90.370370);
    _loadQuestRewardsArrays();
    PROGRESS_CALLBACK(91.111111);
    _loadQuestRewardEquipmentsArrays();
    PROGRESS_CALLBACK(91.851852);
    _loadQuestRewardGlidersArrays();
    PROGRESS_CALLBACK(92.592593);
    _loadQuestRewardGoodsArrays();
    PROGRESS_CALLBACK(93.333333);
    _loadQuestRewardModificatorsArrays();
    PROGRESS_CALLBACK(94.074074);
    _loadQuestRewardProjectilesArrays();
    PROGRESS_CALLBACK(94.814815);
    _loadQuestRewardReputationsArrays();
    PROGRESS_CALLBACK(95.555556);
    _loadQuestRewardWeaponsArrays();
    PROGRESS_CALLBACK(96.296296);
    _loadScriptVariablesArrays();
    PROGRESS_CALLBACK(97.037037);
    _loadSettingsArrays();
    PROGRESS_CALLBACK(97.777778);
    _loadStringsArrays();
    PROGRESS_CALLBACK(98.518519);
    _loadTablesArrays();
    PROGRESS_CALLBACK(99.259259);
    _loadWeaponsArrays();
    PROGRESS_CALLBACK(100.000000);
}

void StorageImpl::save(ProgressCallback callback) const
{
    _saveBuildings();
    PROGRESS_CALLBACK(2.222222);
    _saveClans();
    PROGRESS_CALLBACK(4.444444);
    _saveClanReputations();
    PROGRESS_CALLBACK(6.666667);
    _saveConfigurations();
    PROGRESS_CALLBACK(8.888889);
    _saveConfigurationEquipments();
    PROGRESS_CALLBACK(11.111111);
    _saveConfigurationGoods();
    PROGRESS_CALLBACK(13.333333);
    _saveConfigurationProjectiles();
    PROGRESS_CALLBACK(15.555556);
    _saveConfigurationWeapons();
    PROGRESS_CALLBACK(17.777778);
    _saveEquipments();
    PROGRESS_CALLBACK(20.000000);
    _saveGliders();
    PROGRESS_CALLBACK(22.222222);
    _saveGoods();
    PROGRESS_CALLBACK(24.444444);
    _saveGroups();
    PROGRESS_CALLBACK(26.666667);
    _saveGroupMechanoids();
    PROGRESS_CALLBACK(28.888889);
    _saveMaps();
    PROGRESS_CALLBACK(31.111111);
    _saveMapBuildings();
    PROGRESS_CALLBACK(33.333333);
    _saveMapBuildingEquipments();
    PROGRESS_CALLBACK(35.555556);
    _saveMapBuildingGliders();
    PROGRESS_CALLBACK(37.777778);
    _saveMapBuildingGoods();
    PROGRESS_CALLBACK(40.000000);
    _saveMapBuildingModificators();
    PROGRESS_CALLBACK(42.222222);
    _saveMapBuildingProjectiles();
    PROGRESS_CALLBACK(44.444444);
    _saveMapBuildingWeapons();
    PROGRESS_CALLBACK(46.666667);
    _saveMapGoods();
    PROGRESS_CALLBACK(48.888889);
    _saveMapObjects();
    PROGRESS_CALLBACK(51.111111);
    _saveMechanoids();
    PROGRESS_CALLBACK(53.333333);
    _saveMechanoidQuests();
    PROGRESS_CALLBACK(55.555556);
    _saveModifications();
    PROGRESS_CALLBACK(57.777778);
    _saveModificationMaps();
    PROGRESS_CALLBACK(60.000000);
    _saveModificators();
    PROGRESS_CALLBACK(62.222222);
    _saveObjects();
    PROGRESS_CALLBACK(64.444444);
    _savePlayers();
    PROGRESS_CALLBACK(66.666667);
    _saveProjectiles();
    PROGRESS_CALLBACK(68.888889);
    _saveQuests();
    PROGRESS_CALLBACK(71.111111);
    _saveQuestRewards();
    PROGRESS_CALLBACK(73.333333);
    _saveQuestRewardEquipments();
    PROGRESS_CALLBACK(75.555556);
    _saveQuestRewardGliders();
    PROGRESS_CALLBACK(77.777778);
    _saveQuestRewardGoods();
    PROGRESS_CALLBACK(80.000000);
    _saveQuestRewardModificators();
    PROGRESS_CALLBACK(82.222222);
    _saveQuestRewardProjectiles();
    PROGRESS_CALLBACK(84.444444);
    _saveQuestRewardReputations();
    PROGRESS_CALLBACK(86.666667);
    _saveQuestRewardWeapons();
    PROGRESS_CALLBACK(88.888889);
    _saveScriptVariables();
    PROGRESS_CALLBACK(91.111111);
    _saveSettings();
    PROGRESS_CALLBACK(93.333333);
    _saveStrings();
    PROGRESS_CALLBACK(95.555556);
    _saveTables();
    PROGRESS_CALLBACK(97.777778);
    _saveWeapons();
    PROGRESS_CALLBACK(100.000000);
}

IdPtr<Building> StorageImpl::addBuilding()
{
    return buildings.createAtEnd();
}

void StorageImpl::deleteBuilding(IObjectBase *v)
{
    buildings.erase(v->id);
}

IdPtr<Clan> StorageImpl::addClan()
{
    return clans.createAtEnd();
}

void StorageImpl::deleteClan(IObjectBase *v)
{
    clans.erase(v->id);
}

IdPtr<ClanReputation> StorageImpl::addClanReputation(IObjectBase *parent)
{
    auto v = clanReputations.createAtEnd();
    Clan *clan = (Clan *)parent;
    clan->reputations->insert(v);
    v->clan1 = clans[clan->id];
    return v;
}

void StorageImpl::deleteClanReputation(IObjectBase *v)
{
    clanReputations.erase(v->id);
}

IdPtr<Configuration> StorageImpl::addConfiguration()
{
    return configurations.createAtEnd();
}

void StorageImpl::deleteConfiguration(IObjectBase *v)
{
    configurations.erase(v->id);
}

IdPtr<ConfigurationEquipment> StorageImpl::addConfigurationEquipment(IObjectBase *parent)
{
    auto v = configurationEquipments.createAtEnd();
    Configuration *configuration = (Configuration *)parent;
    configuration->equipments->insert(v);
    v->configuration = configurations[configuration->id];
    return v;
}

void StorageImpl::deleteConfigurationEquipment(IObjectBase *v)
{
    configurationEquipments.erase(v->id);
}

IdPtr<ConfigurationGood> StorageImpl::addConfigurationGood(IObjectBase *parent)
{
    auto v = configurationGoods.createAtEnd();
    Configuration *configuration = (Configuration *)parent;
    configuration->goods->insert(v);
    v->configuration = configurations[configuration->id];
    return v;
}

void StorageImpl::deleteConfigurationGood(IObjectBase *v)
{
    configurationGoods.erase(v->id);
}

IdPtr<ConfigurationProjectile> StorageImpl::addConfigurationProjectile(IObjectBase *parent)
{
    auto v = configurationProjectiles.createAtEnd();
    Configuration *configuration = (Configuration *)parent;
    configuration->projectiles->insert(v);
    v->configuration = configurations[configuration->id];
    return v;
}

void StorageImpl::deleteConfigurationProjectile(IObjectBase *v)
{
    configurationProjectiles.erase(v->id);
}

IdPtr<ConfigurationWeapon> StorageImpl::addConfigurationWeapon(IObjectBase *parent)
{
    auto v = configurationWeapons.createAtEnd();
    Configuration *configuration = (Configuration *)parent;
    configuration->weapons->insert(v);
    v->configuration = configurations[configuration->id];
    return v;
}

void StorageImpl::deleteConfigurationWeapon(IObjectBase *v)
{
    configurationWeapons.erase(v->id);
}

IdPtr<Equipment> StorageImpl::addEquipment()
{
    return equipments.createAtEnd();
}

void StorageImpl::deleteEquipment(IObjectBase *v)
{
    equipments.erase(v->id);
}

IdPtr<Glider> StorageImpl::addGlider()
{
    return gliders.createAtEnd();
}

void StorageImpl::deleteGlider(IObjectBase *v)
{
    gliders.erase(v->id);
}

IdPtr<Good> StorageImpl::addGood()
{
    return goods.createAtEnd();
}

void StorageImpl::deleteGood(IObjectBase *v)
{
    goods.erase(v->id);
}

IdPtr<Group> StorageImpl::addGroup()
{
    return groups.createAtEnd();
}

void StorageImpl::deleteGroup(IObjectBase *v)
{
    groups.erase(v->id);
}

IdPtr<GroupMechanoid> StorageImpl::addGroupMechanoid(IObjectBase *parent)
{
    auto v = groupMechanoids.createAtEnd();
    Group *group = (Group *)parent;
    group->mechanoids->insert(v);
    v->group = groups[group->id];
    return v;
}

void StorageImpl::deleteGroupMechanoid(IObjectBase *v)
{
    groupMechanoids.erase(v->id);
}

IdPtr<Map> StorageImpl::addMap()
{
    return maps.createAtEnd();
}

void StorageImpl::deleteMap(IObjectBase *v)
{
    maps.erase(v->id);
}

IdPtr<MapBuilding> StorageImpl::addMapBuilding(IObjectBase *parent)
{
    return mapBuildings.createAtEnd();
}

void StorageImpl::deleteMapBuilding(IObjectBase *v)
{
    mapBuildings.erase(v->id);
}

IdPtr<MapBuildingEquipment> StorageImpl::addMapBuildingEquipment(IObjectBase *parent)
{
    auto v = mapBuildingEquipments.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->equipments->insert(v);
    v->map_building = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingEquipment(IObjectBase *v)
{
    mapBuildingEquipments.erase(v->id);
}

IdPtr<MapBuildingGlider> StorageImpl::addMapBuildingGlider(IObjectBase *parent)
{
    auto v = mapBuildingGliders.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->gliders->insert(v);
    v->map_building = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingGlider(IObjectBase *v)
{
    mapBuildingGliders.erase(v->id);
}

IdPtr<MapBuildingGood> StorageImpl::addMapBuildingGood(IObjectBase *parent)
{
    auto v = mapBuildingGoods.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->goods->insert(v);
    v->map_building = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingGood(IObjectBase *v)
{
    mapBuildingGoods.erase(v->id);
}

IdPtr<MapBuildingModificator> StorageImpl::addMapBuildingModificator(IObjectBase *parent)
{
    auto v = mapBuildingModificators.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->modificators->insert(v);
    v->map_building = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingModificator(IObjectBase *v)
{
    mapBuildingModificators.erase(v->id);
}

IdPtr<MapBuildingProjectile> StorageImpl::addMapBuildingProjectile(IObjectBase *parent)
{
    auto v = mapBuildingProjectiles.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->projectiles->insert(v);
    v->map_building = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingProjectile(IObjectBase *v)
{
    mapBuildingProjectiles.erase(v->id);
}

IdPtr<MapBuildingWeapon> StorageImpl::addMapBuildingWeapon(IObjectBase *parent)
{
    auto v = mapBuildingWeapons.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->weapons->insert(v);
    v->map_building = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingWeapon(IObjectBase *v)
{
    mapBuildingWeapons.erase(v->id);
}

IdPtr<MapGood> StorageImpl::addMapGood(IObjectBase *parent)
{
    return mapGoods.createAtEnd();
}

void StorageImpl::deleteMapGood(IObjectBase *v)
{
    mapGoods.erase(v->id);
}

IdPtr<MapObject> StorageImpl::addMapObject(IObjectBase *parent)
{
    return mapObjects.createAtEnd();
}

void StorageImpl::deleteMapObject(IObjectBase *v)
{
    mapObjects.erase(v->id);
}

IdPtr<Mechanoid> StorageImpl::addMechanoid()
{
    return mechanoids.createAtEnd();
}

void StorageImpl::deleteMechanoid(IObjectBase *v)
{
    mechanoids.erase(v->id);
}

IdPtr<MechanoidQuest> StorageImpl::addMechanoidQuest(IObjectBase *parent)
{
    auto v = mechanoidQuests.createAtEnd();
    Mechanoid *mechanoid = (Mechanoid *)parent;
    mechanoid->quests->insert(v);
    v->mechanoid = mechanoids[mechanoid->id];
    return v;
}

void StorageImpl::deleteMechanoidQuest(IObjectBase *v)
{
    mechanoidQuests.erase(v->id);
}

IdPtr<Modification> StorageImpl::addModification()
{
    return modifications.createAtEnd();
}

void StorageImpl::deleteModification(IObjectBase *v)
{
    modifications.erase(v->id);
}

IdPtr<ModificationMap> StorageImpl::addModificationMap(IObjectBase *parent)
{
    auto v = modificationMaps.createAtEnd();
    Modification *modification = (Modification *)parent;
    modification->maps->insert(v);
    v->modification = modifications[modification->id];
    return v;
}

void StorageImpl::deleteModificationMap(IObjectBase *v)
{
    modificationMaps.erase(v->id);
}

IdPtr<Modificator> StorageImpl::addModificator()
{
    return modificators.createAtEnd();
}

void StorageImpl::deleteModificator(IObjectBase *v)
{
    modificators.erase(v->id);
}

IdPtr<Object> StorageImpl::addObject()
{
    return objects.createAtEnd();
}

void StorageImpl::deleteObject(IObjectBase *v)
{
    objects.erase(v->id);
}

IdPtr<Player> StorageImpl::addPlayer()
{
    return players.createAtEnd();
}

void StorageImpl::deletePlayer(IObjectBase *v)
{
    players.erase(v->id);
}

IdPtr<Projectile> StorageImpl::addProjectile()
{
    return projectiles.createAtEnd();
}

void StorageImpl::deleteProjectile(IObjectBase *v)
{
    projectiles.erase(v->id);
}

IdPtr<Quest> StorageImpl::addQuest()
{
    return quests.createAtEnd();
}

void StorageImpl::deleteQuest(IObjectBase *v)
{
    quests.erase(v->id);
}

IdPtr<QuestReward> StorageImpl::addQuestReward(IObjectBase *parent)
{
    return questRewards.createAtEnd();
}

void StorageImpl::deleteQuestReward(IObjectBase *v)
{
    questRewards.erase(v->id);
}

IdPtr<QuestRewardEquipment> StorageImpl::addQuestRewardEquipment(IObjectBase *parent)
{
    auto v = questRewardEquipments.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->equipments->insert(v);
    v->quest_reward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardEquipment(IObjectBase *v)
{
    questRewardEquipments.erase(v->id);
}

IdPtr<QuestRewardGlider> StorageImpl::addQuestRewardGlider(IObjectBase *parent)
{
    auto v = questRewardGliders.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->gliders->insert(v);
    v->quest_reward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardGlider(IObjectBase *v)
{
    questRewardGliders.erase(v->id);
}

IdPtr<QuestRewardGood> StorageImpl::addQuestRewardGood(IObjectBase *parent)
{
    auto v = questRewardGoods.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->goods->insert(v);
    v->quest_reward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardGood(IObjectBase *v)
{
    questRewardGoods.erase(v->id);
}

IdPtr<QuestRewardModificator> StorageImpl::addQuestRewardModificator(IObjectBase *parent)
{
    auto v = questRewardModificators.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->modificators->insert(v);
    v->quest_reward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardModificator(IObjectBase *v)
{
    questRewardModificators.erase(v->id);
}

IdPtr<QuestRewardProjectile> StorageImpl::addQuestRewardProjectile(IObjectBase *parent)
{
    auto v = questRewardProjectiles.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->projectiles->insert(v);
    v->quest_reward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardProjectile(IObjectBase *v)
{
    questRewardProjectiles.erase(v->id);
}

IdPtr<QuestRewardReputation> StorageImpl::addQuestRewardReputation(IObjectBase *parent)
{
    auto v = questRewardReputations.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->reputations->insert(v);
    v->quest_reward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardReputation(IObjectBase *v)
{
    questRewardReputations.erase(v->id);
}

IdPtr<QuestRewardWeapon> StorageImpl::addQuestRewardWeapon(IObjectBase *parent)
{
    auto v = questRewardWeapons.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->weapons->insert(v);
    v->quest_reward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardWeapon(IObjectBase *v)
{
    questRewardWeapons.erase(v->id);
}

IdPtr<ScriptVariable> StorageImpl::addScriptVariable()
{
    return scriptVariables.createAtEnd();
}

void StorageImpl::deleteScriptVariable(IObjectBase *v)
{
    scriptVariables.erase(v->id);
}

IdPtr<Setting> StorageImpl::addSetting()
{
    return settings.createAtEnd();
}

void StorageImpl::deleteSetting(IObjectBase *v)
{
    settings.erase(v->id);
}

IdPtr<String> StorageImpl::addString()
{
    return strings.createAtEnd();
}

void StorageImpl::deleteString(IObjectBase *v)
{
    strings.erase(v->id);
}

IdPtr<Table> StorageImpl::addTable()
{
    return tables.createAtEnd();
}

void StorageImpl::deleteTable(IObjectBase *v)
{
    tables.erase(v->id);
}

IdPtr<Weapon> StorageImpl::addWeapon()
{
    return weapons.createAtEnd();
}

void StorageImpl::deleteWeapon(IObjectBase *v)
{
    weapons.erase(v->id);
}

IdPtr<IObjectBase> StorageImpl::addRecord(IObjectBase *parent)
{
    IdPtr<IObjectBase> p;
    EObjectType type = parent->getType();
    switch (type)
    {
    case EObjectType::Building:
        p = addBuilding();
        break;
    case EObjectType::Clan:
        p = addClan();
        break;
    case EObjectType::ClanReputation:
        p = addClanReputation(parent);
        break;
    case EObjectType::Configuration:
        p = addConfiguration();
        break;
    case EObjectType::ConfigurationEquipment:
        p = addConfigurationEquipment(parent);
        break;
    case EObjectType::ConfigurationGood:
        p = addConfigurationGood(parent);
        break;
    case EObjectType::ConfigurationProjectile:
        p = addConfigurationProjectile(parent);
        break;
    case EObjectType::ConfigurationWeapon:
        p = addConfigurationWeapon(parent);
        break;
    case EObjectType::Equipment:
        p = addEquipment();
        break;
    case EObjectType::Glider:
        p = addGlider();
        break;
    case EObjectType::Good:
        p = addGood();
        break;
    case EObjectType::Group:
        p = addGroup();
        break;
    case EObjectType::GroupMechanoid:
        p = addGroupMechanoid(parent);
        break;
    case EObjectType::Map:
        p = addMap();
        break;
    case EObjectType::MapBuilding:
        p = addMapBuilding(parent);
        break;
    case EObjectType::MapBuildingEquipment:
        p = addMapBuildingEquipment(parent);
        break;
    case EObjectType::MapBuildingGlider:
        p = addMapBuildingGlider(parent);
        break;
    case EObjectType::MapBuildingGood:
        p = addMapBuildingGood(parent);
        break;
    case EObjectType::MapBuildingModificator:
        p = addMapBuildingModificator(parent);
        break;
    case EObjectType::MapBuildingProjectile:
        p = addMapBuildingProjectile(parent);
        break;
    case EObjectType::MapBuildingWeapon:
        p = addMapBuildingWeapon(parent);
        break;
    case EObjectType::MapGood:
        p = addMapGood(parent);
        break;
    case EObjectType::MapObject:
        p = addMapObject(parent);
        break;
    case EObjectType::Mechanoid:
        p = addMechanoid();
        break;
    case EObjectType::MechanoidQuest:
        p = addMechanoidQuest(parent);
        break;
    case EObjectType::Modification:
        p = addModification();
        break;
    case EObjectType::ModificationMap:
        p = addModificationMap(parent);
        break;
    case EObjectType::Modificator:
        p = addModificator();
        break;
    case EObjectType::Object:
        p = addObject();
        break;
    case EObjectType::Player:
        p = addPlayer();
        break;
    case EObjectType::Projectile:
        p = addProjectile();
        break;
    case EObjectType::Quest:
        p = addQuest();
        break;
    case EObjectType::QuestReward:
        p = addQuestReward(parent);
        break;
    case EObjectType::QuestRewardEquipment:
        p = addQuestRewardEquipment(parent);
        break;
    case EObjectType::QuestRewardGlider:
        p = addQuestRewardGlider(parent);
        break;
    case EObjectType::QuestRewardGood:
        p = addQuestRewardGood(parent);
        break;
    case EObjectType::QuestRewardModificator:
        p = addQuestRewardModificator(parent);
        break;
    case EObjectType::QuestRewardProjectile:
        p = addQuestRewardProjectile(parent);
        break;
    case EObjectType::QuestRewardReputation:
        p = addQuestRewardReputation(parent);
        break;
    case EObjectType::QuestRewardWeapon:
        p = addQuestRewardWeapon(parent);
        break;
    case EObjectType::ScriptVariable:
        p = addScriptVariable();
        break;
    case EObjectType::Setting:
        p = addSetting();
        break;
    case EObjectType::String:
        p = addString();
        break;
    case EObjectType::Table:
        p = addTable();
        break;
    case EObjectType::Weapon:
        p = addWeapon();
        break;
    default:
        break;
    }
    return p;
}

void StorageImpl::deleteRecord(IObjectBase *data)
{
    EObjectType type = data->getType();
    switch (type)
    {
    case EObjectType::Building:
        deleteBuilding(data);
        break;
    case EObjectType::Clan:
        deleteClan(data);
        break;
    case EObjectType::ClanReputation:
        deleteClanReputation(data);
        break;
    case EObjectType::Configuration:
        deleteConfiguration(data);
        break;
    case EObjectType::ConfigurationEquipment:
        deleteConfigurationEquipment(data);
        break;
    case EObjectType::ConfigurationGood:
        deleteConfigurationGood(data);
        break;
    case EObjectType::ConfigurationProjectile:
        deleteConfigurationProjectile(data);
        break;
    case EObjectType::ConfigurationWeapon:
        deleteConfigurationWeapon(data);
        break;
    case EObjectType::Equipment:
        deleteEquipment(data);
        break;
    case EObjectType::Glider:
        deleteGlider(data);
        break;
    case EObjectType::Good:
        deleteGood(data);
        break;
    case EObjectType::Group:
        deleteGroup(data);
        break;
    case EObjectType::GroupMechanoid:
        deleteGroupMechanoid(data);
        break;
    case EObjectType::Map:
        deleteMap(data);
        break;
    case EObjectType::MapBuilding:
        deleteMapBuilding(data);
        break;
    case EObjectType::MapBuildingEquipment:
        deleteMapBuildingEquipment(data);
        break;
    case EObjectType::MapBuildingGlider:
        deleteMapBuildingGlider(data);
        break;
    case EObjectType::MapBuildingGood:
        deleteMapBuildingGood(data);
        break;
    case EObjectType::MapBuildingModificator:
        deleteMapBuildingModificator(data);
        break;
    case EObjectType::MapBuildingProjectile:
        deleteMapBuildingProjectile(data);
        break;
    case EObjectType::MapBuildingWeapon:
        deleteMapBuildingWeapon(data);
        break;
    case EObjectType::MapGood:
        deleteMapGood(data);
        break;
    case EObjectType::MapObject:
        deleteMapObject(data);
        break;
    case EObjectType::Mechanoid:
        deleteMechanoid(data);
        break;
    case EObjectType::MechanoidQuest:
        deleteMechanoidQuest(data);
        break;
    case EObjectType::Modification:
        deleteModification(data);
        break;
    case EObjectType::ModificationMap:
        deleteModificationMap(data);
        break;
    case EObjectType::Modificator:
        deleteModificator(data);
        break;
    case EObjectType::Object:
        deleteObject(data);
        break;
    case EObjectType::Player:
        deletePlayer(data);
        break;
    case EObjectType::Projectile:
        deleteProjectile(data);
        break;
    case EObjectType::Quest:
        deleteQuest(data);
        break;
    case EObjectType::QuestReward:
        deleteQuestReward(data);
        break;
    case EObjectType::QuestRewardEquipment:
        deleteQuestRewardEquipment(data);
        break;
    case EObjectType::QuestRewardGlider:
        deleteQuestRewardGlider(data);
        break;
    case EObjectType::QuestRewardGood:
        deleteQuestRewardGood(data);
        break;
    case EObjectType::QuestRewardModificator:
        deleteQuestRewardModificator(data);
        break;
    case EObjectType::QuestRewardProjectile:
        deleteQuestRewardProjectile(data);
        break;
    case EObjectType::QuestRewardReputation:
        deleteQuestRewardReputation(data);
        break;
    case EObjectType::QuestRewardWeapon:
        deleteQuestRewardWeapon(data);
        break;
    case EObjectType::ScriptVariable:
        deleteScriptVariable(data);
        break;
    case EObjectType::Setting:
        deleteSetting(data);
        break;
    case EObjectType::String:
        deleteString(data);
        break;
    case EObjectType::Table:
        deleteTable(data);
        break;
    case EObjectType::Weapon:
        deleteWeapon(data);
        break;
    default:
        break;
    }
}

Ptr<TreeItem> StorageImpl::printTree() const
{
    Ptr<TreeItem> root = std::make_shared<TreeItem>();
    Ptr<TreeItem> item;
    Ptr<TreeItem> tmp;

    item = std::make_shared<TreeItem>();
    item->name = "Buildings";
    item->type = EObjectType::Building;
    item->parent = root.get();
    auto buildings = getOrderedMap(EObjectType::Building);
    for (auto &v : buildings)
    {
        item->children.push_back(tmp = v.second->printTree());
        tmp->parent = item.get();
    }
    root->children.push_back(item);

    item = std::make_shared<TreeItem>();
    item->name = "Configurations";
    item->type = EObjectType::Configuration;
    item->parent = root.get();
    auto configurations = getOrderedMap(EObjectType::Configuration);
    for (auto &v : configurations)
    {
        item->children.push_back(tmp = v.second->printTree());
        tmp->parent = item.get();
    }
    root->children.push_back(item);

    item = std::make_shared<TreeItem>();
    item->name = "Equipments";
    item->type = EObjectType::Equipment;
    item->parent = root.get();
    auto equipments = getOrderedMap(EObjectType::Equipment);
    for (auto &v : equipments)
    {
        item->children.push_back(tmp = v.second->printTree());
        tmp->parent = item.get();
    }
    root->children.push_back(item);

    item = std::make_shared<TreeItem>();
    item->name = "Gliders";
    item->type = EObjectType::Glider;
    item->parent = root.get();
    auto gliders = getOrderedMap(EObjectType::Glider);
    for (auto &v : gliders)
    {
        item->children.push_back(tmp = v.second->printTree());
        tmp->parent = item.get();
    }
    root->children.push_back(item);

    item = std::make_shared<TreeItem>();
    item->name = "Goods";
    item->type = EObjectType::Good;
    item->parent = root.get();
    auto goods = getOrderedMap(EObjectType::Good);
    for (auto &v : goods)
    {
        item->children.push_back(tmp = v.second->printTree());
        tmp->parent = item.get();
    }
    root->children.push_back(item);

    item = std::make_shared<TreeItem>();
    item->name = "Maps";
    item->type = EObjectType::Map;
    item->parent = root.get();
    auto maps = getOrderedMap(EObjectType::Map);
    for (auto &v : maps)
    {
        item->children.push_back(tmp = v.second->printTree());
        tmp->parent = item.get();
    }
    root->children.push_back(item);

    item = std::make_shared<TreeItem>();
    item->name = "Mechanoids";
    item->type = EObjectType::Mechanoid;
    item->parent = root.get();
    auto mechanoids = getOrderedMap(EObjectType::Mechanoid);
    for (auto &v : mechanoids)
    {
        item->children.push_back(tmp = v.second->printTree());
        tmp->parent = item.get();
    }
    root->children.push_back(item);

    item = std::make_shared<TreeItem>();
    item->name = "Modifications";
    item->type = EObjectType::Modification;
    item->parent = root.get();
    auto modifications = getOrderedMap(EObjectType::Modification);
    for (auto &v : modifications)
    {
        item->children.push_back(tmp = v.second->printTree());
        tmp->parent = item.get();
    }
    root->children.push_back(item);

    item = std::make_shared<TreeItem>();
    item->name = "Modificators";
    item->type = EObjectType::Modificator;
    item->parent = root.get();
    auto modificators = getOrderedMap(EObjectType::Modificator);
    for (auto &v : modificators)
    {
        item->children.push_back(tmp = v.second->printTree());
        tmp->parent = item.get();
    }
    root->children.push_back(item);

    item = std::make_shared<TreeItem>();
    item->name = "Objects";
    item->type = EObjectType::Object;
    item->parent = root.get();
    auto objects = getOrderedMap(EObjectType::Object);
    for (auto &v : objects)
    {
        item->children.push_back(tmp = v.second->printTree());
        tmp->parent = item.get();
    }
    root->children.push_back(item);

    item = std::make_shared<TreeItem>();
    item->name = "Projectiles";
    item->type = EObjectType::Projectile;
    item->parent = root.get();
    auto projectiles = getOrderedMap(EObjectType::Projectile);
    for (auto &v : projectiles)
    {
        item->children.push_back(tmp = v.second->printTree());
        tmp->parent = item.get();
    }
    root->children.push_back(item);

    item = std::make_shared<TreeItem>();
    item->name = "Quests";
    item->type = EObjectType::Quest;
    item->parent = root.get();
    auto quests = getOrderedMap(EObjectType::Quest);
    for (auto &v : quests)
    {
        item->children.push_back(tmp = v.second->printTree());
        tmp->parent = item.get();
    }
    root->children.push_back(item);

    item = std::make_shared<TreeItem>();
    item->name = "Script Variables";
    item->type = EObjectType::ScriptVariable;
    item->parent = root.get();
    auto scriptVariables = getOrderedMap(EObjectType::ScriptVariable);
    for (auto &v : scriptVariables)
    {
        item->children.push_back(tmp = v.second->printTree());
        tmp->parent = item.get();
    }
    root->children.push_back(item);

    item = std::make_shared<TreeItem>();
    item->name = "Settings";
    item->type = EObjectType::Setting;
    item->parent = root.get();
    auto settings = getOrderedMap(EObjectType::Setting);
    for (auto &v : settings)
    {
        item->children.push_back(tmp = v.second->printTree());
        tmp->parent = item.get();
    }
    root->children.push_back(item);

    item = std::make_shared<TreeItem>();
    item->name = "Weapons";
    item->type = EObjectType::Weapon;
    item->parent = root.get();
    auto weapons = getOrderedMap(EObjectType::Weapon);
    for (auto &v : weapons)
    {
        item->children.push_back(tmp = v.second->printTree());
        tmp->parent = item.get();
    }
    root->children.push_back(item);

    return root;
}

Ptr<TreeItem> StorageImpl::addRecord(TreeItem *item)
{
    Ptr<TreeItem> tmp;
    switch (item->type)
    {
    case EObjectType::Building:
        item->children.push_back(tmp = addBuilding()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Clan:
        item->children.push_back(tmp = addClan()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::ClanReputation:
        item->children.push_back(tmp = addClanReputation(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Configuration:
        item->children.push_back(tmp = addConfiguration()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::ConfigurationEquipment:
        item->children.push_back(tmp = addConfigurationEquipment(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::ConfigurationGood:
        item->children.push_back(tmp = addConfigurationGood(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::ConfigurationProjectile:
        item->children.push_back(tmp = addConfigurationProjectile(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::ConfigurationWeapon:
        item->children.push_back(tmp = addConfigurationWeapon(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Equipment:
        item->children.push_back(tmp = addEquipment()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Glider:
        item->children.push_back(tmp = addGlider()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Good:
        item->children.push_back(tmp = addGood()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Group:
        item->children.push_back(tmp = addGroup()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::GroupMechanoid:
        item->children.push_back(tmp = addGroupMechanoid(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Map:
        item->children.push_back(tmp = addMap()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapBuilding:
        item->children.push_back(tmp = addMapBuilding(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapBuildingEquipment:
        item->children.push_back(tmp = addMapBuildingEquipment(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapBuildingGlider:
        item->children.push_back(tmp = addMapBuildingGlider(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapBuildingGood:
        item->children.push_back(tmp = addMapBuildingGood(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapBuildingModificator:
        item->children.push_back(tmp = addMapBuildingModificator(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapBuildingProjectile:
        item->children.push_back(tmp = addMapBuildingProjectile(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapBuildingWeapon:
        item->children.push_back(tmp = addMapBuildingWeapon(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapGood:
        item->children.push_back(tmp = addMapGood(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MapObject:
        item->children.push_back(tmp = addMapObject(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Mechanoid:
        item->children.push_back(tmp = addMechanoid()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::MechanoidQuest:
        item->children.push_back(tmp = addMechanoidQuest(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Modification:
        item->children.push_back(tmp = addModification()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::ModificationMap:
        item->children.push_back(tmp = addModificationMap(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Modificator:
        item->children.push_back(tmp = addModificator()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Object:
        item->children.push_back(tmp = addObject()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Player:
        item->children.push_back(tmp = addPlayer()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Projectile:
        item->children.push_back(tmp = addProjectile()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Quest:
        item->children.push_back(tmp = addQuest()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::QuestReward:
        item->children.push_back(tmp = addQuestReward(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::QuestRewardEquipment:
        item->children.push_back(tmp = addQuestRewardEquipment(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::QuestRewardGlider:
        item->children.push_back(tmp = addQuestRewardGlider(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::QuestRewardGood:
        item->children.push_back(tmp = addQuestRewardGood(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::QuestRewardModificator:
        item->children.push_back(tmp = addQuestRewardModificator(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::QuestRewardProjectile:
        item->children.push_back(tmp = addQuestRewardProjectile(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::QuestRewardReputation:
        item->children.push_back(tmp = addQuestRewardReputation(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::QuestRewardWeapon:
        item->children.push_back(tmp = addQuestRewardWeapon(item->parent->object)->printTree());
        tmp->parent = item;
        break;
    case EObjectType::ScriptVariable:
        item->children.push_back(tmp = addScriptVariable()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Setting:
        item->children.push_back(tmp = addSetting()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::String:
        item->children.push_back(tmp = addString()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Table:
        item->children.push_back(tmp = addTable()->printTree());
        tmp->parent = item;
        break;
    case EObjectType::Weapon:
        item->children.push_back(tmp = addWeapon()->printTree());
        tmp->parent = item;
        break;
    default:
        break;
    }
    return tmp;
}

void StorageImpl::deleteRecord(TreeItem *item)
{
    if (!item || !item->object)
        return;
    switch (item->type)
    {
    case EObjectType::Building:
        deleteBuilding(item->object);
        break;
    case EObjectType::Clan:
        deleteClan(item->object);
        break;
    case EObjectType::ClanReputation:
        deleteClanReputation(item->object);
        break;
    case EObjectType::Configuration:
        deleteConfiguration(item->object);
        break;
    case EObjectType::ConfigurationEquipment:
        deleteConfigurationEquipment(item->object);
        break;
    case EObjectType::ConfigurationGood:
        deleteConfigurationGood(item->object);
        break;
    case EObjectType::ConfigurationProjectile:
        deleteConfigurationProjectile(item->object);
        break;
    case EObjectType::ConfigurationWeapon:
        deleteConfigurationWeapon(item->object);
        break;
    case EObjectType::Equipment:
        deleteEquipment(item->object);
        break;
    case EObjectType::Glider:
        deleteGlider(item->object);
        break;
    case EObjectType::Good:
        deleteGood(item->object);
        break;
    case EObjectType::Group:
        deleteGroup(item->object);
        break;
    case EObjectType::GroupMechanoid:
        deleteGroupMechanoid(item->object);
        break;
    case EObjectType::Map:
        deleteMap(item->object);
        break;
    case EObjectType::MapBuilding:
        deleteMapBuilding(item->object);
        break;
    case EObjectType::MapBuildingEquipment:
        deleteMapBuildingEquipment(item->object);
        break;
    case EObjectType::MapBuildingGlider:
        deleteMapBuildingGlider(item->object);
        break;
    case EObjectType::MapBuildingGood:
        deleteMapBuildingGood(item->object);
        break;
    case EObjectType::MapBuildingModificator:
        deleteMapBuildingModificator(item->object);
        break;
    case EObjectType::MapBuildingProjectile:
        deleteMapBuildingProjectile(item->object);
        break;
    case EObjectType::MapBuildingWeapon:
        deleteMapBuildingWeapon(item->object);
        break;
    case EObjectType::MapGood:
        deleteMapGood(item->object);
        break;
    case EObjectType::MapObject:
        deleteMapObject(item->object);
        break;
    case EObjectType::Mechanoid:
        deleteMechanoid(item->object);
        break;
    case EObjectType::MechanoidQuest:
        deleteMechanoidQuest(item->object);
        break;
    case EObjectType::Modification:
        deleteModification(item->object);
        break;
    case EObjectType::ModificationMap:
        deleteModificationMap(item->object);
        break;
    case EObjectType::Modificator:
        deleteModificator(item->object);
        break;
    case EObjectType::Object:
        deleteObject(item->object);
        break;
    case EObjectType::Player:
        deletePlayer(item->object);
        break;
    case EObjectType::Projectile:
        deleteProjectile(item->object);
        break;
    case EObjectType::Quest:
        deleteQuest(item->object);
        break;
    case EObjectType::QuestReward:
        deleteQuestReward(item->object);
        break;
    case EObjectType::QuestRewardEquipment:
        deleteQuestRewardEquipment(item->object);
        break;
    case EObjectType::QuestRewardGlider:
        deleteQuestRewardGlider(item->object);
        break;
    case EObjectType::QuestRewardGood:
        deleteQuestRewardGood(item->object);
        break;
    case EObjectType::QuestRewardModificator:
        deleteQuestRewardModificator(item->object);
        break;
    case EObjectType::QuestRewardProjectile:
        deleteQuestRewardProjectile(item->object);
        break;
    case EObjectType::QuestRewardReputation:
        deleteQuestRewardReputation(item->object);
        break;
    case EObjectType::QuestRewardWeapon:
        deleteQuestRewardWeapon(item->object);
        break;
    case EObjectType::ScriptVariable:
        deleteScriptVariable(item->object);
        break;
    case EObjectType::Setting:
        deleteSetting(item->object);
        break;
    case EObjectType::String:
        deleteString(item->object);
        break;
    case EObjectType::Table:
        deleteTable(item->object);
        break;
    case EObjectType::Weapon:
        deleteWeapon(item->object);
        break;
    default:
        break;
    }
}

OrderedObjectMap StorageImpl::getOrderedMap(EObjectType type, std::function<bool(IObjectBase *)> f) const
{
    switch (type)
    {
    case EObjectType::Building:
        return ::getOrderedMap(buildings, f);
    case EObjectType::Clan:
        return ::getOrderedMap(clans, f);
    case EObjectType::ClanReputation:
        return ::getOrderedMap(clanReputations, f);
    case EObjectType::Configuration:
        return ::getOrderedMap(configurations, f);
    case EObjectType::ConfigurationEquipment:
        return ::getOrderedMap(configurationEquipments, f);
    case EObjectType::ConfigurationGood:
        return ::getOrderedMap(configurationGoods, f);
    case EObjectType::ConfigurationProjectile:
        return ::getOrderedMap(configurationProjectiles, f);
    case EObjectType::ConfigurationWeapon:
        return ::getOrderedMap(configurationWeapons, f);
    case EObjectType::Equipment:
        return ::getOrderedMap(equipments, f);
    case EObjectType::Glider:
        return ::getOrderedMap(gliders, f);
    case EObjectType::Good:
        return ::getOrderedMap(goods, f);
    case EObjectType::Group:
        return ::getOrderedMap(groups, f);
    case EObjectType::GroupMechanoid:
        return ::getOrderedMap(groupMechanoids, f);
    case EObjectType::Map:
        return ::getOrderedMap(maps, f);
    case EObjectType::MapBuilding:
        return ::getOrderedMap(mapBuildings, f);
    case EObjectType::MapBuildingEquipment:
        return ::getOrderedMap(mapBuildingEquipments, f);
    case EObjectType::MapBuildingGlider:
        return ::getOrderedMap(mapBuildingGliders, f);
    case EObjectType::MapBuildingGood:
        return ::getOrderedMap(mapBuildingGoods, f);
    case EObjectType::MapBuildingModificator:
        return ::getOrderedMap(mapBuildingModificators, f);
    case EObjectType::MapBuildingProjectile:
        return ::getOrderedMap(mapBuildingProjectiles, f);
    case EObjectType::MapBuildingWeapon:
        return ::getOrderedMap(mapBuildingWeapons, f);
    case EObjectType::MapGood:
        return ::getOrderedMap(mapGoods, f);
    case EObjectType::MapObject:
        return ::getOrderedMap(mapObjects, f);
    case EObjectType::Mechanoid:
        return ::getOrderedMap(mechanoids, f);
    case EObjectType::MechanoidQuest:
        return ::getOrderedMap(mechanoidQuests, f);
    case EObjectType::Modification:
        return ::getOrderedMap(modifications, f);
    case EObjectType::ModificationMap:
        return ::getOrderedMap(modificationMaps, f);
    case EObjectType::Modificator:
        return ::getOrderedMap(modificators, f);
    case EObjectType::Object:
        return ::getOrderedMap(objects, f);
    case EObjectType::Player:
        return ::getOrderedMap(players, f);
    case EObjectType::Projectile:
        return ::getOrderedMap(projectiles, f);
    case EObjectType::Quest:
        return ::getOrderedMap(quests, f);
    case EObjectType::QuestReward:
        return ::getOrderedMap(questRewards, f);
    case EObjectType::QuestRewardEquipment:
        return ::getOrderedMap(questRewardEquipments, f);
    case EObjectType::QuestRewardGlider:
        return ::getOrderedMap(questRewardGliders, f);
    case EObjectType::QuestRewardGood:
        return ::getOrderedMap(questRewardGoods, f);
    case EObjectType::QuestRewardModificator:
        return ::getOrderedMap(questRewardModificators, f);
    case EObjectType::QuestRewardProjectile:
        return ::getOrderedMap(questRewardProjectiles, f);
    case EObjectType::QuestRewardReputation:
        return ::getOrderedMap(questRewardReputations, f);
    case EObjectType::QuestRewardWeapon:
        return ::getOrderedMap(questRewardWeapons, f);
    case EObjectType::ScriptVariable:
        return ::getOrderedMap(scriptVariables, f);
    case EObjectType::Setting:
        return ::getOrderedMap(settings, f);
    case EObjectType::String:
        return ::getOrderedMap(strings, f);
    case EObjectType::Table:
        return ::getOrderedMap(tables, f);
    case EObjectType::Weapon:
        return ::getOrderedMap(weapons, f);
    default:
        return OrderedObjectMap();
    }
}

