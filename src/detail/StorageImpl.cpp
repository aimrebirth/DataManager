/* DO NOT EDIT! This is an autogenerated file. */

void StorageImpl::_loadBuildings()
{
    int ret = 0;
    const std::string query = "select * from Buildings;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = buildings.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->scale = (float)sqlite3_column_double(stmt, 3);
        v->scale_x = (float)sqlite3_column_double(stmt, 4);
        v->scale_y = (float)sqlite3_column_double(stmt, 5);
        v->scale_z = (float)sqlite3_column_double(stmt, 6);
        buildings.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadBuildingsPtrs()
{
}

void StorageImpl::_loadBuildingsArrays()
{
}

void StorageImpl::_saveBuildings() const
{
    db->execute("BEGIN;");
    db->execute("delete from Buildings;");
    const std::string query = "insert into Buildings values (?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &building : buildings)
    {
        auto &v = building.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, v->resource.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_double(stmt, 4, v->scale);
        ret = sqlite3_bind_double(stmt, 5, v->scale_x);
        ret = sqlite3_bind_double(stmt, 6, v->scale_y);
        ret = sqlite3_bind_double(stmt, 7, v->scale_z);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadClanMechanoids()
{
    int ret = 0;
    const std::string query = "select * from ClanMechanoids;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = clanMechanoids.create();
        v->clan.id = sqlite3_column_int(stmt, 0);
        v->mechanoid.id = sqlite3_column_int(stmt, 1);
        clanMechanoids.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadClanMechanoidsPtrs()
{
    for (auto &clanMechanoid : clanMechanoids)
    {
        if (clans.find(clanMechanoid->clan.id) != clans.end())
            clanMechanoid->clan.ptr = clans[clanMechanoid->clan.id];
        if (mechanoids.find(clanMechanoid->mechanoid.id) != mechanoids.end())
            clanMechanoid->mechanoid.ptr = mechanoids[clanMechanoid->mechanoid.id];
    }
}

void StorageImpl::_loadClanMechanoidsArrays()
{
}

void StorageImpl::_saveClanMechanoids() const
{
    db->execute("BEGIN;");
    db->execute("delete from ClanMechanoids;");
    const std::string query = "insert into ClanMechanoids values (?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &clanMechanoid : clanMechanoids)
    {
        auto &v = clanMechanoid;
        ret = sqlite3_bind_int(stmt, 1, v->clan.id);
        ret = sqlite3_bind_int(stmt, 2, v->mechanoid.id);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadClanReputations()
{
    int ret = 0;
    const std::string query = "select * from ClanReputations;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = clanReputations.create();
        v->clan.id = sqlite3_column_int(stmt, 0);
        v->clan2.id = sqlite3_column_int(stmt, 1);
        v->reputation = (float)sqlite3_column_double(stmt, 2);
        clanReputations.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadClanReputationsPtrs()
{
    for (auto &clanReputation : clanReputations)
    {
        if (clans.find(clanReputation->clan.id) != clans.end())
            clanReputation->clan.ptr = clans[clanReputation->clan.id];
        if (clans.find(clanReputation->clan2.id) != clans.end())
            clanReputation->clan2.ptr = clans[clanReputation->clan2.id];
    }
}

void StorageImpl::_loadClanReputationsArrays()
{
}

void StorageImpl::_saveClanReputations() const
{
    db->execute("BEGIN;");
    db->execute("delete from ClanReputations;");
    const std::string query = "insert into ClanReputations values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &clanReputation : clanReputations)
    {
        auto &v = clanReputation;
        ret = sqlite3_bind_int(stmt, 1, v->clan.id);
        ret = sqlite3_bind_int(stmt, 2, v->clan2.id);
        ret = sqlite3_bind_double(stmt, 3, v->reputation);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadClans()
{
    int ret = 0;
    const std::string query = "select * from Clans;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = clans.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name.id = sqlite3_column_int(stmt, 3);
        v->member_name.id = sqlite3_column_int(stmt, 4);
        v->bonusexp = sqlite3_column_int(stmt, 5);
        v->bonusrepair = sqlite3_column_int(stmt, 6);
        v->bonustrade = sqlite3_column_int(stmt, 7);
        v->helpness = sqlite3_column_int(stmt, 8);
        v->Volatile = (float)sqlite3_column_double(stmt, 9);
        v->noblivion = (float)sqlite3_column_double(stmt, 10);
        v->playereffect = (float)sqlite3_column_double(stmt, 11);
        v->color = sqlite3_column_int(stmt, 12);
        clans.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadClansPtrs()
{
    for (auto &clan : clans)
    {
        if (strings.find(clan.second->name.id) != strings.end())
            clan.second->name.ptr = strings[clan.second->name.id];
        if (strings.find(clan.second->member_name.id) != strings.end())
            clan.second->member_name.ptr = strings[clan.second->member_name.id];
    }
}

void StorageImpl::_loadClansArrays()
{
    for (auto &clan : clans)
    {
        for (auto &clanMechanoid : clanMechanoids)
            if (clan.first == clanMechanoid->clan.id)
                clan->mechanoids.insert(clanMechanoid);
        for (auto &clanReputation : clanReputations)
            if (clan.first == clanReputation->clan.id)
                clan->reputations.insert(clanReputation);
    }
}

void StorageImpl::_saveClans() const
{
    db->execute("BEGIN;");
    db->execute("delete from Clans;");
    const std::string query = "insert into Clans values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &clan : clans)
    {
        auto &v = clan.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, v->resource.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->name.id);
        ret = sqlite3_bind_int(stmt, 5, v->member_name.id);
        ret = sqlite3_bind_int(stmt, 6, v->bonusexp);
        ret = sqlite3_bind_int(stmt, 7, v->bonusrepair);
        ret = sqlite3_bind_int(stmt, 8, v->bonustrade);
        ret = sqlite3_bind_int(stmt, 9, v->helpness);
        ret = sqlite3_bind_double(stmt, 10, v->Volatile);
        ret = sqlite3_bind_double(stmt, 11, v->noblivion);
        ret = sqlite3_bind_double(stmt, 12, v->playereffect);
        ret = sqlite3_bind_int(stmt, 13, v->color);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadConfigurationEquipments()
{
    int ret = 0;
    const std::string query = "select * from ConfigurationEquipments;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = configurationEquipments.create();
        v->configuration.id = sqlite3_column_int(stmt, 0);
        v->equipment.id = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        configurationEquipments.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadConfigurationEquipmentsPtrs()
{
    for (auto &configurationEquipment : configurationEquipments)
    {
        if (configurations.find(configurationEquipment->configuration.id) != configurations.end())
            configurationEquipment->configuration.ptr = configurations[configurationEquipment->configuration.id];
        if (equipments.find(configurationEquipment->equipment.id) != equipments.end())
            configurationEquipment->equipment.ptr = equipments[configurationEquipment->equipment.id];
    }
}

void StorageImpl::_loadConfigurationEquipmentsArrays()
{
}

void StorageImpl::_saveConfigurationEquipments() const
{
    db->execute("BEGIN;");
    db->execute("delete from ConfigurationEquipments;");
    const std::string query = "insert into ConfigurationEquipments values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &configurationEquipment : configurationEquipments)
    {
        auto &v = configurationEquipment;
        ret = sqlite3_bind_int(stmt, 1, v->configuration.id);
        ret = sqlite3_bind_int(stmt, 2, v->equipment.id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadConfigurationGoods()
{
    int ret = 0;
    const std::string query = "select * from ConfigurationGoods;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = configurationGoods.create();
        v->configuration.id = sqlite3_column_int(stmt, 0);
        v->good.id = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        configurationGoods.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadConfigurationGoodsPtrs()
{
    for (auto &configurationGood : configurationGoods)
    {
        if (configurations.find(configurationGood->configuration.id) != configurations.end())
            configurationGood->configuration.ptr = configurations[configurationGood->configuration.id];
        if (goods.find(configurationGood->good.id) != goods.end())
            configurationGood->good.ptr = goods[configurationGood->good.id];
    }
}

void StorageImpl::_loadConfigurationGoodsArrays()
{
}

void StorageImpl::_saveConfigurationGoods() const
{
    db->execute("BEGIN;");
    db->execute("delete from ConfigurationGoods;");
    const std::string query = "insert into ConfigurationGoods values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &configurationGood : configurationGoods)
    {
        auto &v = configurationGood;
        ret = sqlite3_bind_int(stmt, 1, v->configuration.id);
        ret = sqlite3_bind_int(stmt, 2, v->good.id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadConfigurationProjectiles()
{
    int ret = 0;
    const std::string query = "select * from ConfigurationProjectiles;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = configurationProjectiles.create();
        v->configuration.id = sqlite3_column_int(stmt, 0);
        v->projectile.id = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        configurationProjectiles.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadConfigurationProjectilesPtrs()
{
    for (auto &configurationProjectile : configurationProjectiles)
    {
        if (configurations.find(configurationProjectile->configuration.id) != configurations.end())
            configurationProjectile->configuration.ptr = configurations[configurationProjectile->configuration.id];
        if (projectiles.find(configurationProjectile->projectile.id) != projectiles.end())
            configurationProjectile->projectile.ptr = projectiles[configurationProjectile->projectile.id];
    }
}

void StorageImpl::_loadConfigurationProjectilesArrays()
{
}

void StorageImpl::_saveConfigurationProjectiles() const
{
    db->execute("BEGIN;");
    db->execute("delete from ConfigurationProjectiles;");
    const std::string query = "insert into ConfigurationProjectiles values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &configurationProjectile : configurationProjectiles)
    {
        auto &v = configurationProjectile;
        ret = sqlite3_bind_int(stmt, 1, v->configuration.id);
        ret = sqlite3_bind_int(stmt, 2, v->projectile.id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadConfigurationWeapons()
{
    int ret = 0;
    const std::string query = "select * from ConfigurationWeapons;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = configurationWeapons.create();
        v->configuration.id = sqlite3_column_int(stmt, 0);
        v->weapon.id = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        configurationWeapons.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadConfigurationWeaponsPtrs()
{
    for (auto &configurationWeapon : configurationWeapons)
    {
        if (configurations.find(configurationWeapon->configuration.id) != configurations.end())
            configurationWeapon->configuration.ptr = configurations[configurationWeapon->configuration.id];
        if (weapons.find(configurationWeapon->weapon.id) != weapons.end())
            configurationWeapon->weapon.ptr = weapons[configurationWeapon->weapon.id];
    }
}

void StorageImpl::_loadConfigurationWeaponsArrays()
{
}

void StorageImpl::_saveConfigurationWeapons() const
{
    db->execute("BEGIN;");
    db->execute("delete from ConfigurationWeapons;");
    const std::string query = "insert into ConfigurationWeapons values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &configurationWeapon : configurationWeapons)
    {
        auto &v = configurationWeapon;
        ret = sqlite3_bind_int(stmt, 1, v->configuration.id);
        ret = sqlite3_bind_int(stmt, 2, v->weapon.id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadConfigurations()
{
    int ret = 0;
    const std::string query = "select * from Configurations;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = configurations.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->name.id = sqlite3_column_int(stmt, 2);
        v->glider.id = sqlite3_column_int(stmt, 3);
        configurations.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadConfigurationsPtrs()
{
    for (auto &configuration : configurations)
    {
        if (strings.find(configuration.second->name.id) != strings.end())
            configuration.second->name.ptr = strings[configuration.second->name.id];
        if (gliders.find(configuration.second->glider.id) != gliders.end())
            configuration.second->glider.ptr = gliders[configuration.second->glider.id];
    }
}

void StorageImpl::_loadConfigurationsArrays()
{
    for (auto &configuration : configurations)
    {
        for (auto &configurationEquipment : configurationEquipments)
            if (configuration.first == configurationEquipment->configuration.id)
                configuration->equipments.insert(configurationEquipment);
        for (auto &configurationGood : configurationGoods)
            if (configuration.first == configurationGood->configuration.id)
                configuration->goods.insert(configurationGood);
        for (auto &configurationProjectile : configurationProjectiles)
            if (configuration.first == configurationProjectile->configuration.id)
                configuration->projectiles.insert(configurationProjectile);
        for (auto &configurationWeapon : configurationWeapons)
            if (configuration.first == configurationWeapon->configuration.id)
                configuration->weapons.insert(configurationWeapon);
    }
}

void StorageImpl::_saveConfigurations() const
{
    db->execute("BEGIN;");
    db->execute("delete from Configurations;");
    const std::string query = "insert into Configurations values (?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &configuration : configurations)
    {
        auto &v = configuration.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->name.id);
        ret = sqlite3_bind_int(stmt, 4, v->glider.id);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadEquipments()
{
    int ret = 0;
    const std::string query = "select * from Equipments;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = equipments.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name.id = sqlite3_column_int(stmt, 3);
        v->type = sqlite3_column_int(stmt, 4);
        v->standard = sqlite3_column_int(stmt, 5);
        v->weight = (float)sqlite3_column_double(stmt, 6);
        v->durability = (float)sqlite3_column_double(stmt, 7);
        v->power = (float)sqlite3_column_double(stmt, 8);
        v->value1 = (float)sqlite3_column_double(stmt, 9);
        v->value2 = (float)sqlite3_column_double(stmt, 10);
        v->value3 = (float)sqlite3_column_double(stmt, 11);
        v->manual = sqlite3_column_int(stmt, 12);
        v->price = (float)sqlite3_column_double(stmt, 13);
        v->notrade = sqlite3_column_int(stmt, 14);
        equipments.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadEquipmentsPtrs()
{
    for (auto &equipment : equipments)
    {
        if (strings.find(equipment.second->name.id) != strings.end())
            equipment.second->name.ptr = strings[equipment.second->name.id];
    }
}

void StorageImpl::_loadEquipmentsArrays()
{
}

void StorageImpl::_saveEquipments() const
{
    db->execute("BEGIN;");
    db->execute("delete from Equipments;");
    const std::string query = "insert into Equipments values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &equipment : equipments)
    {
        auto &v = equipment.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, v->resource.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->name.id);
        ret = sqlite3_bind_int(stmt, 5, v->type);
        ret = sqlite3_bind_int(stmt, 6, v->standard);
        ret = sqlite3_bind_double(stmt, 7, v->weight);
        ret = sqlite3_bind_double(stmt, 8, v->durability);
        ret = sqlite3_bind_double(stmt, 9, v->power);
        ret = sqlite3_bind_double(stmt, 10, v->value1);
        ret = sqlite3_bind_double(stmt, 11, v->value2);
        ret = sqlite3_bind_double(stmt, 12, v->value3);
        ret = sqlite3_bind_int(stmt, 13, v->manual);
        ret = sqlite3_bind_double(stmt, 14, v->price);
        ret = sqlite3_bind_int(stmt, 15, v->notrade);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadGliders()
{
    int ret = 0;
    const std::string query = "select * from Gliders;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = gliders.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name.id = sqlite3_column_int(stmt, 3);
        v->standard = sqlite3_column_int(stmt, 4);
        v->weight = (float)sqlite3_column_double(stmt, 5);
        v->maxweight = (float)sqlite3_column_double(stmt, 6);
        v->armor = (float)sqlite3_column_double(stmt, 7);
        v->price = sqlite3_column_int(stmt, 8);
        v->restore = (float)sqlite3_column_double(stmt, 9);
        v->power = (float)sqlite3_column_double(stmt, 10);
        v->special = sqlite3_column_int(stmt, 11);
        v->rotatespeed = (float)sqlite3_column_double(stmt, 12);
        v->resfront = (float)sqlite3_column_double(stmt, 13);
        v->restop = (float)sqlite3_column_double(stmt, 14);
        v->resside = (float)sqlite3_column_double(stmt, 15);
        v->stabfront = (float)sqlite3_column_double(stmt, 16);
        v->stabside = (float)sqlite3_column_double(stmt, 17);
        v->careen = (float)sqlite3_column_double(stmt, 18);
        v->delta_t = (float)sqlite3_column_double(stmt, 19);
        v->turbulence = (float)sqlite3_column_double(stmt, 20);
        gliders.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadGlidersPtrs()
{
    for (auto &glider : gliders)
    {
        if (strings.find(glider.second->name.id) != strings.end())
            glider.second->name.ptr = strings[glider.second->name.id];
    }
}

void StorageImpl::_loadGlidersArrays()
{
}

void StorageImpl::_saveGliders() const
{
    db->execute("BEGIN;");
    db->execute("delete from Gliders;");
    const std::string query = "insert into Gliders values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &glider : gliders)
    {
        auto &v = glider.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, v->resource.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->name.id);
        ret = sqlite3_bind_int(stmt, 5, v->standard);
        ret = sqlite3_bind_double(stmt, 6, v->weight);
        ret = sqlite3_bind_double(stmt, 7, v->maxweight);
        ret = sqlite3_bind_double(stmt, 8, v->armor);
        ret = sqlite3_bind_int(stmt, 9, v->price);
        ret = sqlite3_bind_double(stmt, 10, v->restore);
        ret = sqlite3_bind_double(stmt, 11, v->power);
        ret = sqlite3_bind_int(stmt, 12, v->special);
        ret = sqlite3_bind_double(stmt, 13, v->rotatespeed);
        ret = sqlite3_bind_double(stmt, 14, v->resfront);
        ret = sqlite3_bind_double(stmt, 15, v->restop);
        ret = sqlite3_bind_double(stmt, 16, v->resside);
        ret = sqlite3_bind_double(stmt, 17, v->stabfront);
        ret = sqlite3_bind_double(stmt, 18, v->stabside);
        ret = sqlite3_bind_double(stmt, 19, v->careen);
        ret = sqlite3_bind_double(stmt, 20, v->delta_t);
        ret = sqlite3_bind_double(stmt, 21, v->turbulence);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadGoods()
{
    int ret = 0;
    const std::string query = "select * from Goods;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = goods.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->resource_drop = (const char *)sqlite3_column_text(stmt, 3);
        v->name.id = sqlite3_column_int(stmt, 4);
        v->price = sqlite3_column_int(stmt, 5);
        v->weight = (float)sqlite3_column_double(stmt, 6);
        v->notrade = sqlite3_column_int(stmt, 7);
        v->type = sqlite3_column_int(stmt, 8);
        goods.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadGoodsPtrs()
{
    for (auto &good : goods)
    {
        if (strings.find(good.second->name.id) != strings.end())
            good.second->name.ptr = strings[good.second->name.id];
    }
}

void StorageImpl::_loadGoodsArrays()
{
}

void StorageImpl::_saveGoods() const
{
    db->execute("BEGIN;");
    db->execute("delete from Goods;");
    const std::string query = "insert into Goods values (?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &good : goods)
    {
        auto &v = good.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, v->resource.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 4, v->resource_drop.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 5, v->name.id);
        ret = sqlite3_bind_int(stmt, 6, v->price);
        ret = sqlite3_bind_double(stmt, 7, v->weight);
        ret = sqlite3_bind_int(stmt, 8, v->notrade);
        ret = sqlite3_bind_int(stmt, 9, v->type);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadGroupMechanoids()
{
    int ret = 0;
    const std::string query = "select * from GroupMechanoids;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = groupMechanoids.create();
        v->group.id = sqlite3_column_int(stmt, 0);
        v->mechanoid.id = sqlite3_column_int(stmt, 1);
        groupMechanoids.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadGroupMechanoidsPtrs()
{
    for (auto &groupMechanoid : groupMechanoids)
    {
        if (groups.find(groupMechanoid->group.id) != groups.end())
            groupMechanoid->group.ptr = groups[groupMechanoid->group.id];
        if (mechanoids.find(groupMechanoid->mechanoid.id) != mechanoids.end())
            groupMechanoid->mechanoid.ptr = mechanoids[groupMechanoid->mechanoid.id];
    }
}

void StorageImpl::_loadGroupMechanoidsArrays()
{
}

void StorageImpl::_saveGroupMechanoids() const
{
    db->execute("BEGIN;");
    db->execute("delete from GroupMechanoids;");
    const std::string query = "insert into GroupMechanoids values (?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &groupMechanoid : groupMechanoids)
    {
        auto &v = groupMechanoid;
        ret = sqlite3_bind_int(stmt, 1, v->group.id);
        ret = sqlite3_bind_int(stmt, 2, v->mechanoid.id);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadGroups()
{
    int ret = 0;
    const std::string query = "select * from Groups;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = groups.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->name.id = sqlite3_column_int(stmt, 2);
        groups.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadGroupsPtrs()
{
    for (auto &group : groups)
    {
        if (strings.find(group.second->name.id) != strings.end())
            group.second->name.ptr = strings[group.second->name.id];
    }
}

void StorageImpl::_loadGroupsArrays()
{
    for (auto &group : groups)
    {
        for (auto &groupMechanoid : groupMechanoids)
            if (group.first == groupMechanoid->group.id)
                group->mechanoids.insert(groupMechanoid);
    }
}

void StorageImpl::_saveGroups() const
{
    db->execute("BEGIN;");
    db->execute("delete from Groups;");
    const std::string query = "insert into Groups values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &group : groups)
    {
        auto &v = group.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->name.id);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingEquipments()
{
    int ret = 0;
    const std::string query = "select * from MapBuildingEquipments;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingEquipments.create();
        v->mapBuilding.id = sqlite3_column_int(stmt, 0);
        v->equipment.id = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingEquipments.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingEquipmentsPtrs()
{
    for (auto &mapBuildingEquipment : mapBuildingEquipments)
    {
        if (mapBuildings.find(mapBuildingEquipment->mapBuilding.id) != mapBuildings.end())
            mapBuildingEquipment->mapBuilding.ptr = mapBuildings[mapBuildingEquipment->mapBuilding.id];
        if (equipments.find(mapBuildingEquipment->equipment.id) != equipments.end())
            mapBuildingEquipment->equipment.ptr = equipments[mapBuildingEquipment->equipment.id];
    }
}

void StorageImpl::_loadMapBuildingEquipmentsArrays()
{
}

void StorageImpl::_saveMapBuildingEquipments() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingEquipments;");
    const std::string query = "insert into MapBuildingEquipments values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingEquipment : mapBuildingEquipments)
    {
        auto &v = mapBuildingEquipment;
        ret = sqlite3_bind_int(stmt, 1, v->mapBuilding.id);
        ret = sqlite3_bind_int(stmt, 2, v->equipment.id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingGliders()
{
    int ret = 0;
    const std::string query = "select * from MapBuildingGliders;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingGliders.create();
        v->mapBuilding.id = sqlite3_column_int(stmt, 0);
        v->glider.id = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingGliders.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingGlidersPtrs()
{
    for (auto &mapBuildingGlider : mapBuildingGliders)
    {
        if (mapBuildings.find(mapBuildingGlider->mapBuilding.id) != mapBuildings.end())
            mapBuildingGlider->mapBuilding.ptr = mapBuildings[mapBuildingGlider->mapBuilding.id];
        if (gliders.find(mapBuildingGlider->glider.id) != gliders.end())
            mapBuildingGlider->glider.ptr = gliders[mapBuildingGlider->glider.id];
    }
}

void StorageImpl::_loadMapBuildingGlidersArrays()
{
}

void StorageImpl::_saveMapBuildingGliders() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingGliders;");
    const std::string query = "insert into MapBuildingGliders values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingGlider : mapBuildingGliders)
    {
        auto &v = mapBuildingGlider;
        ret = sqlite3_bind_int(stmt, 1, v->mapBuilding.id);
        ret = sqlite3_bind_int(stmt, 2, v->glider.id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingGoods()
{
    int ret = 0;
    const std::string query = "select * from MapBuildingGoods;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingGoods.create();
        v->mapBuilding.id = sqlite3_column_int(stmt, 0);
        v->good.id = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingGoods.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingGoodsPtrs()
{
    for (auto &mapBuildingGood : mapBuildingGoods)
    {
        if (mapBuildings.find(mapBuildingGood->mapBuilding.id) != mapBuildings.end())
            mapBuildingGood->mapBuilding.ptr = mapBuildings[mapBuildingGood->mapBuilding.id];
        if (goods.find(mapBuildingGood->good.id) != goods.end())
            mapBuildingGood->good.ptr = goods[mapBuildingGood->good.id];
    }
}

void StorageImpl::_loadMapBuildingGoodsArrays()
{
}

void StorageImpl::_saveMapBuildingGoods() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingGoods;");
    const std::string query = "insert into MapBuildingGoods values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingGood : mapBuildingGoods)
    {
        auto &v = mapBuildingGood;
        ret = sqlite3_bind_int(stmt, 1, v->mapBuilding.id);
        ret = sqlite3_bind_int(stmt, 2, v->good.id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingModificators()
{
    int ret = 0;
    const std::string query = "select * from MapBuildingModificators;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingModificators.create();
        v->mapBuilding.id = sqlite3_column_int(stmt, 0);
        v->modificator.id = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingModificators.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingModificatorsPtrs()
{
    for (auto &mapBuildingModificator : mapBuildingModificators)
    {
        if (mapBuildings.find(mapBuildingModificator->mapBuilding.id) != mapBuildings.end())
            mapBuildingModificator->mapBuilding.ptr = mapBuildings[mapBuildingModificator->mapBuilding.id];
        if (modificators.find(mapBuildingModificator->modificator.id) != modificators.end())
            mapBuildingModificator->modificator.ptr = modificators[mapBuildingModificator->modificator.id];
    }
}

void StorageImpl::_loadMapBuildingModificatorsArrays()
{
}

void StorageImpl::_saveMapBuildingModificators() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingModificators;");
    const std::string query = "insert into MapBuildingModificators values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingModificator : mapBuildingModificators)
    {
        auto &v = mapBuildingModificator;
        ret = sqlite3_bind_int(stmt, 1, v->mapBuilding.id);
        ret = sqlite3_bind_int(stmt, 2, v->modificator.id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingProjectiles()
{
    int ret = 0;
    const std::string query = "select * from MapBuildingProjectiles;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingProjectiles.create();
        v->mapBuilding.id = sqlite3_column_int(stmt, 0);
        v->projectile.id = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingProjectiles.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingProjectilesPtrs()
{
    for (auto &mapBuildingProjectile : mapBuildingProjectiles)
    {
        if (mapBuildings.find(mapBuildingProjectile->mapBuilding.id) != mapBuildings.end())
            mapBuildingProjectile->mapBuilding.ptr = mapBuildings[mapBuildingProjectile->mapBuilding.id];
        if (projectiles.find(mapBuildingProjectile->projectile.id) != projectiles.end())
            mapBuildingProjectile->projectile.ptr = projectiles[mapBuildingProjectile->projectile.id];
    }
}

void StorageImpl::_loadMapBuildingProjectilesArrays()
{
}

void StorageImpl::_saveMapBuildingProjectiles() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingProjectiles;");
    const std::string query = "insert into MapBuildingProjectiles values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingProjectile : mapBuildingProjectiles)
    {
        auto &v = mapBuildingProjectile;
        ret = sqlite3_bind_int(stmt, 1, v->mapBuilding.id);
        ret = sqlite3_bind_int(stmt, 2, v->projectile.id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildingWeapons()
{
    int ret = 0;
    const std::string query = "select * from MapBuildingWeapons;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildingWeapons.create();
        v->mapBuilding.id = sqlite3_column_int(stmt, 0);
        v->weapon.id = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        mapBuildingWeapons.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingWeaponsPtrs()
{
    for (auto &mapBuildingWeapon : mapBuildingWeapons)
    {
        if (mapBuildings.find(mapBuildingWeapon->mapBuilding.id) != mapBuildings.end())
            mapBuildingWeapon->mapBuilding.ptr = mapBuildings[mapBuildingWeapon->mapBuilding.id];
        if (weapons.find(mapBuildingWeapon->weapon.id) != weapons.end())
            mapBuildingWeapon->weapon.ptr = weapons[mapBuildingWeapon->weapon.id];
    }
}

void StorageImpl::_loadMapBuildingWeaponsArrays()
{
}

void StorageImpl::_saveMapBuildingWeapons() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildingWeapons;");
    const std::string query = "insert into MapBuildingWeapons values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuildingWeapon : mapBuildingWeapons)
    {
        auto &v = mapBuildingWeapon;
        ret = sqlite3_bind_int(stmt, 1, v->mapBuilding.id);
        ret = sqlite3_bind_int(stmt, 2, v->weapon.id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapBuildings()
{
    int ret = 0;
    const std::string query = "select * from MapBuildings;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapBuildings.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->map.id = sqlite3_column_int(stmt, 2);
        v->building.id = sqlite3_column_int(stmt, 3);
        v->name.id = sqlite3_column_int(stmt, 4);
        v->interactive = sqlite3_column_int(stmt, 5);
        v->x = (float)sqlite3_column_double(stmt, 6);
        v->y = (float)sqlite3_column_double(stmt, 7);
        v->z = (float)sqlite3_column_double(stmt, 8);
        v->roll = (float)sqlite3_column_double(stmt, 9);
        v->pitch = (float)sqlite3_column_double(stmt, 10);
        v->yaw = (float)sqlite3_column_double(stmt, 11);
        v->scale = (float)sqlite3_column_double(stmt, 12);
        v->scale_x = (float)sqlite3_column_double(stmt, 13);
        v->scale_y = (float)sqlite3_column_double(stmt, 14);
        v->scale_z = (float)sqlite3_column_double(stmt, 15);
        mapBuildings.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapBuildingsPtrs()
{
    for (auto &mapBuilding : mapBuildings)
    {
        if (maps.find(mapBuilding.second->map.id) != maps.end())
            mapBuilding.second->map.ptr = maps[mapBuilding.second->map.id];
        if (buildings.find(mapBuilding.second->building.id) != buildings.end())
            mapBuilding.second->building.ptr = buildings[mapBuilding.second->building.id];
        if (strings.find(mapBuilding.second->name.id) != strings.end())
            mapBuilding.second->name.ptr = strings[mapBuilding.second->name.id];
    }
}

void StorageImpl::_loadMapBuildingsArrays()
{
    for (auto &mapBuilding : mapBuildings)
    {
        for (auto &mapBuildingEquipment : mapBuildingEquipments)
            if (mapBuilding.first == mapBuildingEquipment->mapBuilding.id)
                mapBuilding->equipments.insert(mapBuildingEquipment);
        for (auto &mapBuildingGlider : mapBuildingGliders)
            if (mapBuilding.first == mapBuildingGlider->mapBuilding.id)
                mapBuilding->gliders.insert(mapBuildingGlider);
        for (auto &mapBuildingGood : mapBuildingGoods)
            if (mapBuilding.first == mapBuildingGood->mapBuilding.id)
                mapBuilding->goods.insert(mapBuildingGood);
        for (auto &mapBuildingModificator : mapBuildingModificators)
            if (mapBuilding.first == mapBuildingModificator->mapBuilding.id)
                mapBuilding->modificators.insert(mapBuildingModificator);
        for (auto &mapBuildingProjectile : mapBuildingProjectiles)
            if (mapBuilding.first == mapBuildingProjectile->mapBuilding.id)
                mapBuilding->projectiles.insert(mapBuildingProjectile);
        for (auto &mapBuildingWeapon : mapBuildingWeapons)
            if (mapBuilding.first == mapBuildingWeapon->mapBuilding.id)
                mapBuilding->weapons.insert(mapBuildingWeapon);
    }
}

void StorageImpl::_saveMapBuildings() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapBuildings;");
    const std::string query = "insert into MapBuildings values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapBuilding : mapBuildings)
    {
        auto &v = mapBuilding.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->map.id);
        ret = sqlite3_bind_int(stmt, 4, v->building.id);
        ret = sqlite3_bind_int(stmt, 5, v->name.id);
        ret = sqlite3_bind_int(stmt, 6, v->interactive);
        ret = sqlite3_bind_double(stmt, 7, v->x);
        ret = sqlite3_bind_double(stmt, 8, v->y);
        ret = sqlite3_bind_double(stmt, 9, v->z);
        ret = sqlite3_bind_double(stmt, 10, v->roll);
        ret = sqlite3_bind_double(stmt, 11, v->pitch);
        ret = sqlite3_bind_double(stmt, 12, v->yaw);
        ret = sqlite3_bind_double(stmt, 13, v->scale);
        ret = sqlite3_bind_double(stmt, 14, v->scale_x);
        ret = sqlite3_bind_double(stmt, 15, v->scale_y);
        ret = sqlite3_bind_double(stmt, 16, v->scale_z);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapGoods()
{
    int ret = 0;
    const std::string query = "select * from MapGoods;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapGoods.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = sqlite3_column_int(stmt, 1);
        v->map.id = sqlite3_column_int(stmt, 2);
        v->good.id = sqlite3_column_int(stmt, 3);
        v->x = (float)sqlite3_column_double(stmt, 4);
        v->y = (float)sqlite3_column_double(stmt, 5);
        v->z = (float)sqlite3_column_double(stmt, 6);
        v->roll = (float)sqlite3_column_double(stmt, 7);
        v->pitch = (float)sqlite3_column_double(stmt, 8);
        v->yaw = (float)sqlite3_column_double(stmt, 9);
        v->scale = (float)sqlite3_column_double(stmt, 10);
        v->scale_x = (float)sqlite3_column_double(stmt, 11);
        v->scale_y = (float)sqlite3_column_double(stmt, 12);
        v->scale_z = (float)sqlite3_column_double(stmt, 13);
        mapGoods.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapGoodsPtrs()
{
    for (auto &mapGood : mapGoods)
    {
        if (maps.find(mapGood.second->map.id) != maps.end())
            mapGood.second->map.ptr = maps[mapGood.second->map.id];
        if (goods.find(mapGood.second->good.id) != goods.end())
            mapGood.second->good.ptr = goods[mapGood.second->good.id];
    }
}

void StorageImpl::_loadMapGoodsArrays()
{
}

void StorageImpl::_saveMapGoods() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapGoods;");
    const std::string query = "insert into MapGoods values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapGood : mapGoods)
    {
        auto &v = mapGood.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_int(stmt, 2, v->text_id);
        ret = sqlite3_bind_int(stmt, 3, v->map.id);
        ret = sqlite3_bind_int(stmt, 4, v->good.id);
        ret = sqlite3_bind_double(stmt, 5, v->x);
        ret = sqlite3_bind_double(stmt, 6, v->y);
        ret = sqlite3_bind_double(stmt, 7, v->z);
        ret = sqlite3_bind_double(stmt, 8, v->roll);
        ret = sqlite3_bind_double(stmt, 9, v->pitch);
        ret = sqlite3_bind_double(stmt, 10, v->yaw);
        ret = sqlite3_bind_double(stmt, 11, v->scale);
        ret = sqlite3_bind_double(stmt, 12, v->scale_x);
        ret = sqlite3_bind_double(stmt, 13, v->scale_y);
        ret = sqlite3_bind_double(stmt, 14, v->scale_z);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMapObjects()
{
    int ret = 0;
    const std::string query = "select * from MapObjects;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mapObjects.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->map.id = sqlite3_column_int(stmt, 2);
        v->object.id = sqlite3_column_int(stmt, 3);
        v->x = (float)sqlite3_column_double(stmt, 4);
        v->y = (float)sqlite3_column_double(stmt, 5);
        v->z = (float)sqlite3_column_double(stmt, 6);
        v->roll = (float)sqlite3_column_double(stmt, 7);
        v->pitch = (float)sqlite3_column_double(stmt, 8);
        v->yaw = (float)sqlite3_column_double(stmt, 9);
        v->scale = (float)sqlite3_column_double(stmt, 10);
        v->scale_x = (float)sqlite3_column_double(stmt, 11);
        v->scale_y = (float)sqlite3_column_double(stmt, 12);
        v->scale_z = (float)sqlite3_column_double(stmt, 13);
        mapObjects.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapObjectsPtrs()
{
    for (auto &mapObject : mapObjects)
    {
        if (maps.find(mapObject.second->map.id) != maps.end())
            mapObject.second->map.ptr = maps[mapObject.second->map.id];
        if (objects.find(mapObject.second->object.id) != objects.end())
            mapObject.second->object.ptr = objects[mapObject.second->object.id];
    }
}

void StorageImpl::_loadMapObjectsArrays()
{
}

void StorageImpl::_saveMapObjects() const
{
    db->execute("BEGIN;");
    db->execute("delete from MapObjects;");
    const std::string query = "insert into MapObjects values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mapObject : mapObjects)
    {
        auto &v = mapObject.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->map.id);
        ret = sqlite3_bind_int(stmt, 4, v->object.id);
        ret = sqlite3_bind_double(stmt, 5, v->x);
        ret = sqlite3_bind_double(stmt, 6, v->y);
        ret = sqlite3_bind_double(stmt, 7, v->z);
        ret = sqlite3_bind_double(stmt, 8, v->roll);
        ret = sqlite3_bind_double(stmt, 9, v->pitch);
        ret = sqlite3_bind_double(stmt, 10, v->yaw);
        ret = sqlite3_bind_double(stmt, 11, v->scale);
        ret = sqlite3_bind_double(stmt, 12, v->scale_x);
        ret = sqlite3_bind_double(stmt, 13, v->scale_y);
        ret = sqlite3_bind_double(stmt, 14, v->scale_z);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMaps()
{
    int ret = 0;
    const std::string query = "select * from Maps;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = maps.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name.id = sqlite3_column_int(stmt, 3);
        v->h_min = (float)sqlite3_column_double(stmt, 4);
        v->h_max = (float)sqlite3_column_double(stmt, 5);
        v->kx = (float)sqlite3_column_double(stmt, 6);
        v->bx = (float)sqlite3_column_double(stmt, 7);
        v->ky = (float)sqlite3_column_double(stmt, 8);
        v->by = (float)sqlite3_column_double(stmt, 9);
        maps.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMapsPtrs()
{
    for (auto &map : maps)
    {
        if (strings.find(map.second->name.id) != strings.end())
            map.second->name.ptr = strings[map.second->name.id];
    }
}

void StorageImpl::_loadMapsArrays()
{
    for (auto &map : maps)
    {
        for (auto &mapBuilding : mapBuildings)
            if (map.first == mapBuilding->map.id)
                map->buildings.insert(mapBuilding);
        for (auto &mapGood : mapGoods)
            if (map.first == mapGood->map.id)
                map->goods.insert(mapGood);
        for (auto &mapObject : mapObjects)
            if (map.first == mapObject->map.id)
                map->objects.insert(mapObject);
    }
}

void StorageImpl::_saveMaps() const
{
    db->execute("BEGIN;");
    db->execute("delete from Maps;");
    const std::string query = "insert into Maps values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &map : maps)
    {
        auto &v = map.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, v->resource.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->name.id);
        ret = sqlite3_bind_double(stmt, 5, v->h_min);
        ret = sqlite3_bind_double(stmt, 6, v->h_max);
        ret = sqlite3_bind_double(stmt, 7, v->kx);
        ret = sqlite3_bind_double(stmt, 8, v->bx);
        ret = sqlite3_bind_double(stmt, 9, v->ky);
        ret = sqlite3_bind_double(stmt, 10, v->by);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMechanoidQuests()
{
    int ret = 0;
    const std::string query = "select * from MechanoidQuests;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mechanoidQuests.create();
        v->mechanoid.id = sqlite3_column_int(stmt, 0);
        v->quest.id = sqlite3_column_int(stmt, 1);
        v->state = sqlite3_column_int(stmt, 2);
        mechanoidQuests.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMechanoidQuestsPtrs()
{
    for (auto &mechanoidQuest : mechanoidQuests)
    {
        if (mechanoids.find(mechanoidQuest->mechanoid.id) != mechanoids.end())
            mechanoidQuest->mechanoid.ptr = mechanoids[mechanoidQuest->mechanoid.id];
        if (quests.find(mechanoidQuest->quest.id) != quests.end())
            mechanoidQuest->quest.ptr = quests[mechanoidQuest->quest.id];
    }
}

void StorageImpl::_loadMechanoidQuestsArrays()
{
}

void StorageImpl::_saveMechanoidQuests() const
{
    db->execute("BEGIN;");
    db->execute("delete from MechanoidQuests;");
    const std::string query = "insert into MechanoidQuests values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mechanoidQuest : mechanoidQuests)
    {
        auto &v = mechanoidQuest;
        ret = sqlite3_bind_int(stmt, 1, v->mechanoid.id);
        ret = sqlite3_bind_int(stmt, 2, v->quest.id);
        ret = sqlite3_bind_int(stmt, 3, v->state);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadMechanoids()
{
    int ret = 0;
    const std::string query = "select * from Mechanoids;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = mechanoids.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->name.id = sqlite3_column_int(stmt, 2);
        v->generation = sqlite3_column_int(stmt, 3);
        v->rating = (float)sqlite3_column_double(stmt, 4);
        v->money = (float)sqlite3_column_double(stmt, 5);
        v->configuration.id = sqlite3_column_int(stmt, 6);
        v->group.id = sqlite3_column_int(stmt, 7);
        v->clan.id = sqlite3_column_int(stmt, 8);
        v->rating_fight = (float)sqlite3_column_double(stmt, 9);
        v->rating_courier = (float)sqlite3_column_double(stmt, 10);
        v->rating_trade = (float)sqlite3_column_double(stmt, 11);
        v->map.id = sqlite3_column_int(stmt, 12);
        v->mapBuilding.id = sqlite3_column_int(stmt, 13);
        v->x = (float)sqlite3_column_double(stmt, 14);
        v->y = (float)sqlite3_column_double(stmt, 15);
        v->z = (float)sqlite3_column_double(stmt, 16);
        v->roll = (float)sqlite3_column_double(stmt, 17);
        v->pitch = (float)sqlite3_column_double(stmt, 18);
        v->yaw = (float)sqlite3_column_double(stmt, 19);
        mechanoids.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadMechanoidsPtrs()
{
    for (auto &mechanoid : mechanoids)
    {
        if (strings.find(mechanoid.second->name.id) != strings.end())
            mechanoid.second->name.ptr = strings[mechanoid.second->name.id];
        if (configurations.find(mechanoid.second->configuration.id) != configurations.end())
            mechanoid.second->configuration.ptr = configurations[mechanoid.second->configuration.id];
        if (groups.find(mechanoid.second->group.id) != groups.end())
            mechanoid.second->group.ptr = groups[mechanoid.second->group.id];
        if (clans.find(mechanoid.second->clan.id) != clans.end())
            mechanoid.second->clan.ptr = clans[mechanoid.second->clan.id];
        if (maps.find(mechanoid.second->map.id) != maps.end())
            mechanoid.second->map.ptr = maps[mechanoid.second->map.id];
        if (mapBuildings.find(mechanoid.second->mapBuilding.id) != mapBuildings.end())
            mechanoid.second->mapBuilding.ptr = mapBuildings[mechanoid.second->mapBuilding.id];
    }
}

void StorageImpl::_loadMechanoidsArrays()
{
    for (auto &mechanoid : mechanoids)
    {
        for (auto &mechanoidQuest : mechanoidQuests)
            if (mechanoid.first == mechanoidQuest->mechanoid.id)
                mechanoid->quests.insert(mechanoidQuest);
    }
}

void StorageImpl::_saveMechanoids() const
{
    db->execute("BEGIN;");
    db->execute("delete from Mechanoids;");
    const std::string query = "insert into Mechanoids values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &mechanoid : mechanoids)
    {
        auto &v = mechanoid.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->name.id);
        ret = sqlite3_bind_int(stmt, 4, v->generation);
        ret = sqlite3_bind_double(stmt, 5, v->rating);
        ret = sqlite3_bind_double(stmt, 6, v->money);
        ret = sqlite3_bind_int(stmt, 7, v->configuration.id);
        ret = sqlite3_bind_int(stmt, 8, v->group.id);
        ret = sqlite3_bind_int(stmt, 9, v->clan.id);
        ret = sqlite3_bind_double(stmt, 10, v->rating_fight);
        ret = sqlite3_bind_double(stmt, 11, v->rating_courier);
        ret = sqlite3_bind_double(stmt, 12, v->rating_trade);
        ret = sqlite3_bind_int(stmt, 13, v->map.id);
        ret = sqlite3_bind_int(stmt, 14, v->mapBuilding.id);
        ret = sqlite3_bind_double(stmt, 15, v->x);
        ret = sqlite3_bind_double(stmt, 16, v->y);
        ret = sqlite3_bind_double(stmt, 17, v->z);
        ret = sqlite3_bind_double(stmt, 18, v->roll);
        ret = sqlite3_bind_double(stmt, 19, v->pitch);
        ret = sqlite3_bind_double(stmt, 20, v->yaw);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadModificationClans()
{
    int ret = 0;
    const std::string query = "select * from ModificationClans;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = modificationClans.create();
        v->modification.id = sqlite3_column_int(stmt, 0);
        v->clan.id = sqlite3_column_int(stmt, 1);
        modificationClans.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadModificationClansPtrs()
{
    for (auto &modificationClan : modificationClans)
    {
        if (modifications.find(modificationClan->modification.id) != modifications.end())
            modificationClan->modification.ptr = modifications[modificationClan->modification.id];
        if (clans.find(modificationClan->clan.id) != clans.end())
            modificationClan->clan.ptr = clans[modificationClan->clan.id];
    }
}

void StorageImpl::_loadModificationClansArrays()
{
}

void StorageImpl::_saveModificationClans() const
{
    db->execute("BEGIN;");
    db->execute("delete from ModificationClans;");
    const std::string query = "insert into ModificationClans values (?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &modificationClan : modificationClans)
    {
        auto &v = modificationClan;
        ret = sqlite3_bind_int(stmt, 1, v->modification.id);
        ret = sqlite3_bind_int(stmt, 2, v->clan.id);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadModificationMaps()
{
    int ret = 0;
    const std::string query = "select * from ModificationMaps;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = modificationMaps.create();
        v->modification.id = sqlite3_column_int(stmt, 0);
        v->map.id = sqlite3_column_int(stmt, 1);
        modificationMaps.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadModificationMapsPtrs()
{
    for (auto &modificationMap : modificationMaps)
    {
        if (modifications.find(modificationMap->modification.id) != modifications.end())
            modificationMap->modification.ptr = modifications[modificationMap->modification.id];
        if (maps.find(modificationMap->map.id) != maps.end())
            modificationMap->map.ptr = maps[modificationMap->map.id];
    }
}

void StorageImpl::_loadModificationMapsArrays()
{
}

void StorageImpl::_saveModificationMaps() const
{
    db->execute("BEGIN;");
    db->execute("delete from ModificationMaps;");
    const std::string query = "insert into ModificationMaps values (?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &modificationMap : modificationMaps)
    {
        auto &v = modificationMap;
        ret = sqlite3_bind_int(stmt, 1, v->modification.id);
        ret = sqlite3_bind_int(stmt, 2, v->map.id);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadModificationMechanoids()
{
    int ret = 0;
    const std::string query = "select * from ModificationMechanoids;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = modificationMechanoids.create();
        v->modification.id = sqlite3_column_int(stmt, 0);
        v->mechanoid.id = sqlite3_column_int(stmt, 1);
        modificationMechanoids.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadModificationMechanoidsPtrs()
{
    for (auto &modificationMechanoid : modificationMechanoids)
    {
        if (modifications.find(modificationMechanoid->modification.id) != modifications.end())
            modificationMechanoid->modification.ptr = modifications[modificationMechanoid->modification.id];
        if (mechanoids.find(modificationMechanoid->mechanoid.id) != mechanoids.end())
            modificationMechanoid->mechanoid.ptr = mechanoids[modificationMechanoid->mechanoid.id];
    }
}

void StorageImpl::_loadModificationMechanoidsArrays()
{
}

void StorageImpl::_saveModificationMechanoids() const
{
    db->execute("BEGIN;");
    db->execute("delete from ModificationMechanoids;");
    const std::string query = "insert into ModificationMechanoids values (?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &modificationMechanoid : modificationMechanoids)
    {
        auto &v = modificationMechanoid;
        ret = sqlite3_bind_int(stmt, 1, v->modification.id);
        ret = sqlite3_bind_int(stmt, 2, v->mechanoid.id);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadModifications()
{
    int ret = 0;
    const std::string query = "select * from Modifications;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = modifications.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->name.id = sqlite3_column_int(stmt, 1);
        v->directory = (const char *)sqlite3_column_text(stmt, 2);
        v->author = (const char *)sqlite3_column_text(stmt, 3);
        v->date_created = (const char *)sqlite3_column_text(stmt, 4);
        v->date_modified = (const char *)sqlite3_column_text(stmt, 5);
        v->comment = (const char *)sqlite3_column_text(stmt, 6);
        v->version = (const char *)sqlite3_column_text(stmt, 7);
        v->script_language = (const char *)sqlite3_column_text(stmt, 8);
        v->script_main = (const char *)sqlite3_column_text(stmt, 9);
        v->player_mechanoid.id = sqlite3_column_int(stmt, 10);
        v->cooperative_player_configuration.id = sqlite3_column_int(stmt, 11);
        modifications.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadModificationsPtrs()
{
    for (auto &modification : modifications)
    {
        if (strings.find(modification.second->name.id) != strings.end())
            modification.second->name.ptr = strings[modification.second->name.id];
        if (mechanoids.find(modification.second->player_mechanoid.id) != mechanoids.end())
            modification.second->player_mechanoid.ptr = mechanoids[modification.second->player_mechanoid.id];
        if (configurations.find(modification.second->cooperative_player_configuration.id) != configurations.end())
            modification.second->cooperative_player_configuration.ptr = configurations[modification.second->cooperative_player_configuration.id];
    }
}

void StorageImpl::_loadModificationsArrays()
{
    for (auto &modification : modifications)
    {
        for (auto &modificationClan : modificationClans)
            if (modification.first == modificationClan->modification.id)
                modification->clans.insert(modificationClan);
        for (auto &modificationMap : modificationMaps)
            if (modification.first == modificationMap->modification.id)
                modification->maps.insert(modificationMap);
        for (auto &modificationMechanoid : modificationMechanoids)
            if (modification.first == modificationMechanoid->modification.id)
                modification->mechanoids.insert(modificationMechanoid);
    }
}

void StorageImpl::_saveModifications() const
{
    db->execute("BEGIN;");
    db->execute("delete from Modifications;");
    const std::string query = "insert into Modifications values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &modification : modifications)
    {
        auto &v = modification.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_int(stmt, 2, v->name.id);
        ret = sqlite3_bind_text(stmt, 3, v->directory.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 4, v->author.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 5, v->date_created.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 6, v->date_modified.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 7, v->comment.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 8, v->version.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 9, v->script_language.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 10, v->script_main.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 11, v->player_mechanoid.id);
        ret = sqlite3_bind_int(stmt, 12, v->cooperative_player_configuration.id);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadModificators()
{
    int ret = 0;
    const std::string query = "select * from Modificators;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = modificators.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name.id = sqlite3_column_int(stmt, 3);
        v->probability = (float)sqlite3_column_double(stmt, 4);
        v->price = (float)sqlite3_column_double(stmt, 5);
        v->k_price = (float)sqlite3_column_double(stmt, 6);
        v->k_param1 = (float)sqlite3_column_double(stmt, 7);
        v->k_param2 = (float)sqlite3_column_double(stmt, 8);
        v->unicum_id = sqlite3_column_int(stmt, 9);
        v->mask = sqlite3_column_int(stmt, 10);
        modificators.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadModificatorsPtrs()
{
    for (auto &modificator : modificators)
    {
        if (strings.find(modificator.second->name.id) != strings.end())
            modificator.second->name.ptr = strings[modificator.second->name.id];
    }
}

void StorageImpl::_loadModificatorsArrays()
{
}

void StorageImpl::_saveModificators() const
{
    db->execute("BEGIN;");
    db->execute("delete from Modificators;");
    const std::string query = "insert into Modificators values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &modificator : modificators)
    {
        auto &v = modificator.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, v->resource.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->name.id);
        ret = sqlite3_bind_double(stmt, 5, v->probability);
        ret = sqlite3_bind_double(stmt, 6, v->price);
        ret = sqlite3_bind_double(stmt, 7, v->k_price);
        ret = sqlite3_bind_double(stmt, 8, v->k_param1);
        ret = sqlite3_bind_double(stmt, 9, v->k_param2);
        ret = sqlite3_bind_int(stmt, 10, v->unicum_id);
        ret = sqlite3_bind_int(stmt, 11, v->mask);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadObjects()
{
    int ret = 0;
    const std::string query = "select * from Objects;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = objects.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name.id = sqlite3_column_int(stmt, 3);
        v->type = sqlite3_column_int(stmt, 4);
        v->scale = (float)sqlite3_column_double(stmt, 5);
        v->scale_x = (float)sqlite3_column_double(stmt, 6);
        v->scale_y = (float)sqlite3_column_double(stmt, 7);
        v->scale_z = (float)sqlite3_column_double(stmt, 8);
        objects.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadObjectsPtrs()
{
    for (auto &object : objects)
    {
        if (strings.find(object.second->name.id) != strings.end())
            object.second->name.ptr = strings[object.second->name.id];
    }
}

void StorageImpl::_loadObjectsArrays()
{
}

void StorageImpl::_saveObjects() const
{
    db->execute("BEGIN;");
    db->execute("delete from Objects;");
    const std::string query = "insert into Objects values (?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &object : objects)
    {
        auto &v = object.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, v->resource.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->name.id);
        ret = sqlite3_bind_int(stmt, 5, v->type);
        ret = sqlite3_bind_double(stmt, 6, v->scale);
        ret = sqlite3_bind_double(stmt, 7, v->scale_x);
        ret = sqlite3_bind_double(stmt, 8, v->scale_y);
        ret = sqlite3_bind_double(stmt, 9, v->scale_z);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadPlayers()
{
    int ret = 0;
    const std::string query = "select * from Players;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = players.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->mechanoid.id = sqlite3_column_int(stmt, 1);
        players.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadPlayersPtrs()
{
    for (auto &player : players)
    {
        if (mechanoids.find(player.second->mechanoid.id) != mechanoids.end())
            player.second->mechanoid.ptr = mechanoids[player.second->mechanoid.id];
    }
}

void StorageImpl::_loadPlayersArrays()
{
}

void StorageImpl::_savePlayers() const
{
    db->execute("BEGIN;");
    db->execute("delete from Players;");
    const std::string query = "insert into Players values (?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &player : players)
    {
        auto &v = player.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_int(stmt, 2, v->mechanoid.id);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadProjectiles()
{
    int ret = 0;
    const std::string query = "select * from Projectiles;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = projectiles.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name.id = sqlite3_column_int(stmt, 3);
        v->type = sqlite3_column_int(stmt, 4);
        v->weight = (float)sqlite3_column_double(stmt, 5);
        v->damage = (float)sqlite3_column_double(stmt, 6);
        v->T = (const char *)sqlite3_column_text(stmt, 7);
        v->speed = (float)sqlite3_column_double(stmt, 8);
        v->scale = (float)sqlite3_column_double(stmt, 9);
        v->numstate = sqlite3_column_int(stmt, 10);
        v->rotate = (float)sqlite3_column_double(stmt, 11);
        v->subtype = sqlite3_column_int(stmt, 12);
        v->life_time = (float)sqlite3_column_double(stmt, 13);
        v->detonation_delay = (float)sqlite3_column_double(stmt, 14);
        v->distance_detonation = (float)sqlite3_column_double(stmt, 15);
        v->strength = (float)sqlite3_column_double(stmt, 16);
        v->price = (float)sqlite3_column_double(stmt, 17);
        v->notrade = sqlite3_column_int(stmt, 18);
        projectiles.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadProjectilesPtrs()
{
    for (auto &projectile : projectiles)
    {
        if (strings.find(projectile.second->name.id) != strings.end())
            projectile.second->name.ptr = strings[projectile.second->name.id];
    }
}

void StorageImpl::_loadProjectilesArrays()
{
}

void StorageImpl::_saveProjectiles() const
{
    db->execute("BEGIN;");
    db->execute("delete from Projectiles;");
    const std::string query = "insert into Projectiles values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &projectile : projectiles)
    {
        auto &v = projectile.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, v->resource.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->name.id);
        ret = sqlite3_bind_int(stmt, 5, v->type);
        ret = sqlite3_bind_double(stmt, 6, v->weight);
        ret = sqlite3_bind_double(stmt, 7, v->damage);
        ret = sqlite3_bind_text(stmt, 8, v->T.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_double(stmt, 9, v->speed);
        ret = sqlite3_bind_double(stmt, 10, v->scale);
        ret = sqlite3_bind_int(stmt, 11, v->numstate);
        ret = sqlite3_bind_double(stmt, 12, v->rotate);
        ret = sqlite3_bind_int(stmt, 13, v->subtype);
        ret = sqlite3_bind_double(stmt, 14, v->life_time);
        ret = sqlite3_bind_double(stmt, 15, v->detonation_delay);
        ret = sqlite3_bind_double(stmt, 16, v->distance_detonation);
        ret = sqlite3_bind_double(stmt, 17, v->strength);
        ret = sqlite3_bind_double(stmt, 18, v->price);
        ret = sqlite3_bind_int(stmt, 19, v->notrade);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardEquipments()
{
    int ret = 0;
    const std::string query = "select * from QuestRewardEquipments;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardEquipments.create();
        v->questReward.id = sqlite3_column_int(stmt, 0);
        v->equipment.id = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardEquipments.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardEquipmentsPtrs()
{
    for (auto &questRewardEquipment : questRewardEquipments)
    {
        if (questRewards.find(questRewardEquipment->questReward.id) != questRewards.end())
            questRewardEquipment->questReward.ptr = questRewards[questRewardEquipment->questReward.id];
        if (equipments.find(questRewardEquipment->equipment.id) != equipments.end())
            questRewardEquipment->equipment.ptr = equipments[questRewardEquipment->equipment.id];
    }
}

void StorageImpl::_loadQuestRewardEquipmentsArrays()
{
}

void StorageImpl::_saveQuestRewardEquipments() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardEquipments;");
    const std::string query = "insert into QuestRewardEquipments values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardEquipment : questRewardEquipments)
    {
        auto &v = questRewardEquipment;
        ret = sqlite3_bind_int(stmt, 1, v->questReward.id);
        ret = sqlite3_bind_int(stmt, 2, v->equipment.id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardGliders()
{
    int ret = 0;
    const std::string query = "select * from QuestRewardGliders;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardGliders.create();
        v->questReward.id = sqlite3_column_int(stmt, 0);
        v->glider.id = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardGliders.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardGlidersPtrs()
{
    for (auto &questRewardGlider : questRewardGliders)
    {
        if (questRewards.find(questRewardGlider->questReward.id) != questRewards.end())
            questRewardGlider->questReward.ptr = questRewards[questRewardGlider->questReward.id];
        if (gliders.find(questRewardGlider->glider.id) != gliders.end())
            questRewardGlider->glider.ptr = gliders[questRewardGlider->glider.id];
    }
}

void StorageImpl::_loadQuestRewardGlidersArrays()
{
}

void StorageImpl::_saveQuestRewardGliders() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardGliders;");
    const std::string query = "insert into QuestRewardGliders values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardGlider : questRewardGliders)
    {
        auto &v = questRewardGlider;
        ret = sqlite3_bind_int(stmt, 1, v->questReward.id);
        ret = sqlite3_bind_int(stmt, 2, v->glider.id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardGoods()
{
    int ret = 0;
    const std::string query = "select * from QuestRewardGoods;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardGoods.create();
        v->questReward.id = sqlite3_column_int(stmt, 0);
        v->good.id = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardGoods.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardGoodsPtrs()
{
    for (auto &questRewardGood : questRewardGoods)
    {
        if (questRewards.find(questRewardGood->questReward.id) != questRewards.end())
            questRewardGood->questReward.ptr = questRewards[questRewardGood->questReward.id];
        if (goods.find(questRewardGood->good.id) != goods.end())
            questRewardGood->good.ptr = goods[questRewardGood->good.id];
    }
}

void StorageImpl::_loadQuestRewardGoodsArrays()
{
}

void StorageImpl::_saveQuestRewardGoods() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardGoods;");
    const std::string query = "insert into QuestRewardGoods values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardGood : questRewardGoods)
    {
        auto &v = questRewardGood;
        ret = sqlite3_bind_int(stmt, 1, v->questReward.id);
        ret = sqlite3_bind_int(stmt, 2, v->good.id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardModificators()
{
    int ret = 0;
    const std::string query = "select * from QuestRewardModificators;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardModificators.create();
        v->questReward.id = sqlite3_column_int(stmt, 0);
        v->modificator.id = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardModificators.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardModificatorsPtrs()
{
    for (auto &questRewardModificator : questRewardModificators)
    {
        if (questRewards.find(questRewardModificator->questReward.id) != questRewards.end())
            questRewardModificator->questReward.ptr = questRewards[questRewardModificator->questReward.id];
        if (modificators.find(questRewardModificator->modificator.id) != modificators.end())
            questRewardModificator->modificator.ptr = modificators[questRewardModificator->modificator.id];
    }
}

void StorageImpl::_loadQuestRewardModificatorsArrays()
{
}

void StorageImpl::_saveQuestRewardModificators() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardModificators;");
    const std::string query = "insert into QuestRewardModificators values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardModificator : questRewardModificators)
    {
        auto &v = questRewardModificator;
        ret = sqlite3_bind_int(stmt, 1, v->questReward.id);
        ret = sqlite3_bind_int(stmt, 2, v->modificator.id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardProjectiles()
{
    int ret = 0;
    const std::string query = "select * from QuestRewardProjectiles;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardProjectiles.create();
        v->questReward.id = sqlite3_column_int(stmt, 0);
        v->projectile.id = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardProjectiles.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardProjectilesPtrs()
{
    for (auto &questRewardProjectile : questRewardProjectiles)
    {
        if (questRewards.find(questRewardProjectile->questReward.id) != questRewards.end())
            questRewardProjectile->questReward.ptr = questRewards[questRewardProjectile->questReward.id];
        if (projectiles.find(questRewardProjectile->projectile.id) != projectiles.end())
            questRewardProjectile->projectile.ptr = projectiles[questRewardProjectile->projectile.id];
    }
}

void StorageImpl::_loadQuestRewardProjectilesArrays()
{
}

void StorageImpl::_saveQuestRewardProjectiles() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardProjectiles;");
    const std::string query = "insert into QuestRewardProjectiles values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardProjectile : questRewardProjectiles)
    {
        auto &v = questRewardProjectile;
        ret = sqlite3_bind_int(stmt, 1, v->questReward.id);
        ret = sqlite3_bind_int(stmt, 2, v->projectile.id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardReputations()
{
    int ret = 0;
    const std::string query = "select * from QuestRewardReputations;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardReputations.create();
        v->questReward.id = sqlite3_column_int(stmt, 0);
        v->clan.id = sqlite3_column_int(stmt, 1);
        v->reputation = (float)sqlite3_column_double(stmt, 2);
        questRewardReputations.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardReputationsPtrs()
{
    for (auto &questRewardReputation : questRewardReputations)
    {
        if (questRewards.find(questRewardReputation->questReward.id) != questRewards.end())
            questRewardReputation->questReward.ptr = questRewards[questRewardReputation->questReward.id];
        if (clans.find(questRewardReputation->clan.id) != clans.end())
            questRewardReputation->clan.ptr = clans[questRewardReputation->clan.id];
    }
}

void StorageImpl::_loadQuestRewardReputationsArrays()
{
}

void StorageImpl::_saveQuestRewardReputations() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardReputations;");
    const std::string query = "insert into QuestRewardReputations values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardReputation : questRewardReputations)
    {
        auto &v = questRewardReputation;
        ret = sqlite3_bind_int(stmt, 1, v->questReward.id);
        ret = sqlite3_bind_int(stmt, 2, v->clan.id);
        ret = sqlite3_bind_double(stmt, 3, v->reputation);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewardWeapons()
{
    int ret = 0;
    const std::string query = "select * from QuestRewardWeapons;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewardWeapons.create();
        v->questReward.id = sqlite3_column_int(stmt, 0);
        v->weapon.id = sqlite3_column_int(stmt, 1);
        v->quantity = sqlite3_column_int(stmt, 2);
        questRewardWeapons.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardWeaponsPtrs()
{
    for (auto &questRewardWeapon : questRewardWeapons)
    {
        if (questRewards.find(questRewardWeapon->questReward.id) != questRewards.end())
            questRewardWeapon->questReward.ptr = questRewards[questRewardWeapon->questReward.id];
        if (weapons.find(questRewardWeapon->weapon.id) != weapons.end())
            questRewardWeapon->weapon.ptr = weapons[questRewardWeapon->weapon.id];
    }
}

void StorageImpl::_loadQuestRewardWeaponsArrays()
{
}

void StorageImpl::_saveQuestRewardWeapons() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewardWeapons;");
    const std::string query = "insert into QuestRewardWeapons values (?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questRewardWeapon : questRewardWeapons)
    {
        auto &v = questRewardWeapon;
        ret = sqlite3_bind_int(stmt, 1, v->questReward.id);
        ret = sqlite3_bind_int(stmt, 2, v->weapon.id);
        ret = sqlite3_bind_int(stmt, 3, v->quantity);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuestRewards()
{
    int ret = 0;
    const std::string query = "select * from QuestRewards;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = questRewards.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->quest.id = sqlite3_column_int(stmt, 1);
        v->text_id = (const char *)sqlite3_column_text(stmt, 2);
        v->money = sqlite3_column_int(stmt, 3);
        v->rating = (float)sqlite3_column_double(stmt, 4);
        questRewards.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestRewardsPtrs()
{
    for (auto &questReward : questRewards)
    {
        if (quests.find(questReward.second->quest.id) != quests.end())
            questReward.second->quest.ptr = quests[questReward.second->quest.id];
    }
}

void StorageImpl::_loadQuestRewardsArrays()
{
    for (auto &questReward : questRewards)
    {
        for (auto &questRewardEquipment : questRewardEquipments)
            if (questReward.first == questRewardEquipment->questReward.id)
                questReward->equipments.insert(questRewardEquipment);
        for (auto &questRewardGlider : questRewardGliders)
            if (questReward.first == questRewardGlider->questReward.id)
                questReward->gliders.insert(questRewardGlider);
        for (auto &questRewardGood : questRewardGoods)
            if (questReward.first == questRewardGood->questReward.id)
                questReward->goods.insert(questRewardGood);
        for (auto &questRewardModificator : questRewardModificators)
            if (questReward.first == questRewardModificator->questReward.id)
                questReward->modificators.insert(questRewardModificator);
        for (auto &questRewardProjectile : questRewardProjectiles)
            if (questReward.first == questRewardProjectile->questReward.id)
                questReward->projectiles.insert(questRewardProjectile);
        for (auto &questRewardReputation : questRewardReputations)
            if (questReward.first == questRewardReputation->questReward.id)
                questReward->reputations.insert(questRewardReputation);
        for (auto &questRewardWeapon : questRewardWeapons)
            if (questReward.first == questRewardWeapon->questReward.id)
                questReward->weapons.insert(questRewardWeapon);
    }
}

void StorageImpl::_saveQuestRewards() const
{
    db->execute("BEGIN;");
    db->execute("delete from QuestRewards;");
    const std::string query = "insert into QuestRewards values (?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &questReward : questRewards)
    {
        auto &v = questReward.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_int(stmt, 2, v->quest.id);
        ret = sqlite3_bind_text(stmt, 3, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->money);
        ret = sqlite3_bind_double(stmt, 5, v->rating);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadQuests()
{
    int ret = 0;
    const std::string query = "select * from Quests;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = quests.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->name.id = sqlite3_column_int(stmt, 2);
        v->title.id = sqlite3_column_int(stmt, 3);
        v->description.id = sqlite3_column_int(stmt, 4);
        v->time = sqlite3_column_int(stmt, 5);
        quests.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadQuestsPtrs()
{
    for (auto &quest : quests)
    {
        if (strings.find(quest.second->name.id) != strings.end())
            quest.second->name.ptr = strings[quest.second->name.id];
        if (strings.find(quest.second->title.id) != strings.end())
            quest.second->title.ptr = strings[quest.second->title.id];
        if (strings.find(quest.second->description.id) != strings.end())
            quest.second->description.ptr = strings[quest.second->description.id];
    }
}

void StorageImpl::_loadQuestsArrays()
{
    for (auto &quest : quests)
    {
        for (auto &questReward : questRewards)
            if (quest.first == questReward->quest.id)
                quest->rewards.insert(questReward);
    }
}

void StorageImpl::_saveQuests() const
{
    db->execute("BEGIN;");
    db->execute("delete from Quests;");
    const std::string query = "insert into Quests values (?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &quest : quests)
    {
        auto &v = quest.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->name.id);
        ret = sqlite3_bind_int(stmt, 4, v->title.id);
        ret = sqlite3_bind_int(stmt, 5, v->description.id);
        ret = sqlite3_bind_int(stmt, 6, v->time);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadScriptVariables()
{
    int ret = 0;
    const std::string query = "select * from ScriptVariables;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = scriptVariables.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->variable = (const char *)sqlite3_column_text(stmt, 1);
        v->value_int = sqlite3_column_int(stmt, 2);
        v->value_float = (float)sqlite3_column_double(stmt, 3);
        v->value_text = (const char *)sqlite3_column_text(stmt, 4);
        scriptVariables.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadScriptVariablesPtrs()
{
}

void StorageImpl::_loadScriptVariablesArrays()
{
}

void StorageImpl::_saveScriptVariables() const
{
    db->execute("BEGIN;");
    db->execute("delete from ScriptVariables;");
    const std::string query = "insert into ScriptVariables values (?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &scriptVariable : scriptVariables)
    {
        auto &v = scriptVariable.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->variable.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->value_int);
        ret = sqlite3_bind_double(stmt, 4, v->value_float);
        ret = sqlite3_bind_text(stmt, 5, v->value_text.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadSettings()
{
    int ret = 0;
    const std::string query = "select * from Settings;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = settings.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->player.id = sqlite3_column_int(stmt, 1);
        v->value_int = sqlite3_column_int(stmt, 2);
        v->value_float = (float)sqlite3_column_double(stmt, 3);
        v->value_text = (const char *)sqlite3_column_text(stmt, 4);
        v->value_blob = Blob(sqlite3_column_blob(stmt, 5), sqlite3_column_bytes(stmt, 5));
        settings.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadSettingsPtrs()
{
    for (auto &setting : settings)
    {
        if (players.find(setting.second->player.id) != players.end())
            setting.second->player.ptr = players[setting.second->player.id];
    }
}

void StorageImpl::_loadSettingsArrays()
{
}

void StorageImpl::_saveSettings() const
{
    db->execute("BEGIN;");
    db->execute("delete from Settings;");
    const std::string query = "insert into Settings values (?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &setting : settings)
    {
        auto &v = setting.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_int(stmt, 2, v->player.id);
        ret = sqlite3_bind_int(stmt, 3, v->value_int);
        ret = sqlite3_bind_double(stmt, 4, v->value_float);
        ret = sqlite3_bind_text(stmt, 5, v->value_text.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_blob(stmt, 6, v->value_blob.getRawData(), v->value_blob.getLength(), SQLITE_TRANSIENT);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadStrings()
{
    int ret = 0;
    const std::string query = "select * from Strings;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = strings.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->table.id = sqlite3_column_int(stmt, 2);
        v->ru = (const char *)sqlite3_column_text(stmt, 3);
        v->en = (const char *)sqlite3_column_text(stmt, 4);
        strings.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadStringsPtrs()
{
    for (auto &string : strings)
    {
        if (tables.find(string.second->table.id) != tables.end())
            string.second->table.ptr = tables[string.second->table.id];
    }
}

void StorageImpl::_loadStringsArrays()
{
}

void StorageImpl::_saveStrings() const
{
    db->execute("BEGIN;");
    db->execute("delete from Strings;");
    const std::string query = "insert into Strings values (?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &string : strings)
    {
        auto &v = string.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 3, v->table.id);
        ret = sqlite3_bind_text(stmt, 4, v->ru.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 5, v->en.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadTables()
{
    int ret = 0;
    const std::string query = "select * from Tables;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = tables.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        tables.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadTablesPtrs()
{
}

void StorageImpl::_loadTablesArrays()
{
}

void StorageImpl::_saveTables() const
{
    db->execute("BEGIN;");
    db->execute("delete from Tables;");
    const std::string query = "insert into Tables values (?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &table : tables)
    {
        auto &v = table.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::_loadWeapons()
{
    int ret = 0;
    const std::string query = "select * from Weapons;";
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        auto v = weapons.create();
        v->id = sqlite3_column_int(stmt, 0);
        v->text_id = (const char *)sqlite3_column_text(stmt, 1);
        v->resource = (const char *)sqlite3_column_text(stmt, 2);
        v->name.id = sqlite3_column_int(stmt, 3);
        v->projectile.id = sqlite3_column_int(stmt, 4);
        v->type = sqlite3_column_int(stmt, 5);
        v->standard = sqlite3_column_int(stmt, 6);
        v->weight = (float)sqlite3_column_double(stmt, 7);
        v->power = (float)sqlite3_column_double(stmt, 8);
        v->firerate = (float)sqlite3_column_double(stmt, 9);
        v->damage = (float)sqlite3_column_double(stmt, 10);
        v->price = (float)sqlite3_column_double(stmt, 11);
        v->fx = (float)sqlite3_column_double(stmt, 12);
        v->shoottype = sqlite3_column_int(stmt, 13);
        v->shootscale = (float)sqlite3_column_double(stmt, 14);
        v->xstate = sqlite3_column_int(stmt, 15);
        v->rcolor = (float)sqlite3_column_double(stmt, 16);
        v->gcolor = (float)sqlite3_column_double(stmt, 17);
        v->bcolor = (float)sqlite3_column_double(stmt, 18);
        v->typearms = sqlite3_column_int(stmt, 19);
        v->tfire = (float)sqlite3_column_double(stmt, 20);
        v->vtype = sqlite3_column_int(stmt, 21);
        v->spare = (float)sqlite3_column_double(stmt, 22);
        v->reconstruction = (float)sqlite3_column_double(stmt, 23);
        v->maxdistance = (float)sqlite3_column_double(stmt, 24);
        v->angle = (float)sqlite3_column_double(stmt, 25);
        v->fxtime = (float)sqlite3_column_double(stmt, 26);
        v->damagetype = sqlite3_column_int(stmt, 27);
        v->fxmodeltime = (float)sqlite3_column_double(stmt, 28);
        v->inside_mul = (float)sqlite3_column_double(stmt, 29);
        v->inside_x = (float)sqlite3_column_double(stmt, 30);
        v->inside_y = (float)sqlite3_column_double(stmt, 31);
        v->inside_z = (float)sqlite3_column_double(stmt, 32);
        v->notrade = sqlite3_column_int(stmt, 33);
        weapons.insert(v);
    }
    ret = sqlite3_finalize(stmt);
}

void StorageImpl::_loadWeaponsPtrs()
{
    for (auto &weapon : weapons)
    {
        if (strings.find(weapon.second->name.id) != strings.end())
            weapon.second->name.ptr = strings[weapon.second->name.id];
        if (projectiles.find(weapon.second->projectile.id) != projectiles.end())
            weapon.second->projectile.ptr = projectiles[weapon.second->projectile.id];
    }
}

void StorageImpl::_loadWeaponsArrays()
{
}

void StorageImpl::_saveWeapons() const
{
    db->execute("BEGIN;");
    db->execute("delete from Weapons;");
    const std::string query = "insert into Weapons values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    int ret = 0;
    auto db3 = db->getDb();
    sqlite3_stmt *stmt;
    ret = sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);
    for (auto &weapon : weapons)
    {
        auto &v = weapon.second;
        ret = sqlite3_bind_int(stmt, 1, v->id);
        ret = sqlite3_bind_text(stmt, 2, v->text_id.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_text(stmt, 3, v->resource.string().c_str(), -1, SQLITE_TRANSIENT);
        ret = sqlite3_bind_int(stmt, 4, v->name.id);
        ret = sqlite3_bind_int(stmt, 5, v->projectile.id);
        ret = sqlite3_bind_int(stmt, 6, v->type);
        ret = sqlite3_bind_int(stmt, 7, v->standard);
        ret = sqlite3_bind_double(stmt, 8, v->weight);
        ret = sqlite3_bind_double(stmt, 9, v->power);
        ret = sqlite3_bind_double(stmt, 10, v->firerate);
        ret = sqlite3_bind_double(stmt, 11, v->damage);
        ret = sqlite3_bind_double(stmt, 12, v->price);
        ret = sqlite3_bind_double(stmt, 13, v->fx);
        ret = sqlite3_bind_int(stmt, 14, v->shoottype);
        ret = sqlite3_bind_double(stmt, 15, v->shootscale);
        ret = sqlite3_bind_int(stmt, 16, v->xstate);
        ret = sqlite3_bind_double(stmt, 17, v->rcolor);
        ret = sqlite3_bind_double(stmt, 18, v->gcolor);
        ret = sqlite3_bind_double(stmt, 19, v->bcolor);
        ret = sqlite3_bind_int(stmt, 20, v->typearms);
        ret = sqlite3_bind_double(stmt, 21, v->tfire);
        ret = sqlite3_bind_int(stmt, 22, v->vtype);
        ret = sqlite3_bind_double(stmt, 23, v->spare);
        ret = sqlite3_bind_double(stmt, 24, v->reconstruction);
        ret = sqlite3_bind_double(stmt, 25, v->maxdistance);
        ret = sqlite3_bind_double(stmt, 26, v->angle);
        ret = sqlite3_bind_double(stmt, 27, v->fxtime);
        ret = sqlite3_bind_int(stmt, 28, v->damagetype);
        ret = sqlite3_bind_double(stmt, 29, v->fxmodeltime);
        ret = sqlite3_bind_double(stmt, 30, v->inside_mul);
        ret = sqlite3_bind_double(stmt, 31, v->inside_x);
        ret = sqlite3_bind_double(stmt, 32, v->inside_y);
        ret = sqlite3_bind_double(stmt, 33, v->inside_z);
        ret = sqlite3_bind_int(stmt, 34, v->notrade);
        ret = sqlite3_step(stmt);
        ret = sqlite3_reset(stmt);
    }
    ret = sqlite3_finalize(stmt);
    db->execute("COMMIT;");
}

void StorageImpl::create() const
{
    db->execute(Building::getSql());
    db->execute(ClanMechanoid::getSql());
    db->execute(ClanReputation::getSql());
    db->execute(Clan::getSql());
    db->execute(ConfigurationEquipment::getSql());
    db->execute(ConfigurationGood::getSql());
    db->execute(ConfigurationProjectile::getSql());
    db->execute(ConfigurationWeapon::getSql());
    db->execute(Configuration::getSql());
    db->execute(Equipment::getSql());
    db->execute(Glider::getSql());
    db->execute(Good::getSql());
    db->execute(GroupMechanoid::getSql());
    db->execute(Group::getSql());
    db->execute(MapBuildingEquipment::getSql());
    db->execute(MapBuildingGlider::getSql());
    db->execute(MapBuildingGood::getSql());
    db->execute(MapBuildingModificator::getSql());
    db->execute(MapBuildingProjectile::getSql());
    db->execute(MapBuildingWeapon::getSql());
    db->execute(MapBuilding::getSql());
    db->execute(MapGood::getSql());
    db->execute(MapObject::getSql());
    db->execute(Map::getSql());
    db->execute(MechanoidQuest::getSql());
    db->execute(Mechanoid::getSql());
    db->execute(ModificationClan::getSql());
    db->execute(ModificationMap::getSql());
    db->execute(ModificationMechanoid::getSql());
    db->execute(Modification::getSql());
    db->execute(Modificator::getSql());
    db->execute(Object::getSql());
    db->execute(Player::getSql());
    db->execute(Projectile::getSql());
    db->execute(QuestRewardEquipment::getSql());
    db->execute(QuestRewardGlider::getSql());
    db->execute(QuestRewardGood::getSql());
    db->execute(QuestRewardModificator::getSql());
    db->execute(QuestRewardProjectile::getSql());
    db->execute(QuestRewardReputation::getSql());
    db->execute(QuestRewardWeapon::getSql());
    db->execute(QuestReward::getSql());
    db->execute(Quest::getSql());
    db->execute(ScriptVariable::getSql());
    db->execute(Setting::getSql());
    db->execute(String::getSql());
    db->execute(Table::getSql());
    db->execute(Weapon::getSql());
}

void StorageImpl::clear()
{
    buildings.clear();
    clanMechanoids.clear();
    clanReputations.clear();
    clans.clear();
    configurationEquipments.clear();
    configurationGoods.clear();
    configurationProjectiles.clear();
    configurationWeapons.clear();
    configurations.clear();
    equipments.clear();
    gliders.clear();
    goods.clear();
    groupMechanoids.clear();
    groups.clear();
    mapBuildingEquipments.clear();
    mapBuildingGliders.clear();
    mapBuildingGoods.clear();
    mapBuildingModificators.clear();
    mapBuildingProjectiles.clear();
    mapBuildingWeapons.clear();
    mapBuildings.clear();
    mapGoods.clear();
    mapObjects.clear();
    maps.clear();
    mechanoidQuests.clear();
    mechanoids.clear();
    modificationClans.clear();
    modificationMaps.clear();
    modificationMechanoids.clear();
    modifications.clear();
    modificators.clear();
    objects.clear();
    players.clear();
    projectiles.clear();
    questRewardEquipments.clear();
    questRewardGliders.clear();
    questRewardGoods.clear();
    questRewardModificators.clear();
    questRewardProjectiles.clear();
    questRewardReputations.clear();
    questRewardWeapons.clear();
    questRewards.clear();
    quests.clear();
    scriptVariables.clear();
    settings.clear();
    strings.clear();
    tables.clear();
    weapons.clear();
}

void StorageImpl::load(ProgressCallback callback)
{
    _loadBuildings();
    PROGRESS_CALLBACK(0.694444);
    _loadClanMechanoids();
    PROGRESS_CALLBACK(1.388889);
    _loadClanReputations();
    PROGRESS_CALLBACK(2.083333);
    _loadClans();
    PROGRESS_CALLBACK(2.777778);
    _loadConfigurationEquipments();
    PROGRESS_CALLBACK(3.472222);
    _loadConfigurationGoods();
    PROGRESS_CALLBACK(4.166667);
    _loadConfigurationProjectiles();
    PROGRESS_CALLBACK(4.861111);
    _loadConfigurationWeapons();
    PROGRESS_CALLBACK(5.555556);
    _loadConfigurations();
    PROGRESS_CALLBACK(6.250000);
    _loadEquipments();
    PROGRESS_CALLBACK(6.944444);
    _loadGliders();
    PROGRESS_CALLBACK(7.638889);
    _loadGoods();
    PROGRESS_CALLBACK(8.333333);
    _loadGroupMechanoids();
    PROGRESS_CALLBACK(9.027778);
    _loadGroups();
    PROGRESS_CALLBACK(9.722222);
    _loadMapBuildingEquipments();
    PROGRESS_CALLBACK(10.416667);
    _loadMapBuildingGliders();
    PROGRESS_CALLBACK(11.111111);
    _loadMapBuildingGoods();
    PROGRESS_CALLBACK(11.805556);
    _loadMapBuildingModificators();
    PROGRESS_CALLBACK(12.500000);
    _loadMapBuildingProjectiles();
    PROGRESS_CALLBACK(13.194444);
    _loadMapBuildingWeapons();
    PROGRESS_CALLBACK(13.888889);
    _loadMapBuildings();
    PROGRESS_CALLBACK(14.583333);
    _loadMapGoods();
    PROGRESS_CALLBACK(15.277778);
    _loadMapObjects();
    PROGRESS_CALLBACK(15.972222);
    _loadMaps();
    PROGRESS_CALLBACK(16.666667);
    _loadMechanoidQuests();
    PROGRESS_CALLBACK(17.361111);
    _loadMechanoids();
    PROGRESS_CALLBACK(18.055556);
    _loadModificationClans();
    PROGRESS_CALLBACK(18.750000);
    _loadModificationMaps();
    PROGRESS_CALLBACK(19.444444);
    _loadModificationMechanoids();
    PROGRESS_CALLBACK(20.138889);
    _loadModifications();
    PROGRESS_CALLBACK(20.833333);
    _loadModificators();
    PROGRESS_CALLBACK(21.527778);
    _loadObjects();
    PROGRESS_CALLBACK(22.222222);
    _loadPlayers();
    PROGRESS_CALLBACK(22.916667);
    _loadProjectiles();
    PROGRESS_CALLBACK(23.611111);
    _loadQuestRewardEquipments();
    PROGRESS_CALLBACK(24.305556);
    _loadQuestRewardGliders();
    PROGRESS_CALLBACK(25.000000);
    _loadQuestRewardGoods();
    PROGRESS_CALLBACK(25.694444);
    _loadQuestRewardModificators();
    PROGRESS_CALLBACK(26.388889);
    _loadQuestRewardProjectiles();
    PROGRESS_CALLBACK(27.083333);
    _loadQuestRewardReputations();
    PROGRESS_CALLBACK(27.777778);
    _loadQuestRewardWeapons();
    PROGRESS_CALLBACK(28.472222);
    _loadQuestRewards();
    PROGRESS_CALLBACK(29.166667);
    _loadQuests();
    PROGRESS_CALLBACK(29.861111);
    _loadScriptVariables();
    PROGRESS_CALLBACK(30.555556);
    _loadSettings();
    PROGRESS_CALLBACK(31.250000);
    _loadStrings();
    PROGRESS_CALLBACK(31.944444);
    _loadTables();
    PROGRESS_CALLBACK(32.638889);
    _loadWeapons();
    PROGRESS_CALLBACK(33.333333);

    _loadBuildingsPtrs();
    PROGRESS_CALLBACK(34.027778);
    _loadClanMechanoidsPtrs();
    PROGRESS_CALLBACK(34.722222);
    _loadClanReputationsPtrs();
    PROGRESS_CALLBACK(35.416667);
    _loadClansPtrs();
    PROGRESS_CALLBACK(36.111111);
    _loadConfigurationEquipmentsPtrs();
    PROGRESS_CALLBACK(36.805556);
    _loadConfigurationGoodsPtrs();
    PROGRESS_CALLBACK(37.500000);
    _loadConfigurationProjectilesPtrs();
    PROGRESS_CALLBACK(38.194444);
    _loadConfigurationWeaponsPtrs();
    PROGRESS_CALLBACK(38.888889);
    _loadConfigurationsPtrs();
    PROGRESS_CALLBACK(39.583333);
    _loadEquipmentsPtrs();
    PROGRESS_CALLBACK(40.277778);
    _loadGlidersPtrs();
    PROGRESS_CALLBACK(40.972222);
    _loadGoodsPtrs();
    PROGRESS_CALLBACK(41.666667);
    _loadGroupMechanoidsPtrs();
    PROGRESS_CALLBACK(42.361111);
    _loadGroupsPtrs();
    PROGRESS_CALLBACK(43.055556);
    _loadMapBuildingEquipmentsPtrs();
    PROGRESS_CALLBACK(43.750000);
    _loadMapBuildingGlidersPtrs();
    PROGRESS_CALLBACK(44.444444);
    _loadMapBuildingGoodsPtrs();
    PROGRESS_CALLBACK(45.138889);
    _loadMapBuildingModificatorsPtrs();
    PROGRESS_CALLBACK(45.833333);
    _loadMapBuildingProjectilesPtrs();
    PROGRESS_CALLBACK(46.527778);
    _loadMapBuildingWeaponsPtrs();
    PROGRESS_CALLBACK(47.222222);
    _loadMapBuildingsPtrs();
    PROGRESS_CALLBACK(47.916667);
    _loadMapGoodsPtrs();
    PROGRESS_CALLBACK(48.611111);
    _loadMapObjectsPtrs();
    PROGRESS_CALLBACK(49.305556);
    _loadMapsPtrs();
    PROGRESS_CALLBACK(50.000000);
    _loadMechanoidQuestsPtrs();
    PROGRESS_CALLBACK(50.694444);
    _loadMechanoidsPtrs();
    PROGRESS_CALLBACK(51.388889);
    _loadModificationClansPtrs();
    PROGRESS_CALLBACK(52.083333);
    _loadModificationMapsPtrs();
    PROGRESS_CALLBACK(52.777778);
    _loadModificationMechanoidsPtrs();
    PROGRESS_CALLBACK(53.472222);
    _loadModificationsPtrs();
    PROGRESS_CALLBACK(54.166667);
    _loadModificatorsPtrs();
    PROGRESS_CALLBACK(54.861111);
    _loadObjectsPtrs();
    PROGRESS_CALLBACK(55.555556);
    _loadPlayersPtrs();
    PROGRESS_CALLBACK(56.250000);
    _loadProjectilesPtrs();
    PROGRESS_CALLBACK(56.944444);
    _loadQuestRewardEquipmentsPtrs();
    PROGRESS_CALLBACK(57.638889);
    _loadQuestRewardGlidersPtrs();
    PROGRESS_CALLBACK(58.333333);
    _loadQuestRewardGoodsPtrs();
    PROGRESS_CALLBACK(59.027778);
    _loadQuestRewardModificatorsPtrs();
    PROGRESS_CALLBACK(59.722222);
    _loadQuestRewardProjectilesPtrs();
    PROGRESS_CALLBACK(60.416667);
    _loadQuestRewardReputationsPtrs();
    PROGRESS_CALLBACK(61.111111);
    _loadQuestRewardWeaponsPtrs();
    PROGRESS_CALLBACK(61.805556);
    _loadQuestRewardsPtrs();
    PROGRESS_CALLBACK(62.500000);
    _loadQuestsPtrs();
    PROGRESS_CALLBACK(63.194444);
    _loadScriptVariablesPtrs();
    PROGRESS_CALLBACK(63.888889);
    _loadSettingsPtrs();
    PROGRESS_CALLBACK(64.583333);
    _loadStringsPtrs();
    PROGRESS_CALLBACK(65.277778);
    _loadTablesPtrs();
    PROGRESS_CALLBACK(65.972222);
    _loadWeaponsPtrs();
    PROGRESS_CALLBACK(66.666667);

    _loadBuildingsArrays();
    PROGRESS_CALLBACK(67.361111);
    _loadClanMechanoidsArrays();
    PROGRESS_CALLBACK(68.055556);
    _loadClanReputationsArrays();
    PROGRESS_CALLBACK(68.750000);
    _loadClansArrays();
    PROGRESS_CALLBACK(69.444444);
    _loadConfigurationEquipmentsArrays();
    PROGRESS_CALLBACK(70.138889);
    _loadConfigurationGoodsArrays();
    PROGRESS_CALLBACK(70.833333);
    _loadConfigurationProjectilesArrays();
    PROGRESS_CALLBACK(71.527778);
    _loadConfigurationWeaponsArrays();
    PROGRESS_CALLBACK(72.222222);
    _loadConfigurationsArrays();
    PROGRESS_CALLBACK(72.916667);
    _loadEquipmentsArrays();
    PROGRESS_CALLBACK(73.611111);
    _loadGlidersArrays();
    PROGRESS_CALLBACK(74.305556);
    _loadGoodsArrays();
    PROGRESS_CALLBACK(75.000000);
    _loadGroupMechanoidsArrays();
    PROGRESS_CALLBACK(75.694444);
    _loadGroupsArrays();
    PROGRESS_CALLBACK(76.388889);
    _loadMapBuildingEquipmentsArrays();
    PROGRESS_CALLBACK(77.083333);
    _loadMapBuildingGlidersArrays();
    PROGRESS_CALLBACK(77.777778);
    _loadMapBuildingGoodsArrays();
    PROGRESS_CALLBACK(78.472222);
    _loadMapBuildingModificatorsArrays();
    PROGRESS_CALLBACK(79.166667);
    _loadMapBuildingProjectilesArrays();
    PROGRESS_CALLBACK(79.861111);
    _loadMapBuildingWeaponsArrays();
    PROGRESS_CALLBACK(80.555556);
    _loadMapBuildingsArrays();
    PROGRESS_CALLBACK(81.250000);
    _loadMapGoodsArrays();
    PROGRESS_CALLBACK(81.944444);
    _loadMapObjectsArrays();
    PROGRESS_CALLBACK(82.638889);
    _loadMapsArrays();
    PROGRESS_CALLBACK(83.333333);
    _loadMechanoidQuestsArrays();
    PROGRESS_CALLBACK(84.027778);
    _loadMechanoidsArrays();
    PROGRESS_CALLBACK(84.722222);
    _loadModificationClansArrays();
    PROGRESS_CALLBACK(85.416667);
    _loadModificationMapsArrays();
    PROGRESS_CALLBACK(86.111111);
    _loadModificationMechanoidsArrays();
    PROGRESS_CALLBACK(86.805556);
    _loadModificationsArrays();
    PROGRESS_CALLBACK(87.500000);
    _loadModificatorsArrays();
    PROGRESS_CALLBACK(88.194444);
    _loadObjectsArrays();
    PROGRESS_CALLBACK(88.888889);
    _loadPlayersArrays();
    PROGRESS_CALLBACK(89.583333);
    _loadProjectilesArrays();
    PROGRESS_CALLBACK(90.277778);
    _loadQuestRewardEquipmentsArrays();
    PROGRESS_CALLBACK(90.972222);
    _loadQuestRewardGlidersArrays();
    PROGRESS_CALLBACK(91.666667);
    _loadQuestRewardGoodsArrays();
    PROGRESS_CALLBACK(92.361111);
    _loadQuestRewardModificatorsArrays();
    PROGRESS_CALLBACK(93.055556);
    _loadQuestRewardProjectilesArrays();
    PROGRESS_CALLBACK(93.750000);
    _loadQuestRewardReputationsArrays();
    PROGRESS_CALLBACK(94.444444);
    _loadQuestRewardWeaponsArrays();
    PROGRESS_CALLBACK(95.138889);
    _loadQuestRewardsArrays();
    PROGRESS_CALLBACK(95.833333);
    _loadQuestsArrays();
    PROGRESS_CALLBACK(96.527778);
    _loadScriptVariablesArrays();
    PROGRESS_CALLBACK(97.222222);
    _loadSettingsArrays();
    PROGRESS_CALLBACK(97.916667);
    _loadStringsArrays();
    PROGRESS_CALLBACK(98.611111);
    _loadTablesArrays();
    PROGRESS_CALLBACK(99.305556);
    _loadWeaponsArrays();
    PROGRESS_CALLBACK(100.000000);
}

void StorageImpl::save(ProgressCallback callback) const
{
    _saveBuildings();
    PROGRESS_CALLBACK(2.083333);
    _saveClanMechanoids();
    PROGRESS_CALLBACK(4.166667);
    _saveClanReputations();
    PROGRESS_CALLBACK(6.250000);
    _saveClans();
    PROGRESS_CALLBACK(8.333333);
    _saveConfigurationEquipments();
    PROGRESS_CALLBACK(10.416667);
    _saveConfigurationGoods();
    PROGRESS_CALLBACK(12.500000);
    _saveConfigurationProjectiles();
    PROGRESS_CALLBACK(14.583333);
    _saveConfigurationWeapons();
    PROGRESS_CALLBACK(16.666667);
    _saveConfigurations();
    PROGRESS_CALLBACK(18.750000);
    _saveEquipments();
    PROGRESS_CALLBACK(20.833333);
    _saveGliders();
    PROGRESS_CALLBACK(22.916667);
    _saveGoods();
    PROGRESS_CALLBACK(25.000000);
    _saveGroupMechanoids();
    PROGRESS_CALLBACK(27.083333);
    _saveGroups();
    PROGRESS_CALLBACK(29.166667);
    _saveMapBuildingEquipments();
    PROGRESS_CALLBACK(31.250000);
    _saveMapBuildingGliders();
    PROGRESS_CALLBACK(33.333333);
    _saveMapBuildingGoods();
    PROGRESS_CALLBACK(35.416667);
    _saveMapBuildingModificators();
    PROGRESS_CALLBACK(37.500000);
    _saveMapBuildingProjectiles();
    PROGRESS_CALLBACK(39.583333);
    _saveMapBuildingWeapons();
    PROGRESS_CALLBACK(41.666667);
    _saveMapBuildings();
    PROGRESS_CALLBACK(43.750000);
    _saveMapGoods();
    PROGRESS_CALLBACK(45.833333);
    _saveMapObjects();
    PROGRESS_CALLBACK(47.916667);
    _saveMaps();
    PROGRESS_CALLBACK(50.000000);
    _saveMechanoidQuests();
    PROGRESS_CALLBACK(52.083333);
    _saveMechanoids();
    PROGRESS_CALLBACK(54.166667);
    _saveModificationClans();
    PROGRESS_CALLBACK(56.250000);
    _saveModificationMaps();
    PROGRESS_CALLBACK(58.333333);
    _saveModificationMechanoids();
    PROGRESS_CALLBACK(60.416667);
    _saveModifications();
    PROGRESS_CALLBACK(62.500000);
    _saveModificators();
    PROGRESS_CALLBACK(64.583333);
    _saveObjects();
    PROGRESS_CALLBACK(66.666667);
    _savePlayers();
    PROGRESS_CALLBACK(68.750000);
    _saveProjectiles();
    PROGRESS_CALLBACK(70.833333);
    _saveQuestRewardEquipments();
    PROGRESS_CALLBACK(72.916667);
    _saveQuestRewardGliders();
    PROGRESS_CALLBACK(75.000000);
    _saveQuestRewardGoods();
    PROGRESS_CALLBACK(77.083333);
    _saveQuestRewardModificators();
    PROGRESS_CALLBACK(79.166667);
    _saveQuestRewardProjectiles();
    PROGRESS_CALLBACK(81.250000);
    _saveQuestRewardReputations();
    PROGRESS_CALLBACK(83.333333);
    _saveQuestRewardWeapons();
    PROGRESS_CALLBACK(85.416667);
    _saveQuestRewards();
    PROGRESS_CALLBACK(87.500000);
    _saveQuests();
    PROGRESS_CALLBACK(89.583333);
    _saveScriptVariables();
    PROGRESS_CALLBACK(91.666667);
    _saveSettings();
    PROGRESS_CALLBACK(93.750000);
    _saveStrings();
    PROGRESS_CALLBACK(95.833333);
    _saveTables();
    PROGRESS_CALLBACK(97.916667);
    _saveWeapons();
    PROGRESS_CALLBACK(100.000000);
}

Ptr<Building> StorageImpl::addBuilding()
{
    return buildings.createAtEnd();
}

void StorageImpl::deleteBuilding(Building *v)
{
    buildings.erase(v->id);
}

Ptr<ClanMechanoid> StorageImpl::addClanMechanoid(IObject *parent)
{
    auto v = clanMechanoids.createAtEnd();
    Clan *clan = (Clan *)parent;
    clan->mechanoids.insert(v);
    v->clan = clans[clan->id];
    return v;
}

void StorageImpl::deleteClanMechanoid(ClanMechanoid *v)
{
    clanMechanoids.erase(v);
}

Ptr<ClanReputation> StorageImpl::addClanReputation(IObject *parent)
{
    auto v = clanReputations.createAtEnd();
    Clan *clan = (Clan *)parent;
    clan->reputations.insert(v);
    v->clan = clans[clan->id];
    return v;
}

void StorageImpl::deleteClanReputation(ClanReputation *v)
{
    clanReputations.erase(v);
}

Ptr<Clan> StorageImpl::addClan()
{
    return clans.createAtEnd();
}

void StorageImpl::deleteClan(Clan *v)
{
    clans.erase(v->id);
}

Ptr<ConfigurationEquipment> StorageImpl::addConfigurationEquipment(IObject *parent)
{
    auto v = configurationEquipments.createAtEnd();
    Configuration *configuration = (Configuration *)parent;
    configuration->equipments.insert(v);
    v->configuration = configurations[configuration->id];
    return v;
}

void StorageImpl::deleteConfigurationEquipment(ConfigurationEquipment *v)
{
    configurationEquipments.erase(v);
}

Ptr<ConfigurationGood> StorageImpl::addConfigurationGood(IObject *parent)
{
    auto v = configurationGoods.createAtEnd();
    Configuration *configuration = (Configuration *)parent;
    configuration->goods.insert(v);
    v->configuration = configurations[configuration->id];
    return v;
}

void StorageImpl::deleteConfigurationGood(ConfigurationGood *v)
{
    configurationGoods.erase(v);
}

Ptr<ConfigurationProjectile> StorageImpl::addConfigurationProjectile(IObject *parent)
{
    auto v = configurationProjectiles.createAtEnd();
    Configuration *configuration = (Configuration *)parent;
    configuration->projectiles.insert(v);
    v->configuration = configurations[configuration->id];
    return v;
}

void StorageImpl::deleteConfigurationProjectile(ConfigurationProjectile *v)
{
    configurationProjectiles.erase(v);
}

Ptr<ConfigurationWeapon> StorageImpl::addConfigurationWeapon(IObject *parent)
{
    auto v = configurationWeapons.createAtEnd();
    Configuration *configuration = (Configuration *)parent;
    configuration->weapons.insert(v);
    v->configuration = configurations[configuration->id];
    return v;
}

void StorageImpl::deleteConfigurationWeapon(ConfigurationWeapon *v)
{
    configurationWeapons.erase(v);
}

Ptr<Configuration> StorageImpl::addConfiguration()
{
    return configurations.createAtEnd();
}

void StorageImpl::deleteConfiguration(Configuration *v)
{
    configurations.erase(v->id);
}

Ptr<Equipment> StorageImpl::addEquipment()
{
    return equipments.createAtEnd();
}

void StorageImpl::deleteEquipment(Equipment *v)
{
    equipments.erase(v->id);
}

Ptr<Glider> StorageImpl::addGlider()
{
    return gliders.createAtEnd();
}

void StorageImpl::deleteGlider(Glider *v)
{
    gliders.erase(v->id);
}

Ptr<Good> StorageImpl::addGood()
{
    return goods.createAtEnd();
}

void StorageImpl::deleteGood(Good *v)
{
    goods.erase(v->id);
}

Ptr<GroupMechanoid> StorageImpl::addGroupMechanoid(IObject *parent)
{
    auto v = groupMechanoids.createAtEnd();
    Group *group = (Group *)parent;
    group->mechanoids.insert(v);
    v->group = groups[group->id];
    return v;
}

void StorageImpl::deleteGroupMechanoid(GroupMechanoid *v)
{
    groupMechanoids.erase(v);
}

Ptr<Group> StorageImpl::addGroup()
{
    return groups.createAtEnd();
}

void StorageImpl::deleteGroup(Group *v)
{
    groups.erase(v->id);
}

Ptr<MapBuildingEquipment> StorageImpl::addMapBuildingEquipment(IObject *parent)
{
    auto v = mapBuildingEquipments.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->equipments.insert(v);
    v->mapBuilding = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingEquipment(MapBuildingEquipment *v)
{
    mapBuildingEquipments.erase(v);
}

Ptr<MapBuildingGlider> StorageImpl::addMapBuildingGlider(IObject *parent)
{
    auto v = mapBuildingGliders.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->gliders.insert(v);
    v->mapBuilding = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingGlider(MapBuildingGlider *v)
{
    mapBuildingGliders.erase(v);
}

Ptr<MapBuildingGood> StorageImpl::addMapBuildingGood(IObject *parent)
{
    auto v = mapBuildingGoods.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->goods.insert(v);
    v->mapBuilding = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingGood(MapBuildingGood *v)
{
    mapBuildingGoods.erase(v);
}

Ptr<MapBuildingModificator> StorageImpl::addMapBuildingModificator(IObject *parent)
{
    auto v = mapBuildingModificators.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->modificators.insert(v);
    v->mapBuilding = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingModificator(MapBuildingModificator *v)
{
    mapBuildingModificators.erase(v);
}

Ptr<MapBuildingProjectile> StorageImpl::addMapBuildingProjectile(IObject *parent)
{
    auto v = mapBuildingProjectiles.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->projectiles.insert(v);
    v->mapBuilding = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingProjectile(MapBuildingProjectile *v)
{
    mapBuildingProjectiles.erase(v);
}

Ptr<MapBuildingWeapon> StorageImpl::addMapBuildingWeapon(IObject *parent)
{
    auto v = mapBuildingWeapons.createAtEnd();
    MapBuilding *mapBuilding = (MapBuilding *)parent;
    mapBuilding->weapons.insert(v);
    v->mapBuilding = mapBuildings[mapBuilding->id];
    return v;
}

void StorageImpl::deleteMapBuildingWeapon(MapBuildingWeapon *v)
{
    mapBuildingWeapons.erase(v);
}

Ptr<MapBuilding> StorageImpl::addMapBuilding(IObject *parent)
{
    auto v = mapBuildings.createAtEnd();
    Map *map = (Map *)parent;
    map->buildings.insert(v);
    v->map = maps[map->id];
    return v;
}

void StorageImpl::deleteMapBuilding(MapBuilding *v)
{
    mapBuildings.erase(v->id);
}

Ptr<MapGood> StorageImpl::addMapGood(IObject *parent)
{
    auto v = mapGoods.createAtEnd();
    Map *map = (Map *)parent;
    map->goods.insert(v);
    v->map = maps[map->id];
    return v;
}

void StorageImpl::deleteMapGood(MapGood *v)
{
    mapGoods.erase(v->id);
}

Ptr<MapObject> StorageImpl::addMapObject(IObject *parent)
{
    auto v = mapObjects.createAtEnd();
    Map *map = (Map *)parent;
    map->objects.insert(v);
    v->map = maps[map->id];
    return v;
}

void StorageImpl::deleteMapObject(MapObject *v)
{
    mapObjects.erase(v->id);
}

Ptr<Map> StorageImpl::addMap()
{
    return maps.createAtEnd();
}

void StorageImpl::deleteMap(Map *v)
{
    maps.erase(v->id);
}

Ptr<MechanoidQuest> StorageImpl::addMechanoidQuest(IObject *parent)
{
    auto v = mechanoidQuests.createAtEnd();
    Mechanoid *mechanoid = (Mechanoid *)parent;
    mechanoid->quests.insert(v);
    v->mechanoid = mechanoids[mechanoid->id];
    return v;
}

void StorageImpl::deleteMechanoidQuest(MechanoidQuest *v)
{
    mechanoidQuests.erase(v);
}

Ptr<Mechanoid> StorageImpl::addMechanoid()
{
    return mechanoids.createAtEnd();
}

void StorageImpl::deleteMechanoid(Mechanoid *v)
{
    mechanoids.erase(v->id);
}

Ptr<ModificationClan> StorageImpl::addModificationClan(IObject *parent)
{
    auto v = modificationClans.createAtEnd();
    Modification *modification = (Modification *)parent;
    modification->clans.insert(v);
    v->modification = modifications[modification->id];
    return v;
}

void StorageImpl::deleteModificationClan(ModificationClan *v)
{
    modificationClans.erase(v);
}

Ptr<ModificationMap> StorageImpl::addModificationMap(IObject *parent)
{
    auto v = modificationMaps.createAtEnd();
    Modification *modification = (Modification *)parent;
    modification->maps.insert(v);
    v->modification = modifications[modification->id];
    return v;
}

void StorageImpl::deleteModificationMap(ModificationMap *v)
{
    modificationMaps.erase(v);
}

Ptr<ModificationMechanoid> StorageImpl::addModificationMechanoid(IObject *parent)
{
    auto v = modificationMechanoids.createAtEnd();
    Modification *modification = (Modification *)parent;
    modification->mechanoids.insert(v);
    v->modification = modifications[modification->id];
    return v;
}

void StorageImpl::deleteModificationMechanoid(ModificationMechanoid *v)
{
    modificationMechanoids.erase(v);
}

Ptr<Modification> StorageImpl::addModification()
{
    return modifications.createAtEnd();
}

void StorageImpl::deleteModification(Modification *v)
{
    modifications.erase(v->id);
}

Ptr<Modificator> StorageImpl::addModificator()
{
    return modificators.createAtEnd();
}

void StorageImpl::deleteModificator(Modificator *v)
{
    modificators.erase(v->id);
}

Ptr<Object> StorageImpl::addObject()
{
    return objects.createAtEnd();
}

void StorageImpl::deleteObject(Object *v)
{
    objects.erase(v->id);
}

Ptr<Player> StorageImpl::addPlayer()
{
    return players.createAtEnd();
}

void StorageImpl::deletePlayer(Player *v)
{
    players.erase(v->id);
}

Ptr<Projectile> StorageImpl::addProjectile()
{
    return projectiles.createAtEnd();
}

void StorageImpl::deleteProjectile(Projectile *v)
{
    projectiles.erase(v->id);
}

Ptr<QuestRewardEquipment> StorageImpl::addQuestRewardEquipment(IObject *parent)
{
    auto v = questRewardEquipments.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->equipments.insert(v);
    v->questReward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardEquipment(QuestRewardEquipment *v)
{
    questRewardEquipments.erase(v);
}

Ptr<QuestRewardGlider> StorageImpl::addQuestRewardGlider(IObject *parent)
{
    auto v = questRewardGliders.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->gliders.insert(v);
    v->questReward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardGlider(QuestRewardGlider *v)
{
    questRewardGliders.erase(v);
}

Ptr<QuestRewardGood> StorageImpl::addQuestRewardGood(IObject *parent)
{
    auto v = questRewardGoods.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->goods.insert(v);
    v->questReward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardGood(QuestRewardGood *v)
{
    questRewardGoods.erase(v);
}

Ptr<QuestRewardModificator> StorageImpl::addQuestRewardModificator(IObject *parent)
{
    auto v = questRewardModificators.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->modificators.insert(v);
    v->questReward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardModificator(QuestRewardModificator *v)
{
    questRewardModificators.erase(v);
}

Ptr<QuestRewardProjectile> StorageImpl::addQuestRewardProjectile(IObject *parent)
{
    auto v = questRewardProjectiles.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->projectiles.insert(v);
    v->questReward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardProjectile(QuestRewardProjectile *v)
{
    questRewardProjectiles.erase(v);
}

Ptr<QuestRewardReputation> StorageImpl::addQuestRewardReputation(IObject *parent)
{
    auto v = questRewardReputations.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->reputations.insert(v);
    v->questReward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardReputation(QuestRewardReputation *v)
{
    questRewardReputations.erase(v);
}

Ptr<QuestRewardWeapon> StorageImpl::addQuestRewardWeapon(IObject *parent)
{
    auto v = questRewardWeapons.createAtEnd();
    QuestReward *questReward = (QuestReward *)parent;
    questReward->weapons.insert(v);
    v->questReward = questRewards[questReward->id];
    return v;
}

void StorageImpl::deleteQuestRewardWeapon(QuestRewardWeapon *v)
{
    questRewardWeapons.erase(v);
}

Ptr<QuestReward> StorageImpl::addQuestReward(IObject *parent)
{
    return questRewards.createAtEnd();
}

void StorageImpl::deleteQuestReward(QuestReward *v)
{
    questRewards.erase(v->id);
}

Ptr<Quest> StorageImpl::addQuest()
{
    return quests.createAtEnd();
}

void StorageImpl::deleteQuest(Quest *v)
{
    quests.erase(v->id);
}

Ptr<ScriptVariable> StorageImpl::addScriptVariable()
{
    return scriptVariables.createAtEnd();
}

void StorageImpl::deleteScriptVariable(ScriptVariable *v)
{
    scriptVariables.erase(v->id);
}

Ptr<Setting> StorageImpl::addSetting()
{
    return settings.createAtEnd();
}

void StorageImpl::deleteSetting(Setting *v)
{
    settings.erase(v->id);
}

Ptr<String> StorageImpl::addString()
{
    return strings.createAtEnd();
}

void StorageImpl::deleteString(String *v)
{
    strings.erase(v->id);
}

Ptr<Table> StorageImpl::addTable()
{
    return tables.createAtEnd();
}

void StorageImpl::deleteTable(Table *v)
{
    tables.erase(v->id);
}

Ptr<Weapon> StorageImpl::addWeapon()
{
    return weapons.createAtEnd();
}

void StorageImpl::deleteWeapon(Weapon *v)
{
    weapons.erase(v->id);
}

Ptr<IObject> StorageImpl::addRecord(IObject *parent)
{
    EObjectType type = parent->getType();
    switch (type)
    {
    case EObjectType::Building:
        return addBuilding();
    case EObjectType::ClanMechanoid:
        return addClanMechanoid(parent);
    case EObjectType::ClanReputation:
        return addClanReputation(parent);
    case EObjectType::Clan:
        return addClan();
    case EObjectType::ConfigurationEquipment:
        return addConfigurationEquipment(parent);
    case EObjectType::ConfigurationGood:
        return addConfigurationGood(parent);
    case EObjectType::ConfigurationProjectile:
        return addConfigurationProjectile(parent);
    case EObjectType::ConfigurationWeapon:
        return addConfigurationWeapon(parent);
    case EObjectType::Configuration:
        return addConfiguration();
    case EObjectType::Equipment:
        return addEquipment();
    case EObjectType::Glider:
        return addGlider();
    case EObjectType::Good:
        return addGood();
    case EObjectType::GroupMechanoid:
        return addGroupMechanoid(parent);
    case EObjectType::Group:
        return addGroup();
    case EObjectType::MapBuildingEquipment:
        return addMapBuildingEquipment(parent);
    case EObjectType::MapBuildingGlider:
        return addMapBuildingGlider(parent);
    case EObjectType::MapBuildingGood:
        return addMapBuildingGood(parent);
    case EObjectType::MapBuildingModificator:
        return addMapBuildingModificator(parent);
    case EObjectType::MapBuildingProjectile:
        return addMapBuildingProjectile(parent);
    case EObjectType::MapBuildingWeapon:
        return addMapBuildingWeapon(parent);
    case EObjectType::MapBuilding:
        return addMapBuilding(parent);
    case EObjectType::MapGood:
        return addMapGood(parent);
    case EObjectType::MapObject:
        return addMapObject(parent);
    case EObjectType::Map:
        return addMap();
    case EObjectType::MechanoidQuest:
        return addMechanoidQuest(parent);
    case EObjectType::Mechanoid:
        return addMechanoid();
    case EObjectType::ModificationClan:
        return addModificationClan(parent);
    case EObjectType::ModificationMap:
        return addModificationMap(parent);
    case EObjectType::ModificationMechanoid:
        return addModificationMechanoid(parent);
    case EObjectType::Modification:
        return addModification();
    case EObjectType::Modificator:
        return addModificator();
    case EObjectType::Object:
        return addObject();
    case EObjectType::Player:
        return addPlayer();
    case EObjectType::Projectile:
        return addProjectile();
    case EObjectType::QuestRewardEquipment:
        return addQuestRewardEquipment(parent);
    case EObjectType::QuestRewardGlider:
        return addQuestRewardGlider(parent);
    case EObjectType::QuestRewardGood:
        return addQuestRewardGood(parent);
    case EObjectType::QuestRewardModificator:
        return addQuestRewardModificator(parent);
    case EObjectType::QuestRewardProjectile:
        return addQuestRewardProjectile(parent);
    case EObjectType::QuestRewardReputation:
        return addQuestRewardReputation(parent);
    case EObjectType::QuestRewardWeapon:
        return addQuestRewardWeapon(parent);
    case EObjectType::QuestReward:
        return addQuestReward(parent);
    case EObjectType::Quest:
        return addQuest();
    case EObjectType::ScriptVariable:
        return addScriptVariable();
    case EObjectType::Setting:
        return addSetting();
    case EObjectType::String:
        return addString();
    case EObjectType::Table:
        return addTable();
    case EObjectType::Weapon:
        return addWeapon();
    default:
        return Ptr<IObject>(0);
    }
}

void StorageImpl::deleteRecord(IObject *data)
{
    EObjectType type = data->getType();
    switch (type)
    {
    case EObjectType::Building:
        deleteBuilding((Building *)data);
        break;
    case EObjectType::ClanMechanoid:
        deleteClanMechanoid((ClanMechanoid *)data);
        break;
    case EObjectType::ClanReputation:
        deleteClanReputation((ClanReputation *)data);
        break;
    case EObjectType::Clan:
        deleteClan((Clan *)data);
        break;
    case EObjectType::ConfigurationEquipment:
        deleteConfigurationEquipment((ConfigurationEquipment *)data);
        break;
    case EObjectType::ConfigurationGood:
        deleteConfigurationGood((ConfigurationGood *)data);
        break;
    case EObjectType::ConfigurationProjectile:
        deleteConfigurationProjectile((ConfigurationProjectile *)data);
        break;
    case EObjectType::ConfigurationWeapon:
        deleteConfigurationWeapon((ConfigurationWeapon *)data);
        break;
    case EObjectType::Configuration:
        deleteConfiguration((Configuration *)data);
        break;
    case EObjectType::Equipment:
        deleteEquipment((Equipment *)data);
        break;
    case EObjectType::Glider:
        deleteGlider((Glider *)data);
        break;
    case EObjectType::Good:
        deleteGood((Good *)data);
        break;
    case EObjectType::GroupMechanoid:
        deleteGroupMechanoid((GroupMechanoid *)data);
        break;
    case EObjectType::Group:
        deleteGroup((Group *)data);
        break;
    case EObjectType::MapBuildingEquipment:
        deleteMapBuildingEquipment((MapBuildingEquipment *)data);
        break;
    case EObjectType::MapBuildingGlider:
        deleteMapBuildingGlider((MapBuildingGlider *)data);
        break;
    case EObjectType::MapBuildingGood:
        deleteMapBuildingGood((MapBuildingGood *)data);
        break;
    case EObjectType::MapBuildingModificator:
        deleteMapBuildingModificator((MapBuildingModificator *)data);
        break;
    case EObjectType::MapBuildingProjectile:
        deleteMapBuildingProjectile((MapBuildingProjectile *)data);
        break;
    case EObjectType::MapBuildingWeapon:
        deleteMapBuildingWeapon((MapBuildingWeapon *)data);
        break;
    case EObjectType::MapBuilding:
        deleteMapBuilding((MapBuilding *)data);
        break;
    case EObjectType::MapGood:
        deleteMapGood((MapGood *)data);
        break;
    case EObjectType::MapObject:
        deleteMapObject((MapObject *)data);
        break;
    case EObjectType::Map:
        deleteMap((Map *)data);
        break;
    case EObjectType::MechanoidQuest:
        deleteMechanoidQuest((MechanoidQuest *)data);
        break;
    case EObjectType::Mechanoid:
        deleteMechanoid((Mechanoid *)data);
        break;
    case EObjectType::ModificationClan:
        deleteModificationClan((ModificationClan *)data);
        break;
    case EObjectType::ModificationMap:
        deleteModificationMap((ModificationMap *)data);
        break;
    case EObjectType::ModificationMechanoid:
        deleteModificationMechanoid((ModificationMechanoid *)data);
        break;
    case EObjectType::Modification:
        deleteModification((Modification *)data);
        break;
    case EObjectType::Modificator:
        deleteModificator((Modificator *)data);
        break;
    case EObjectType::Object:
        deleteObject((Object *)data);
        break;
    case EObjectType::Player:
        deletePlayer((Player *)data);
        break;
    case EObjectType::Projectile:
        deleteProjectile((Projectile *)data);
        break;
    case EObjectType::QuestRewardEquipment:
        deleteQuestRewardEquipment((QuestRewardEquipment *)data);
        break;
    case EObjectType::QuestRewardGlider:
        deleteQuestRewardGlider((QuestRewardGlider *)data);
        break;
    case EObjectType::QuestRewardGood:
        deleteQuestRewardGood((QuestRewardGood *)data);
        break;
    case EObjectType::QuestRewardModificator:
        deleteQuestRewardModificator((QuestRewardModificator *)data);
        break;
    case EObjectType::QuestRewardProjectile:
        deleteQuestRewardProjectile((QuestRewardProjectile *)data);
        break;
    case EObjectType::QuestRewardReputation:
        deleteQuestRewardReputation((QuestRewardReputation *)data);
        break;
    case EObjectType::QuestRewardWeapon:
        deleteQuestRewardWeapon((QuestRewardWeapon *)data);
        break;
    case EObjectType::QuestReward:
        deleteQuestReward((QuestReward *)data);
        break;
    case EObjectType::Quest:
        deleteQuest((Quest *)data);
        break;
    case EObjectType::ScriptVariable:
        deleteScriptVariable((ScriptVariable *)data);
        break;
    case EObjectType::Setting:
        deleteSetting((Setting *)data);
        break;
    case EObjectType::String:
        deleteString((String *)data);
        break;
    case EObjectType::Table:
        deleteTable((Table *)data);
        break;
    case EObjectType::Weapon:
        deleteWeapon((Weapon *)data);
        break;
    default:
        break;
    }
}

#ifdef USE_QT
void StorageImpl::printQtTreeView(QTreeWidgetItem *root) const
{
    QTreeWidgetItem *item;

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Buildings")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Building));
    auto buildings = getOrderedMap(EObjectType::Building);
    for (auto &building : buildings)
        building.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Clans")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Clan));
    auto clans = getOrderedMap(EObjectType::Clan);
    for (auto &clan : clans)
        clan.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Configurations")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Configuration));
    auto configurations = getOrderedMap(EObjectType::Configuration);
    for (auto &configuration : configurations)
        configuration.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Equipments")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Equipment));
    auto equipments = getOrderedMap(EObjectType::Equipment);
    for (auto &equipment : equipments)
        equipment.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Gliders")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Glider));
    auto gliders = getOrderedMap(EObjectType::Glider);
    for (auto &glider : gliders)
        glider.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Goods")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Good));
    auto goods = getOrderedMap(EObjectType::Good);
    for (auto &good : goods)
        good.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Groups")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Group));
    auto groups = getOrderedMap(EObjectType::Group);
    for (auto &group : groups)
        group.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Maps")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Map));
    auto maps = getOrderedMap(EObjectType::Map);
    for (auto &map : maps)
        map.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Mechanoids")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Mechanoid));
    auto mechanoids = getOrderedMap(EObjectType::Mechanoid);
    for (auto &mechanoid : mechanoids)
        mechanoid.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Modifications")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Modification));
    auto modifications = getOrderedMap(EObjectType::Modification);
    for (auto &modification : modifications)
        modification.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Modificators")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Modificator));
    auto modificators = getOrderedMap(EObjectType::Modificator);
    for (auto &modificator : modificators)
        modificator.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Objects")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Object));
    auto objects = getOrderedMap(EObjectType::Object);
    for (auto &object : objects)
        object.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Players")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Player));
    auto players = getOrderedMap(EObjectType::Player);
    for (auto &player : players)
        player.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Projectiles")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Projectile));
    auto projectiles = getOrderedMap(EObjectType::Projectile);
    for (auto &projectile : projectiles)
        projectile.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Quests")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Quest));
    auto quests = getOrderedMap(EObjectType::Quest);
    for (auto &quest : quests)
        quest.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Script Variables")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::ScriptVariable));
    auto scriptVariables = getOrderedMap(EObjectType::ScriptVariable);
    for (auto &scriptVariable : scriptVariables)
        scriptVariable.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Settings")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Setting));
    auto settings = getOrderedMap(EObjectType::Setting);
    for (auto &setting : settings)
        setting.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Strings")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::String));
    auto strings = getOrderedMap(EObjectType::String);
    for (auto &string : strings)
        string.second->printQtTreeView(item);

    item = new QTreeWidgetItem(root, QStringList(QCoreApplication::translate("DB", "Weapons")));
    item->setData(0, Qt::UserRole, static_cast<int>(EObjectType::Weapon));
    auto weapons = getOrderedMap(EObjectType::Weapon);
    for (auto &weapon : weapons)
        weapon.second->printQtTreeView(item);
}

QTreeWidgetItem *StorageImpl::addRecord(QTreeWidgetItem *item)
{
    EObjectType type = static_cast<EObjectType>(item->data(0, Qt::UserRole).toInt());
    IObject *parent = 0;
    auto parentItem = item->parent();
    if (parentItem)
        parent = (IObject *)parentItem->data(0, Qt::UserRole).toULongLong();
    switch (type)
    {
    case EObjectType::Building:
        return addBuilding()->printQtTreeView(item);
    case EObjectType::ClanMechanoid:
        return addClanMechanoid(parent)->printQtTreeView(item);
    case EObjectType::ClanReputation:
        return addClanReputation(parent)->printQtTreeView(item);
    case EObjectType::Clan:
        return addClan()->printQtTreeView(item);
    case EObjectType::ConfigurationEquipment:
        return addConfigurationEquipment(parent)->printQtTreeView(item);
    case EObjectType::ConfigurationGood:
        return addConfigurationGood(parent)->printQtTreeView(item);
    case EObjectType::ConfigurationProjectile:
        return addConfigurationProjectile(parent)->printQtTreeView(item);
    case EObjectType::ConfigurationWeapon:
        return addConfigurationWeapon(parent)->printQtTreeView(item);
    case EObjectType::Configuration:
        return addConfiguration()->printQtTreeView(item);
    case EObjectType::Equipment:
        return addEquipment()->printQtTreeView(item);
    case EObjectType::Glider:
        return addGlider()->printQtTreeView(item);
    case EObjectType::Good:
        return addGood()->printQtTreeView(item);
    case EObjectType::GroupMechanoid:
        return addGroupMechanoid(parent)->printQtTreeView(item);
    case EObjectType::Group:
        return addGroup()->printQtTreeView(item);
    case EObjectType::MapBuildingEquipment:
        return addMapBuildingEquipment(parent)->printQtTreeView(item);
    case EObjectType::MapBuildingGlider:
        return addMapBuildingGlider(parent)->printQtTreeView(item);
    case EObjectType::MapBuildingGood:
        return addMapBuildingGood(parent)->printQtTreeView(item);
    case EObjectType::MapBuildingModificator:
        return addMapBuildingModificator(parent)->printQtTreeView(item);
    case EObjectType::MapBuildingProjectile:
        return addMapBuildingProjectile(parent)->printQtTreeView(item);
    case EObjectType::MapBuildingWeapon:
        return addMapBuildingWeapon(parent)->printQtTreeView(item);
    case EObjectType::MapBuilding:
        return addMapBuilding(parent)->printQtTreeView(item);
    case EObjectType::MapGood:
        return addMapGood(parent)->printQtTreeView(item);
    case EObjectType::MapObject:
        return addMapObject(parent)->printQtTreeView(item);
    case EObjectType::Map:
        return addMap()->printQtTreeView(item);
    case EObjectType::MechanoidQuest:
        return addMechanoidQuest(parent)->printQtTreeView(item);
    case EObjectType::Mechanoid:
        return addMechanoid()->printQtTreeView(item);
    case EObjectType::ModificationClan:
        return addModificationClan(parent)->printQtTreeView(item);
    case EObjectType::ModificationMap:
        return addModificationMap(parent)->printQtTreeView(item);
    case EObjectType::ModificationMechanoid:
        return addModificationMechanoid(parent)->printQtTreeView(item);
    case EObjectType::Modification:
        return addModification()->printQtTreeView(item);
    case EObjectType::Modificator:
        return addModificator()->printQtTreeView(item);
    case EObjectType::Object:
        return addObject()->printQtTreeView(item);
    case EObjectType::Player:
        return addPlayer()->printQtTreeView(item);
    case EObjectType::Projectile:
        return addProjectile()->printQtTreeView(item);
    case EObjectType::QuestRewardEquipment:
        return addQuestRewardEquipment(parent)->printQtTreeView(item);
    case EObjectType::QuestRewardGlider:
        return addQuestRewardGlider(parent)->printQtTreeView(item);
    case EObjectType::QuestRewardGood:
        return addQuestRewardGood(parent)->printQtTreeView(item);
    case EObjectType::QuestRewardModificator:
        return addQuestRewardModificator(parent)->printQtTreeView(item);
    case EObjectType::QuestRewardProjectile:
        return addQuestRewardProjectile(parent)->printQtTreeView(item);
    case EObjectType::QuestRewardReputation:
        return addQuestRewardReputation(parent)->printQtTreeView(item);
    case EObjectType::QuestRewardWeapon:
        return addQuestRewardWeapon(parent)->printQtTreeView(item);
    case EObjectType::QuestReward:
        return addQuestReward(parent)->printQtTreeView(item);
    case EObjectType::Quest:
        return addQuest()->printQtTreeView(item);
    case EObjectType::ScriptVariable:
        return addScriptVariable()->printQtTreeView(item);
    case EObjectType::Setting:
        return addSetting()->printQtTreeView(item);
    case EObjectType::String:
        return addString()->printQtTreeView(item);
    case EObjectType::Table:
        return addTable()->printQtTreeView(item);
    case EObjectType::Weapon:
        return addWeapon()->printQtTreeView(item);
    default:
        return 0;
    }
}

void StorageImpl::deleteRecord(QTreeWidgetItem *item)
{
    IObject *data = (IObject *)item->data(0, Qt::UserRole).toULongLong();
    EObjectType type = data->getType();
    switch (type)
    {
    case EObjectType::Building:
        deleteBuilding((Building *)data);
        break;
    case EObjectType::ClanMechanoid:
        deleteClanMechanoid((ClanMechanoid *)data);
        break;
    case EObjectType::ClanReputation:
        deleteClanReputation((ClanReputation *)data);
        break;
    case EObjectType::Clan:
        deleteClan((Clan *)data);
        break;
    case EObjectType::ConfigurationEquipment:
        deleteConfigurationEquipment((ConfigurationEquipment *)data);
        break;
    case EObjectType::ConfigurationGood:
        deleteConfigurationGood((ConfigurationGood *)data);
        break;
    case EObjectType::ConfigurationProjectile:
        deleteConfigurationProjectile((ConfigurationProjectile *)data);
        break;
    case EObjectType::ConfigurationWeapon:
        deleteConfigurationWeapon((ConfigurationWeapon *)data);
        break;
    case EObjectType::Configuration:
        deleteConfiguration((Configuration *)data);
        break;
    case EObjectType::Equipment:
        deleteEquipment((Equipment *)data);
        break;
    case EObjectType::Glider:
        deleteGlider((Glider *)data);
        break;
    case EObjectType::Good:
        deleteGood((Good *)data);
        break;
    case EObjectType::GroupMechanoid:
        deleteGroupMechanoid((GroupMechanoid *)data);
        break;
    case EObjectType::Group:
        deleteGroup((Group *)data);
        break;
    case EObjectType::MapBuildingEquipment:
        deleteMapBuildingEquipment((MapBuildingEquipment *)data);
        break;
    case EObjectType::MapBuildingGlider:
        deleteMapBuildingGlider((MapBuildingGlider *)data);
        break;
    case EObjectType::MapBuildingGood:
        deleteMapBuildingGood((MapBuildingGood *)data);
        break;
    case EObjectType::MapBuildingModificator:
        deleteMapBuildingModificator((MapBuildingModificator *)data);
        break;
    case EObjectType::MapBuildingProjectile:
        deleteMapBuildingProjectile((MapBuildingProjectile *)data);
        break;
    case EObjectType::MapBuildingWeapon:
        deleteMapBuildingWeapon((MapBuildingWeapon *)data);
        break;
    case EObjectType::MapBuilding:
        deleteMapBuilding((MapBuilding *)data);
        break;
    case EObjectType::MapGood:
        deleteMapGood((MapGood *)data);
        break;
    case EObjectType::MapObject:
        deleteMapObject((MapObject *)data);
        break;
    case EObjectType::Map:
        deleteMap((Map *)data);
        break;
    case EObjectType::MechanoidQuest:
        deleteMechanoidQuest((MechanoidQuest *)data);
        break;
    case EObjectType::Mechanoid:
        deleteMechanoid((Mechanoid *)data);
        break;
    case EObjectType::ModificationClan:
        deleteModificationClan((ModificationClan *)data);
        break;
    case EObjectType::ModificationMap:
        deleteModificationMap((ModificationMap *)data);
        break;
    case EObjectType::ModificationMechanoid:
        deleteModificationMechanoid((ModificationMechanoid *)data);
        break;
    case EObjectType::Modification:
        deleteModification((Modification *)data);
        break;
    case EObjectType::Modificator:
        deleteModificator((Modificator *)data);
        break;
    case EObjectType::Object:
        deleteObject((Object *)data);
        break;
    case EObjectType::Player:
        deletePlayer((Player *)data);
        break;
    case EObjectType::Projectile:
        deleteProjectile((Projectile *)data);
        break;
    case EObjectType::QuestRewardEquipment:
        deleteQuestRewardEquipment((QuestRewardEquipment *)data);
        break;
    case EObjectType::QuestRewardGlider:
        deleteQuestRewardGlider((QuestRewardGlider *)data);
        break;
    case EObjectType::QuestRewardGood:
        deleteQuestRewardGood((QuestRewardGood *)data);
        break;
    case EObjectType::QuestRewardModificator:
        deleteQuestRewardModificator((QuestRewardModificator *)data);
        break;
    case EObjectType::QuestRewardProjectile:
        deleteQuestRewardProjectile((QuestRewardProjectile *)data);
        break;
    case EObjectType::QuestRewardReputation:
        deleteQuestRewardReputation((QuestRewardReputation *)data);
        break;
    case EObjectType::QuestRewardWeapon:
        deleteQuestRewardWeapon((QuestRewardWeapon *)data);
        break;
    case EObjectType::QuestReward:
        deleteQuestReward((QuestReward *)data);
        break;
    case EObjectType::Quest:
        deleteQuest((Quest *)data);
        break;
    case EObjectType::ScriptVariable:
        deleteScriptVariable((ScriptVariable *)data);
        break;
    case EObjectType::Setting:
        deleteSetting((Setting *)data);
        break;
    case EObjectType::String:
        deleteString((String *)data);
        break;
    case EObjectType::Table:
        deleteTable((Table *)data);
        break;
    case EObjectType::Weapon:
        deleteWeapon((Weapon *)data);
        break;
    default:
        break;
    }
    item->parent()->removeChild(item);
}
#endif

OrderedObjectMap StorageImpl::getOrderedMap(EObjectType type, std::function<bool(Ptr<IObject>)> f) const
{
    switch (type)
    {
    case EObjectType::Building:
        return ::getOrderedMap(buildings, f);
    case EObjectType::ClanMechanoid:
        return ::getOrderedMap(clanMechanoids, f);
    case EObjectType::ClanReputation:
        return ::getOrderedMap(clanReputations, f);
    case EObjectType::Clan:
        return ::getOrderedMap(clans, f);
    case EObjectType::ConfigurationEquipment:
        return ::getOrderedMap(configurationEquipments, f);
    case EObjectType::ConfigurationGood:
        return ::getOrderedMap(configurationGoods, f);
    case EObjectType::ConfigurationProjectile:
        return ::getOrderedMap(configurationProjectiles, f);
    case EObjectType::ConfigurationWeapon:
        return ::getOrderedMap(configurationWeapons, f);
    case EObjectType::Configuration:
        return ::getOrderedMap(configurations, f);
    case EObjectType::Equipment:
        return ::getOrderedMap(equipments, f);
    case EObjectType::Glider:
        return ::getOrderedMap(gliders, f);
    case EObjectType::Good:
        return ::getOrderedMap(goods, f);
    case EObjectType::GroupMechanoid:
        return ::getOrderedMap(groupMechanoids, f);
    case EObjectType::Group:
        return ::getOrderedMap(groups, f);
    case EObjectType::MapBuildingEquipment:
        return ::getOrderedMap(mapBuildingEquipments, f);
    case EObjectType::MapBuildingGlider:
        return ::getOrderedMap(mapBuildingGliders, f);
    case EObjectType::MapBuildingGood:
        return ::getOrderedMap(mapBuildingGoods, f);
    case EObjectType::MapBuildingModificator:
        return ::getOrderedMap(mapBuildingModificators, f);
    case EObjectType::MapBuildingProjectile:
        return ::getOrderedMap(mapBuildingProjectiles, f);
    case EObjectType::MapBuildingWeapon:
        return ::getOrderedMap(mapBuildingWeapons, f);
    case EObjectType::MapBuilding:
        return ::getOrderedMap(mapBuildings, f);
    case EObjectType::MapGood:
        return ::getOrderedMap(mapGoods, f);
    case EObjectType::MapObject:
        return ::getOrderedMap(mapObjects, f);
    case EObjectType::Map:
        return ::getOrderedMap(maps, f);
    case EObjectType::MechanoidQuest:
        return ::getOrderedMap(mechanoidQuests, f);
    case EObjectType::Mechanoid:
        return ::getOrderedMap(mechanoids, f);
    case EObjectType::ModificationClan:
        return ::getOrderedMap(modificationClans, f);
    case EObjectType::ModificationMap:
        return ::getOrderedMap(modificationMaps, f);
    case EObjectType::ModificationMechanoid:
        return ::getOrderedMap(modificationMechanoids, f);
    case EObjectType::Modification:
        return ::getOrderedMap(modifications, f);
    case EObjectType::Modificator:
        return ::getOrderedMap(modificators, f);
    case EObjectType::Object:
        return ::getOrderedMap(objects, f);
    case EObjectType::Player:
        return ::getOrderedMap(players, f);
    case EObjectType::Projectile:
        return ::getOrderedMap(projectiles, f);
    case EObjectType::QuestRewardEquipment:
        return ::getOrderedMap(questRewardEquipments, f);
    case EObjectType::QuestRewardGlider:
        return ::getOrderedMap(questRewardGliders, f);
    case EObjectType::QuestRewardGood:
        return ::getOrderedMap(questRewardGoods, f);
    case EObjectType::QuestRewardModificator:
        return ::getOrderedMap(questRewardModificators, f);
    case EObjectType::QuestRewardProjectile:
        return ::getOrderedMap(questRewardProjectiles, f);
    case EObjectType::QuestRewardReputation:
        return ::getOrderedMap(questRewardReputations, f);
    case EObjectType::QuestRewardWeapon:
        return ::getOrderedMap(questRewardWeapons, f);
    case EObjectType::QuestReward:
        return ::getOrderedMap(questRewards, f);
    case EObjectType::Quest:
        return ::getOrderedMap(quests, f);
    case EObjectType::ScriptVariable:
        return ::getOrderedMap(scriptVariables, f);
    case EObjectType::Setting:
        return ::getOrderedMap(settings, f);
    case EObjectType::String:
        return ::getOrderedMap(strings, f);
    case EObjectType::Table:
        return ::getOrderedMap(tables, f);
    case EObjectType::Weapon:
        return ::getOrderedMap(weapons, f);
    default:
        return OrderedObjectMap();
    }
}

