/* DO NOT EDIT! This is an autogenerated file. */

Building::Building()
{
}

Building::Building(const Building &rhs)
{
    copyFrom(rhs);
}

Building &Building::operator=(const Building &rhs)
{
    copyFrom(rhs);
    return *this;
}

Building::~Building()
{
}

EObjectType Building::getType() const
{
    return object_type;
}

Text Building::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(scale);
    case 4:
        return to_string(scale_x);
    case 5:
        return to_string(scale_y);
    case 6:
        return to_string(scale_z);
    default:
        return "";
    };
    return "";
}

void Building::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 2:
        this->resource = to_string(text);
        break;
    case 3:
        this->scale = std::stof(to_string(text));
        break;
    case 4:
        this->scale_x = std::stof(to_string(text));
        break;
    case 5:
        this->scale_y = std::stof(to_string(text));
        break;
    case 6:
        this->scale_z = std::stof(to_string(text));
        break;
    default:
        break;
    };
}

void Building::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    default:
        break;
    };
}

Ptr<TreeItem> Building::printTree() const
{
    return createTreeItem();
}

Text Building::getName() const
{
    Text s;
    s = text_id;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Building::operator==(const Building &rhs) const
{
    return
        text_id == rhs.text_id &&
        resource == rhs.resource &&
        scale == rhs.scale &&
        scale_x == rhs.scale_x &&
        scale_y == rhs.scale_y &&
        scale_z == rhs.scale_z &&
        1;
}

void Building::copyFrom(const Building &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    resource = rhs.resource;
    scale = rhs.scale;
    scale_x = rhs.scale_x;
    scale_y = rhs.scale_y;
    scale_z = rhs.scale_z;
}

const char *Building::getSql()
{
    return
    " \
create table \"Buildings\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"scale\" REAL DEFAULT \"1\", \
\"scale_x\" REAL DEFAULT \"1\", \
\"scale_y\" REAL DEFAULT \"1\", \
\"scale_z\" REAL DEFAULT \"1\", \
PRIMARY KEY (\"id\") \
); \
    ";
}

Clan::Clan()
{
    mechanoids = std::make_shared<CTable<Mechanoid>>();
    reputations = std::make_shared<CTable<ClanReputation>>();
}

Clan::Clan(const Clan &rhs)
{
    copyFrom(rhs);
}

Clan &Clan::operator=(const Clan &rhs)
{
    copyFrom(rhs);
    return *this;
}

Clan::~Clan()
{
}

EObjectType Clan::getType() const
{
    return object_type;
}

Text Clan::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(member_name);
    case 5:
        return to_string(modification);
    case 6:
        return to_string(bonusexp);
    case 7:
        return to_string(bonusrepair);
    case 8:
        return to_string(bonustrade);
    case 9:
        return to_string(helpness);
    case 10:
        return to_string(Volatile);
    case 11:
        return to_string(noblivion);
    case 12:
        return to_string(playereffect);
    case 13:
        return to_string(color);
    default:
        return "";
    };
    return "";
}

void Clan::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 2:
        this->resource = to_string(text);
        break;
    case 6:
        this->bonusexp = std::stoi(to_string(text));
        break;
    case 7:
        this->bonusrepair = std::stoi(to_string(text));
        break;
    case 8:
        this->bonustrade = std::stoi(to_string(text));
        break;
    case 9:
        this->helpness = std::stoi(to_string(text));
        break;
    case 10:
        this->Volatile = std::stof(to_string(text));
        break;
    case 11:
        this->noblivion = std::stof(to_string(text));
        break;
    case 12:
        this->playereffect = std::stof(to_string(text));
        break;
    case 13:
        this->color = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void Clan::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 3:
        name = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 4:
        member_name = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 5:
        modification = std::static_pointer_cast<Modification>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> Clan::printTree() const
{
    auto item = createTreeItem();

    Ptr<TreeItem> root;
    Ptr<TreeItem> tmp;

    root = std::make_shared<TreeItem>();
    root->name = "Mechanoids";
    root->type = EObjectType::Mechanoid;
    root->parent = item.get();
    for (auto &v : *mechanoids)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Reputations";
    root->type = EObjectType::ClanReputation;
    root->parent = item.get();
    for (auto &v : *reputations)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    return item;
}

Text Clan::getName() const
{
    Text s;
    s = to_string(name);
    if (!s.empty())
        return s;
    s = text_id;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Clan::operator==(const Clan &rhs) const
{
    return
        text_id == rhs.text_id &&
        resource == rhs.resource &&
        name == rhs.name &&
        member_name == rhs.member_name &&
        modification == rhs.modification &&
        bonusexp == rhs.bonusexp &&
        bonusrepair == rhs.bonusrepair &&
        bonustrade == rhs.bonustrade &&
        helpness == rhs.helpness &&
        Volatile == rhs.Volatile &&
        noblivion == rhs.noblivion &&
        playereffect == rhs.playereffect &&
        color == rhs.color &&
        1;
}

void Clan::copyFrom(const Clan &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    resource = rhs.resource;
    name = rhs.name;
    member_name = rhs.member_name;
    modification = rhs.modification;
    bonusexp = rhs.bonusexp;
    bonusrepair = rhs.bonusrepair;
    bonustrade = rhs.bonustrade;
    helpness = rhs.helpness;
    Volatile = rhs.Volatile;
    noblivion = rhs.noblivion;
    playereffect = rhs.playereffect;
    color = rhs.color;

    mechanoids = std::make_shared<CTable<Mechanoid>>(*rhs.mechanoids);
    reputations = std::make_shared<CTable<ClanReputation>>(*rhs.reputations);
}

const char *Clan::getSql()
{
    return
    " \
create table \"Clans\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
\"member_name_id\" INTEGER, \
\"modification_id\" INTEGER, \
\"bonusexp\" INTEGER, \
\"bonusrepair\" INTEGER, \
\"bonustrade\" INTEGER, \
\"helpness\" INTEGER, \
\"Volatile\" REAL, \
\"noblivion\" REAL, \
\"playereffect\" REAL, \
\"color\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\"), \
FOREIGN KEY (\"member_name_id\") REFERENCES \"Strings\" (\"id\"), \
FOREIGN KEY (\"modification_id\") REFERENCES \"Modifications\" (\"id\") \
); \
    ";
}

ClanReputation::ClanReputation()
{
}

ClanReputation::ClanReputation(const ClanReputation &rhs)
{
    copyFrom(rhs);
}

ClanReputation &ClanReputation::operator=(const ClanReputation &rhs)
{
    copyFrom(rhs);
    return *this;
}

ClanReputation::~ClanReputation()
{
}

EObjectType ClanReputation::getType() const
{
    return object_type;
}

Text ClanReputation::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(clan1);
    case 1:
        return to_string(clan2);
    case 2:
        return to_string(reputation);
    default:
        return "";
    };
    return "";
}

void ClanReputation::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->reputation = std::stof(to_string(text));
        break;
    default:
        break;
    };
}

void ClanReputation::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        clan1 = std::static_pointer_cast<Clan>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        clan2 = std::static_pointer_cast<Clan>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> ClanReputation::printTree() const
{
    return createTreeItem();
}

Text ClanReputation::getName() const
{
    Text s;
    s = 
            clan1->getId() < clan2->getId() ?
            (to_wstring(clan1) + L" - " + to_wstring(clan2)) :
            (to_wstring(clan2) + L" - " + to_wstring(clan1));
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool ClanReputation::operator==(const ClanReputation &rhs) const
{
    return
        clan1 == rhs.clan1 &&
        clan2 == rhs.clan2 &&
        reputation == rhs.reputation &&
        1;
}

void ClanReputation::copyFrom(const ClanReputation &rhs)
{
    clan1 = rhs.clan1;
    clan2 = rhs.clan2;
    reputation = rhs.reputation;
}

const char *ClanReputation::getSql()
{
    return
    " \
create table \"ClanReputations\" ( \
\"clan1_id\" INTEGER, \
\"clan2_id\" INTEGER, \
\"reputation\" REAL, \
FOREIGN KEY (\"clan1_id\") REFERENCES \"Clans\" (\"id\"), \
FOREIGN KEY (\"clan2_id\") REFERENCES \"Clans\" (\"id\") \
); \
    ";
}

Configuration::Configuration()
{
    equipments = std::make_shared<CTable<ConfigurationEquipment>>();
    goods = std::make_shared<CTable<ConfigurationGood>>();
    projectiles = std::make_shared<CTable<ConfigurationProjectile>>();
    weapons = std::make_shared<CTable<ConfigurationWeapon>>();
}

Configuration::Configuration(const Configuration &rhs)
{
    copyFrom(rhs);
}

Configuration &Configuration::operator=(const Configuration &rhs)
{
    copyFrom(rhs);
    return *this;
}

Configuration::~Configuration()
{
}

EObjectType Configuration::getType() const
{
    return object_type;
}

Text Configuration::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(name);
    case 3:
        return to_string(glider);
    default:
        return "";
    };
    return "";
}

void Configuration::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    default:
        break;
    };
}

void Configuration::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 2:
        name = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 3:
        glider = std::static_pointer_cast<Glider>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> Configuration::printTree() const
{
    auto item = createTreeItem();

    Ptr<TreeItem> root;
    Ptr<TreeItem> tmp;

    root = std::make_shared<TreeItem>();
    root->name = "Equipments";
    root->type = EObjectType::ConfigurationEquipment;
    root->parent = item.get();
    for (auto &v : *equipments)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Goods";
    root->type = EObjectType::ConfigurationGood;
    root->parent = item.get();
    for (auto &v : *goods)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Projectiles";
    root->type = EObjectType::ConfigurationProjectile;
    root->parent = item.get();
    for (auto &v : *projectiles)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Weapons";
    root->type = EObjectType::ConfigurationWeapon;
    root->parent = item.get();
    for (auto &v : *weapons)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    return item;
}

Text Configuration::getName() const
{
    Text s;
    s = to_string(name);
    if (!s.empty())
        return s;
    s = text_id;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Configuration::operator==(const Configuration &rhs) const
{
    return
        text_id == rhs.text_id &&
        name == rhs.name &&
        glider == rhs.glider &&
        1;
}

void Configuration::copyFrom(const Configuration &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    name = rhs.name;
    glider = rhs.glider;

    equipments = std::make_shared<CTable<ConfigurationEquipment>>(*rhs.equipments);
    goods = std::make_shared<CTable<ConfigurationGood>>(*rhs.goods);
    projectiles = std::make_shared<CTable<ConfigurationProjectile>>(*rhs.projectiles);
    weapons = std::make_shared<CTable<ConfigurationWeapon>>(*rhs.weapons);
}

const char *Configuration::getSql()
{
    return
    " \
create table \"Configurations\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"name_id\" INTEGER, \
\"glider_id\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\"), \
FOREIGN KEY (\"glider_id\") REFERENCES \"Gliders\" (\"id\") \
); \
    ";
}

ConfigurationEquipment::ConfigurationEquipment()
{
}

ConfigurationEquipment::ConfigurationEquipment(const ConfigurationEquipment &rhs)
{
    copyFrom(rhs);
}

ConfigurationEquipment &ConfigurationEquipment::operator=(const ConfigurationEquipment &rhs)
{
    copyFrom(rhs);
    return *this;
}

ConfigurationEquipment::~ConfigurationEquipment()
{
}

EObjectType ConfigurationEquipment::getType() const
{
    return object_type;
}

Text ConfigurationEquipment::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(configuration);
    case 1:
        return to_string(equipment);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void ConfigurationEquipment::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void ConfigurationEquipment::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        configuration = std::static_pointer_cast<Configuration>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        equipment = std::static_pointer_cast<Equipment>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> ConfigurationEquipment::printTree() const
{
    return createTreeItem();
}

Text ConfigurationEquipment::getName() const
{
    Text s;
    s = to_string(configuration);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool ConfigurationEquipment::operator==(const ConfigurationEquipment &rhs) const
{
    return
        configuration == rhs.configuration &&
        equipment == rhs.equipment &&
        quantity == rhs.quantity &&
        1;
}

Ptr<Configuration> ConfigurationEquipment::operator->() const
{
    if (configuration)
        return configuration;
    throw EXCEPTION("Value is missing");
}

void ConfigurationEquipment::copyFrom(const ConfigurationEquipment &rhs)
{
    configuration = rhs.configuration;
    equipment = rhs.equipment;
    quantity = rhs.quantity;
}

const char *ConfigurationEquipment::getSql()
{
    return
    " \
create table \"ConfigurationEquipments\" ( \
\"configuration_id\" INTEGER, \
\"equipment_id\" INTEGER, \
\"quantity\" INTEGER, \
FOREIGN KEY (\"configuration_id\") REFERENCES \"Configurations\" (\"id\"), \
FOREIGN KEY (\"equipment_id\") REFERENCES \"Equipments\" (\"id\") \
); \
    ";
}

ConfigurationGood::ConfigurationGood()
{
}

ConfigurationGood::ConfigurationGood(const ConfigurationGood &rhs)
{
    copyFrom(rhs);
}

ConfigurationGood &ConfigurationGood::operator=(const ConfigurationGood &rhs)
{
    copyFrom(rhs);
    return *this;
}

ConfigurationGood::~ConfigurationGood()
{
}

EObjectType ConfigurationGood::getType() const
{
    return object_type;
}

Text ConfigurationGood::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(configuration);
    case 1:
        return to_string(good);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void ConfigurationGood::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void ConfigurationGood::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        configuration = std::static_pointer_cast<Configuration>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        good = std::static_pointer_cast<Good>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> ConfigurationGood::printTree() const
{
    return createTreeItem();
}

Text ConfigurationGood::getName() const
{
    Text s;
    s = to_string(configuration);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool ConfigurationGood::operator==(const ConfigurationGood &rhs) const
{
    return
        configuration == rhs.configuration &&
        good == rhs.good &&
        quantity == rhs.quantity &&
        1;
}

Ptr<Configuration> ConfigurationGood::operator->() const
{
    if (configuration)
        return configuration;
    throw EXCEPTION("Value is missing");
}

void ConfigurationGood::copyFrom(const ConfigurationGood &rhs)
{
    configuration = rhs.configuration;
    good = rhs.good;
    quantity = rhs.quantity;
}

const char *ConfigurationGood::getSql()
{
    return
    " \
create table \"ConfigurationGoods\" ( \
\"configuration_id\" INTEGER, \
\"good_id\" INTEGER, \
\"quantity\" INTEGER, \
FOREIGN KEY (\"configuration_id\") REFERENCES \"Configurations\" (\"id\"), \
FOREIGN KEY (\"good_id\") REFERENCES \"Goods\" (\"id\") \
); \
    ";
}

ConfigurationProjectile::ConfigurationProjectile()
{
}

ConfigurationProjectile::ConfigurationProjectile(const ConfigurationProjectile &rhs)
{
    copyFrom(rhs);
}

ConfigurationProjectile &ConfigurationProjectile::operator=(const ConfigurationProjectile &rhs)
{
    copyFrom(rhs);
    return *this;
}

ConfigurationProjectile::~ConfigurationProjectile()
{
}

EObjectType ConfigurationProjectile::getType() const
{
    return object_type;
}

Text ConfigurationProjectile::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(configuration);
    case 1:
        return to_string(projectile);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void ConfigurationProjectile::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void ConfigurationProjectile::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        configuration = std::static_pointer_cast<Configuration>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        projectile = std::static_pointer_cast<Projectile>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> ConfigurationProjectile::printTree() const
{
    return createTreeItem();
}

Text ConfigurationProjectile::getName() const
{
    Text s;
    s = to_string(configuration);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool ConfigurationProjectile::operator==(const ConfigurationProjectile &rhs) const
{
    return
        configuration == rhs.configuration &&
        projectile == rhs.projectile &&
        quantity == rhs.quantity &&
        1;
}

Ptr<Configuration> ConfigurationProjectile::operator->() const
{
    if (configuration)
        return configuration;
    throw EXCEPTION("Value is missing");
}

void ConfigurationProjectile::copyFrom(const ConfigurationProjectile &rhs)
{
    configuration = rhs.configuration;
    projectile = rhs.projectile;
    quantity = rhs.quantity;
}

const char *ConfigurationProjectile::getSql()
{
    return
    " \
create table \"ConfigurationProjectiles\" ( \
\"configuration_id\" INTEGER, \
\"projectile_id\" INTEGER, \
\"quantity\" INTEGER, \
FOREIGN KEY (\"configuration_id\") REFERENCES \"Configurations\" (\"id\"), \
FOREIGN KEY (\"projectile_id\") REFERENCES \"Projectiles\" (\"id\") \
); \
    ";
}

ConfigurationWeapon::ConfigurationWeapon()
{
}

ConfigurationWeapon::ConfigurationWeapon(const ConfigurationWeapon &rhs)
{
    copyFrom(rhs);
}

ConfigurationWeapon &ConfigurationWeapon::operator=(const ConfigurationWeapon &rhs)
{
    copyFrom(rhs);
    return *this;
}

ConfigurationWeapon::~ConfigurationWeapon()
{
}

EObjectType ConfigurationWeapon::getType() const
{
    return object_type;
}

Text ConfigurationWeapon::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(configuration);
    case 1:
        return to_string(weapon);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void ConfigurationWeapon::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void ConfigurationWeapon::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        configuration = std::static_pointer_cast<Configuration>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        weapon = std::static_pointer_cast<Weapon>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> ConfigurationWeapon::printTree() const
{
    return createTreeItem();
}

Text ConfigurationWeapon::getName() const
{
    Text s;
    s = to_string(configuration);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool ConfigurationWeapon::operator==(const ConfigurationWeapon &rhs) const
{
    return
        configuration == rhs.configuration &&
        weapon == rhs.weapon &&
        quantity == rhs.quantity &&
        1;
}

Ptr<Configuration> ConfigurationWeapon::operator->() const
{
    if (configuration)
        return configuration;
    throw EXCEPTION("Value is missing");
}

void ConfigurationWeapon::copyFrom(const ConfigurationWeapon &rhs)
{
    configuration = rhs.configuration;
    weapon = rhs.weapon;
    quantity = rhs.quantity;
}

const char *ConfigurationWeapon::getSql()
{
    return
    " \
create table \"ConfigurationWeapons\" ( \
\"configuration_id\" INTEGER, \
\"weapon_id\" INTEGER, \
\"quantity\" INTEGER, \
FOREIGN KEY (\"configuration_id\") REFERENCES \"Configurations\" (\"id\"), \
FOREIGN KEY (\"weapon_id\") REFERENCES \"Weapons\" (\"id\") \
); \
    ";
}

Equipment::Equipment()
{
}

Equipment::Equipment(const Equipment &rhs)
{
    copyFrom(rhs);
}

Equipment &Equipment::operator=(const Equipment &rhs)
{
    copyFrom(rhs);
    return *this;
}

Equipment::~Equipment()
{
}

EObjectType Equipment::getType() const
{
    return object_type;
}

Text Equipment::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(type);
    case 5:
        return to_string(standard);
    case 6:
        return to_string(weight);
    case 7:
        return to_string(durability);
    case 8:
        return to_string(power);
    case 9:
        return to_string(value1);
    case 10:
        return to_string(value2);
    case 11:
        return to_string(value3);
    case 12:
        return to_string(manual);
    case 13:
        return to_string(price);
    case 14:
        return to_string(notrade);
    default:
        return "";
    };
    return "";
}

void Equipment::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 2:
        this->resource = to_string(text);
        break;
    case 4:
        this->type = std::stoi(to_string(text));
        break;
    case 5:
        this->standard = std::stoi(to_string(text));
        break;
    case 6:
        this->weight = std::stof(to_string(text));
        break;
    case 7:
        this->durability = std::stof(to_string(text));
        break;
    case 8:
        this->power = std::stof(to_string(text));
        break;
    case 9:
        this->value1 = std::stof(to_string(text));
        break;
    case 10:
        this->value2 = std::stof(to_string(text));
        break;
    case 11:
        this->value3 = std::stof(to_string(text));
        break;
    case 12:
        this->manual = std::stoi(to_string(text));
        break;
    case 13:
        this->price = std::stof(to_string(text));
        break;
    case 14:
        this->notrade = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void Equipment::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 3:
        name = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> Equipment::printTree() const
{
    return createTreeItem();
}

Text Equipment::getName() const
{
    Text s;
    s = to_string(name);
    if (!s.empty())
        return s;
    s = text_id;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Equipment::operator==(const Equipment &rhs) const
{
    return
        text_id == rhs.text_id &&
        resource == rhs.resource &&
        name == rhs.name &&
        type == rhs.type &&
        standard == rhs.standard &&
        weight == rhs.weight &&
        durability == rhs.durability &&
        power == rhs.power &&
        value1 == rhs.value1 &&
        value2 == rhs.value2 &&
        value3 == rhs.value3 &&
        manual == rhs.manual &&
        price == rhs.price &&
        notrade == rhs.notrade &&
        1;
}

void Equipment::copyFrom(const Equipment &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    resource = rhs.resource;
    name = rhs.name;
    type = rhs.type;
    standard = rhs.standard;
    weight = rhs.weight;
    durability = rhs.durability;
    power = rhs.power;
    value1 = rhs.value1;
    value2 = rhs.value2;
    value3 = rhs.value3;
    manual = rhs.manual;
    price = rhs.price;
    notrade = rhs.notrade;
}

const char *Equipment::getSql()
{
    return
    " \
create table \"Equipments\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
\"type\" INTEGER, \
\"standard\" INTEGER, \
\"weight\" REAL, \
\"durability\" REAL, \
\"power\" REAL, \
\"value1\" REAL, \
\"value2\" REAL, \
\"value3\" REAL, \
\"manual\" INTEGER, \
\"price\" REAL, \
\"notrade\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

Glider::Glider()
{
}

Glider::Glider(const Glider &rhs)
{
    copyFrom(rhs);
}

Glider &Glider::operator=(const Glider &rhs)
{
    copyFrom(rhs);
    return *this;
}

Glider::~Glider()
{
}

EObjectType Glider::getType() const
{
    return object_type;
}

Text Glider::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(standard);
    case 5:
        return to_string(weight);
    case 6:
        return to_string(maxweight);
    case 7:
        return to_string(armor);
    case 8:
        return to_string(price);
    case 9:
        return to_string(restore);
    case 10:
        return to_string(power);
    case 11:
        return to_string(special);
    case 12:
        return to_string(rotatespeed);
    case 13:
        return to_string(resfront);
    case 14:
        return to_string(resstop);
    case 15:
        return to_string(resside);
    case 16:
        return to_string(stabfront);
    case 17:
        return to_string(stabside);
    case 18:
        return to_string(careen);
    case 19:
        return to_string(delta_t);
    case 20:
        return to_string(turbulence);
    default:
        return "";
    };
    return "";
}

void Glider::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 2:
        this->resource = to_string(text);
        break;
    case 4:
        this->standard = std::stoi(to_string(text));
        break;
    case 5:
        this->weight = std::stof(to_string(text));
        break;
    case 6:
        this->maxweight = std::stof(to_string(text));
        break;
    case 7:
        this->armor = std::stof(to_string(text));
        break;
    case 8:
        this->price = std::stof(to_string(text));
        break;
    case 9:
        this->restore = std::stof(to_string(text));
        break;
    case 10:
        this->power = std::stof(to_string(text));
        break;
    case 11:
        this->special = std::stoi(to_string(text));
        break;
    case 12:
        this->rotatespeed = std::stof(to_string(text));
        break;
    case 13:
        this->resfront = std::stof(to_string(text));
        break;
    case 14:
        this->resstop = std::stof(to_string(text));
        break;
    case 15:
        this->resside = std::stof(to_string(text));
        break;
    case 16:
        this->stabfront = std::stof(to_string(text));
        break;
    case 17:
        this->stabside = std::stof(to_string(text));
        break;
    case 18:
        this->careen = std::stof(to_string(text));
        break;
    case 19:
        this->delta_t = std::stof(to_string(text));
        break;
    case 20:
        this->turbulence = std::stof(to_string(text));
        break;
    default:
        break;
    };
}

void Glider::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 3:
        name = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> Glider::printTree() const
{
    return createTreeItem();
}

Text Glider::getName() const
{
    Text s;
    s = to_string(name);
    if (!s.empty())
        return s;
    s = text_id;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Glider::operator==(const Glider &rhs) const
{
    return
        text_id == rhs.text_id &&
        resource == rhs.resource &&
        name == rhs.name &&
        standard == rhs.standard &&
        weight == rhs.weight &&
        maxweight == rhs.maxweight &&
        armor == rhs.armor &&
        price == rhs.price &&
        restore == rhs.restore &&
        power == rhs.power &&
        special == rhs.special &&
        rotatespeed == rhs.rotatespeed &&
        resfront == rhs.resfront &&
        resstop == rhs.resstop &&
        resside == rhs.resside &&
        stabfront == rhs.stabfront &&
        stabside == rhs.stabside &&
        careen == rhs.careen &&
        delta_t == rhs.delta_t &&
        turbulence == rhs.turbulence &&
        1;
}

void Glider::copyFrom(const Glider &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    resource = rhs.resource;
    name = rhs.name;
    standard = rhs.standard;
    weight = rhs.weight;
    maxweight = rhs.maxweight;
    armor = rhs.armor;
    price = rhs.price;
    restore = rhs.restore;
    power = rhs.power;
    special = rhs.special;
    rotatespeed = rhs.rotatespeed;
    resfront = rhs.resfront;
    resstop = rhs.resstop;
    resside = rhs.resside;
    stabfront = rhs.stabfront;
    stabside = rhs.stabside;
    careen = rhs.careen;
    delta_t = rhs.delta_t;
    turbulence = rhs.turbulence;
}

const char *Glider::getSql()
{
    return
    " \
create table \"Gliders\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
\"standard\" INTEGER, \
\"weight\" REAL, \
\"maxweight\" REAL, \
\"armor\" REAL, \
\"price\" REAL, \
\"restore\" REAL, \
\"power\" REAL, \
\"special\" INTEGER, \
\"rotatespeed\" REAL, \
\"resfront\" REAL, \
\"resstop\" REAL, \
\"resside\" REAL, \
\"stabfront\" REAL, \
\"stabside\" REAL, \
\"careen\" REAL, \
\"delta_t\" REAL, \
\"turbulence\" REAL, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

Good::Good()
{
}

Good::Good(const Good &rhs)
{
    copyFrom(rhs);
}

Good &Good::operator=(const Good &rhs)
{
    copyFrom(rhs);
    return *this;
}

Good::~Good()
{
}

EObjectType Good::getType() const
{
    return object_type;
}

Text Good::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(resource_drop);
    case 4:
        return to_string(name);
    case 5:
        return to_string(price);
    case 6:
        return to_string(weight);
    case 7:
        return to_string(notrade);
    case 8:
        return to_string(type);
    default:
        return "";
    };
    return "";
}

void Good::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 2:
        this->resource = to_string(text);
        break;
    case 3:
        this->resource_drop = to_string(text);
        break;
    case 5:
        this->price = std::stof(to_string(text));
        break;
    case 6:
        this->weight = std::stof(to_string(text));
        break;
    case 7:
        this->notrade = std::stoi(to_string(text));
        break;
    case 8:
        this->type = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void Good::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 4:
        name = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> Good::printTree() const
{
    return createTreeItem();
}

Text Good::getName() const
{
    Text s;
    s = to_string(name);
    if (!s.empty())
        return s;
    s = text_id;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Good::operator==(const Good &rhs) const
{
    return
        text_id == rhs.text_id &&
        resource == rhs.resource &&
        resource_drop == rhs.resource_drop &&
        name == rhs.name &&
        price == rhs.price &&
        weight == rhs.weight &&
        notrade == rhs.notrade &&
        type == rhs.type &&
        1;
}

void Good::copyFrom(const Good &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    resource = rhs.resource;
    resource_drop = rhs.resource_drop;
    name = rhs.name;
    price = rhs.price;
    weight = rhs.weight;
    notrade = rhs.notrade;
    type = rhs.type;
}

const char *Good::getSql()
{
    return
    " \
create table \"Goods\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"resource_drop\" TEXT, \
\"name_id\" INTEGER, \
\"price\" REAL, \
\"weight\" REAL, \
\"notrade\" INTEGER, \
\"type\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

Group::Group()
{
    mechanoids = std::make_shared<CTable<GroupMechanoid>>();
}

Group::Group(const Group &rhs)
{
    copyFrom(rhs);
}

Group &Group::operator=(const Group &rhs)
{
    copyFrom(rhs);
    return *this;
}

Group::~Group()
{
}

EObjectType Group::getType() const
{
    return object_type;
}

Text Group::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(name);
    default:
        return "";
    };
    return "";
}

void Group::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    default:
        break;
    };
}

void Group::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 2:
        name = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> Group::printTree() const
{
    auto item = createTreeItem();

    Ptr<TreeItem> root;
    Ptr<TreeItem> tmp;

    root = std::make_shared<TreeItem>();
    root->name = "Mechanoids";
    root->type = EObjectType::GroupMechanoid;
    root->parent = item.get();
    for (auto &v : *mechanoids)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    return item;
}

Text Group::getName() const
{
    Text s;
    s = to_string(name);
    if (!s.empty())
        return s;
    s = text_id;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Group::operator==(const Group &rhs) const
{
    return
        text_id == rhs.text_id &&
        name == rhs.name &&
        1;
}

void Group::copyFrom(const Group &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    name = rhs.name;

    mechanoids = std::make_shared<CTable<GroupMechanoid>>(*rhs.mechanoids);
}

const char *Group::getSql()
{
    return
    " \
create table \"Groups\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"name_id\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

GroupMechanoid::GroupMechanoid()
{
}

GroupMechanoid::GroupMechanoid(const GroupMechanoid &rhs)
{
    copyFrom(rhs);
}

GroupMechanoid &GroupMechanoid::operator=(const GroupMechanoid &rhs)
{
    copyFrom(rhs);
    return *this;
}

GroupMechanoid::~GroupMechanoid()
{
}

EObjectType GroupMechanoid::getType() const
{
    return object_type;
}

Text GroupMechanoid::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(group);
    case 1:
        return to_string(mechanoid);
    default:
        return "";
    };
    return "";
}

void GroupMechanoid::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    default:
        break;
    };
}

void GroupMechanoid::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        group = std::static_pointer_cast<Group>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        mechanoid = std::static_pointer_cast<Mechanoid>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> GroupMechanoid::printTree() const
{
    return createTreeItem();
}

Text GroupMechanoid::getName() const
{
    Text s;
    s = to_string(group);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool GroupMechanoid::operator==(const GroupMechanoid &rhs) const
{
    return
        group == rhs.group &&
        mechanoid == rhs.mechanoid &&
        1;
}

Ptr<Group> GroupMechanoid::operator->() const
{
    if (group)
        return group;
    throw EXCEPTION("Value is missing");
}

void GroupMechanoid::copyFrom(const GroupMechanoid &rhs)
{
    group = rhs.group;
    mechanoid = rhs.mechanoid;
}

const char *GroupMechanoid::getSql()
{
    return
    " \
create table \"GroupMechanoids\" ( \
\"group_id\" INTEGER, \
\"mechanoid_id\" INTEGER, \
FOREIGN KEY (\"group_id\") REFERENCES \"Groups\" (\"id\"), \
FOREIGN KEY (\"mechanoid_id\") REFERENCES \"Mechanoids\" (\"id\") \
); \
    ";
}

Map::Map()
{
    buildings = std::make_shared<CTable<MapBuilding>>();
    goods = std::make_shared<CTable<MapGood>>();
    objects = std::make_shared<CTable<MapObject>>();
}

Map::Map(const Map &rhs)
{
    copyFrom(rhs);
}

Map &Map::operator=(const Map &rhs)
{
    copyFrom(rhs);
    return *this;
}

Map::~Map()
{
}

EObjectType Map::getType() const
{
    return object_type;
}

Text Map::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(h_min);
    case 5:
        return to_string(h_max);
    case 6:
        return to_string(kx);
    case 7:
        return to_string(bx);
    case 8:
        return to_string(ky);
    case 9:
        return to_string(by);
    default:
        return "";
    };
    return "";
}

void Map::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 2:
        this->resource = to_string(text);
        break;
    case 4:
        this->h_min = std::stof(to_string(text));
        break;
    case 5:
        this->h_max = std::stof(to_string(text));
        break;
    case 6:
        this->kx = std::stof(to_string(text));
        break;
    case 7:
        this->bx = std::stof(to_string(text));
        break;
    case 8:
        this->ky = std::stof(to_string(text));
        break;
    case 9:
        this->by = std::stof(to_string(text));
        break;
    default:
        break;
    };
}

void Map::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 3:
        name = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> Map::printTree() const
{
    auto item = createTreeItem();

    Ptr<TreeItem> root;
    Ptr<TreeItem> tmp;

    root = std::make_shared<TreeItem>();
    root->name = "Buildings";
    root->type = EObjectType::MapBuilding;
    root->parent = item.get();
    for (auto &v : *buildings)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Goods";
    root->type = EObjectType::MapGood;
    root->parent = item.get();
    for (auto &v : *goods)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Objects";
    root->type = EObjectType::MapObject;
    root->parent = item.get();
    for (auto &v : *objects)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    return item;
}

Text Map::getName() const
{
    Text s;
    s = text_id;
    if (!s.empty())
        return s;
    s = to_string(name);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Map::operator==(const Map &rhs) const
{
    return
        text_id == rhs.text_id &&
        resource == rhs.resource &&
        name == rhs.name &&
        h_min == rhs.h_min &&
        h_max == rhs.h_max &&
        kx == rhs.kx &&
        bx == rhs.bx &&
        ky == rhs.ky &&
        by == rhs.by &&
        1;
}

void Map::copyFrom(const Map &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    resource = rhs.resource;
    name = rhs.name;
    h_min = rhs.h_min;
    h_max = rhs.h_max;
    kx = rhs.kx;
    bx = rhs.bx;
    ky = rhs.ky;
    by = rhs.by;

    buildings = std::make_shared<CTable<MapBuilding>>(*rhs.buildings);
    goods = std::make_shared<CTable<MapGood>>(*rhs.goods);
    objects = std::make_shared<CTable<MapObject>>(*rhs.objects);
}

const char *Map::getSql()
{
    return
    " \
create table \"Maps\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
\"h_min\" REAL, \
\"h_max\" REAL, \
\"kx\" REAL, \
\"bx\" REAL, \
\"ky\" REAL, \
\"by\" REAL, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

MapBuilding::MapBuilding()
{
    equipments = std::make_shared<CTable<MapBuildingEquipment>>();
    gliders = std::make_shared<CTable<MapBuildingGlider>>();
    goods = std::make_shared<CTable<MapBuildingGood>>();
    modificators = std::make_shared<CTable<MapBuildingModificator>>();
    projectiles = std::make_shared<CTable<MapBuildingProjectile>>();
    weapons = std::make_shared<CTable<MapBuildingWeapon>>();
}

MapBuilding::MapBuilding(const MapBuilding &rhs)
{
    copyFrom(rhs);
}

MapBuilding &MapBuilding::operator=(const MapBuilding &rhs)
{
    copyFrom(rhs);
    return *this;
}

MapBuilding::~MapBuilding()
{
}

EObjectType MapBuilding::getType() const
{
    return object_type;
}

Text MapBuilding::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(name);
    case 3:
        return to_string(map);
    case 4:
        return to_string(building);
    case 5:
        return to_string(x);
    case 6:
        return to_string(y);
    case 7:
        return to_string(z);
    case 8:
        return to_string(roll);
    case 9:
        return to_string(pitch);
    case 10:
        return to_string(yaw);
    case 11:
        return to_string(scale);
    case 12:
        return to_string(scale_x);
    case 13:
        return to_string(scale_y);
    case 14:
        return to_string(scale_z);
    case 15:
        return to_string(interactive);
    default:
        return "";
    };
    return "";
}

void MapBuilding::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 5:
        this->x = std::stof(to_string(text));
        break;
    case 6:
        this->y = std::stof(to_string(text));
        break;
    case 7:
        this->z = std::stof(to_string(text));
        break;
    case 8:
        this->roll = std::stof(to_string(text));
        break;
    case 9:
        this->pitch = std::stof(to_string(text));
        break;
    case 10:
        this->yaw = std::stof(to_string(text));
        break;
    case 11:
        this->scale = std::stof(to_string(text));
        break;
    case 12:
        this->scale_x = std::stof(to_string(text));
        break;
    case 13:
        this->scale_y = std::stof(to_string(text));
        break;
    case 14:
        this->scale_z = std::stof(to_string(text));
        break;
    case 15:
        this->interactive = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void MapBuilding::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 2:
        name = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 3:
        map = std::static_pointer_cast<Map>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 4:
        building = std::static_pointer_cast<Building>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> MapBuilding::printTree() const
{
    auto item = createTreeItem();

    Ptr<TreeItem> root;
    Ptr<TreeItem> tmp;

    root = std::make_shared<TreeItem>();
    root->name = "Equipments";
    root->type = EObjectType::MapBuildingEquipment;
    root->parent = item.get();
    for (auto &v : *equipments)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Gliders";
    root->type = EObjectType::MapBuildingGlider;
    root->parent = item.get();
    for (auto &v : *gliders)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Goods";
    root->type = EObjectType::MapBuildingGood;
    root->parent = item.get();
    for (auto &v : *goods)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Modificators";
    root->type = EObjectType::MapBuildingModificator;
    root->parent = item.get();
    for (auto &v : *modificators)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Projectiles";
    root->type = EObjectType::MapBuildingProjectile;
    root->parent = item.get();
    for (auto &v : *projectiles)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Weapons";
    root->type = EObjectType::MapBuildingWeapon;
    root->parent = item.get();
    for (auto &v : *weapons)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    return item;
}

Text MapBuilding::getName() const
{
    Text s;
    s = text_id;
    if (!s.empty())
        return s;
    s = to_string(name);
    if (!s.empty())
        return s;
    s = to_string(building);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool MapBuilding::operator==(const MapBuilding &rhs) const
{
    return
        text_id == rhs.text_id &&
        name == rhs.name &&
        map == rhs.map &&
        building == rhs.building &&
        x == rhs.x &&
        y == rhs.y &&
        z == rhs.z &&
        roll == rhs.roll &&
        pitch == rhs.pitch &&
        yaw == rhs.yaw &&
        scale == rhs.scale &&
        scale_x == rhs.scale_x &&
        scale_y == rhs.scale_y &&
        scale_z == rhs.scale_z &&
        interactive == rhs.interactive &&
        1;
}

void MapBuilding::copyFrom(const MapBuilding &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    name = rhs.name;
    map = rhs.map;
    building = rhs.building;
    x = rhs.x;
    y = rhs.y;
    z = rhs.z;
    roll = rhs.roll;
    pitch = rhs.pitch;
    yaw = rhs.yaw;
    scale = rhs.scale;
    scale_x = rhs.scale_x;
    scale_y = rhs.scale_y;
    scale_z = rhs.scale_z;
    interactive = rhs.interactive;

    equipments = std::make_shared<CTable<MapBuildingEquipment>>(*rhs.equipments);
    gliders = std::make_shared<CTable<MapBuildingGlider>>(*rhs.gliders);
    goods = std::make_shared<CTable<MapBuildingGood>>(*rhs.goods);
    modificators = std::make_shared<CTable<MapBuildingModificator>>(*rhs.modificators);
    projectiles = std::make_shared<CTable<MapBuildingProjectile>>(*rhs.projectiles);
    weapons = std::make_shared<CTable<MapBuildingWeapon>>(*rhs.weapons);
}

const char *MapBuilding::getSql()
{
    return
    " \
create table \"MapBuildings\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"name_id\" INTEGER, \
\"map_id\" INTEGER, \
\"building_id\" INTEGER, \
\"x\" REAL, \
\"y\" REAL, \
\"z\" REAL, \
\"roll\" REAL, \
\"pitch\" REAL, \
\"yaw\" REAL, \
\"scale\" REAL DEFAULT \"1\", \
\"scale_x\" REAL DEFAULT \"1\", \
\"scale_y\" REAL DEFAULT \"1\", \
\"scale_z\" REAL DEFAULT \"1\", \
\"interactive\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\"), \
FOREIGN KEY (\"map_id\") REFERENCES \"Maps\" (\"id\"), \
FOREIGN KEY (\"building_id\") REFERENCES \"Buildings\" (\"id\") \
); \
    ";
}

MapBuildingEquipment::MapBuildingEquipment()
{
}

MapBuildingEquipment::MapBuildingEquipment(const MapBuildingEquipment &rhs)
{
    copyFrom(rhs);
}

MapBuildingEquipment &MapBuildingEquipment::operator=(const MapBuildingEquipment &rhs)
{
    copyFrom(rhs);
    return *this;
}

MapBuildingEquipment::~MapBuildingEquipment()
{
}

EObjectType MapBuildingEquipment::getType() const
{
    return object_type;
}

Text MapBuildingEquipment::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(map_building);
    case 1:
        return to_string(equipment);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void MapBuildingEquipment::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void MapBuildingEquipment::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        map_building = std::static_pointer_cast<MapBuilding>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        equipment = std::static_pointer_cast<Equipment>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> MapBuildingEquipment::printTree() const
{
    return createTreeItem();
}

Text MapBuildingEquipment::getName() const
{
    Text s;
    s = to_string(map_building);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool MapBuildingEquipment::operator==(const MapBuildingEquipment &rhs) const
{
    return
        map_building == rhs.map_building &&
        equipment == rhs.equipment &&
        quantity == rhs.quantity &&
        1;
}

Ptr<MapBuilding> MapBuildingEquipment::operator->() const
{
    if (map_building)
        return map_building;
    throw EXCEPTION("Value is missing");
}

void MapBuildingEquipment::copyFrom(const MapBuildingEquipment &rhs)
{
    map_building = rhs.map_building;
    equipment = rhs.equipment;
    quantity = rhs.quantity;
}

const char *MapBuildingEquipment::getSql()
{
    return
    " \
create table \"MapBuildingEquipments\" ( \
\"map_building_id\" INTEGER, \
\"equipment_id\" INTEGER, \
\"quantity\" INTEGER, \
FOREIGN KEY (\"map_building_id\") REFERENCES \"MapBuildings\" (\"id\"), \
FOREIGN KEY (\"equipment_id\") REFERENCES \"Equipments\" (\"id\") \
); \
    ";
}

MapBuildingGlider::MapBuildingGlider()
{
}

MapBuildingGlider::MapBuildingGlider(const MapBuildingGlider &rhs)
{
    copyFrom(rhs);
}

MapBuildingGlider &MapBuildingGlider::operator=(const MapBuildingGlider &rhs)
{
    copyFrom(rhs);
    return *this;
}

MapBuildingGlider::~MapBuildingGlider()
{
}

EObjectType MapBuildingGlider::getType() const
{
    return object_type;
}

Text MapBuildingGlider::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(map_building);
    case 1:
        return to_string(glider);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void MapBuildingGlider::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void MapBuildingGlider::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        map_building = std::static_pointer_cast<MapBuilding>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        glider = std::static_pointer_cast<Glider>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> MapBuildingGlider::printTree() const
{
    return createTreeItem();
}

Text MapBuildingGlider::getName() const
{
    Text s;
    s = to_string(map_building);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool MapBuildingGlider::operator==(const MapBuildingGlider &rhs) const
{
    return
        map_building == rhs.map_building &&
        glider == rhs.glider &&
        quantity == rhs.quantity &&
        1;
}

Ptr<MapBuilding> MapBuildingGlider::operator->() const
{
    if (map_building)
        return map_building;
    throw EXCEPTION("Value is missing");
}

void MapBuildingGlider::copyFrom(const MapBuildingGlider &rhs)
{
    map_building = rhs.map_building;
    glider = rhs.glider;
    quantity = rhs.quantity;
}

const char *MapBuildingGlider::getSql()
{
    return
    " \
create table \"MapBuildingGliders\" ( \
\"map_building_id\" INTEGER, \
\"glider_id\" INTEGER, \
\"quantity\" INTEGER, \
FOREIGN KEY (\"map_building_id\") REFERENCES \"MapBuildings\" (\"id\"), \
FOREIGN KEY (\"glider_id\") REFERENCES \"Gliders\" (\"id\") \
); \
    ";
}

MapBuildingGood::MapBuildingGood()
{
}

MapBuildingGood::MapBuildingGood(const MapBuildingGood &rhs)
{
    copyFrom(rhs);
}

MapBuildingGood &MapBuildingGood::operator=(const MapBuildingGood &rhs)
{
    copyFrom(rhs);
    return *this;
}

MapBuildingGood::~MapBuildingGood()
{
}

EObjectType MapBuildingGood::getType() const
{
    return object_type;
}

Text MapBuildingGood::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(map_building);
    case 1:
        return to_string(good);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void MapBuildingGood::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void MapBuildingGood::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        map_building = std::static_pointer_cast<MapBuilding>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        good = std::static_pointer_cast<Good>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> MapBuildingGood::printTree() const
{
    return createTreeItem();
}

Text MapBuildingGood::getName() const
{
    Text s;
    s = to_string(map_building);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool MapBuildingGood::operator==(const MapBuildingGood &rhs) const
{
    return
        map_building == rhs.map_building &&
        good == rhs.good &&
        quantity == rhs.quantity &&
        1;
}

Ptr<MapBuilding> MapBuildingGood::operator->() const
{
    if (map_building)
        return map_building;
    throw EXCEPTION("Value is missing");
}

void MapBuildingGood::copyFrom(const MapBuildingGood &rhs)
{
    map_building = rhs.map_building;
    good = rhs.good;
    quantity = rhs.quantity;
}

const char *MapBuildingGood::getSql()
{
    return
    " \
create table \"MapBuildingGoods\" ( \
\"map_building_id\" INTEGER, \
\"good_id\" INTEGER, \
\"quantity\" INTEGER, \
FOREIGN KEY (\"map_building_id\") REFERENCES \"MapBuildings\" (\"id\"), \
FOREIGN KEY (\"good_id\") REFERENCES \"Goods\" (\"id\") \
); \
    ";
}

MapBuildingModificator::MapBuildingModificator()
{
}

MapBuildingModificator::MapBuildingModificator(const MapBuildingModificator &rhs)
{
    copyFrom(rhs);
}

MapBuildingModificator &MapBuildingModificator::operator=(const MapBuildingModificator &rhs)
{
    copyFrom(rhs);
    return *this;
}

MapBuildingModificator::~MapBuildingModificator()
{
}

EObjectType MapBuildingModificator::getType() const
{
    return object_type;
}

Text MapBuildingModificator::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(map_building);
    case 1:
        return to_string(modificator);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void MapBuildingModificator::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void MapBuildingModificator::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        map_building = std::static_pointer_cast<MapBuilding>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        modificator = std::static_pointer_cast<Modificator>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> MapBuildingModificator::printTree() const
{
    return createTreeItem();
}

Text MapBuildingModificator::getName() const
{
    Text s;
    s = to_string(map_building);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool MapBuildingModificator::operator==(const MapBuildingModificator &rhs) const
{
    return
        map_building == rhs.map_building &&
        modificator == rhs.modificator &&
        quantity == rhs.quantity &&
        1;
}

Ptr<MapBuilding> MapBuildingModificator::operator->() const
{
    if (map_building)
        return map_building;
    throw EXCEPTION("Value is missing");
}

void MapBuildingModificator::copyFrom(const MapBuildingModificator &rhs)
{
    map_building = rhs.map_building;
    modificator = rhs.modificator;
    quantity = rhs.quantity;
}

const char *MapBuildingModificator::getSql()
{
    return
    " \
create table \"MapBuildingModificators\" ( \
\"map_building_id\" INTEGER, \
\"modificator_id\" INTEGER, \
\"quantity\" INTEGER, \
FOREIGN KEY (\"map_building_id\") REFERENCES \"MapBuildings\" (\"id\"), \
FOREIGN KEY (\"modificator_id\") REFERENCES \"Modificators\" (\"id\") \
); \
    ";
}

MapBuildingProjectile::MapBuildingProjectile()
{
}

MapBuildingProjectile::MapBuildingProjectile(const MapBuildingProjectile &rhs)
{
    copyFrom(rhs);
}

MapBuildingProjectile &MapBuildingProjectile::operator=(const MapBuildingProjectile &rhs)
{
    copyFrom(rhs);
    return *this;
}

MapBuildingProjectile::~MapBuildingProjectile()
{
}

EObjectType MapBuildingProjectile::getType() const
{
    return object_type;
}

Text MapBuildingProjectile::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(map_building);
    case 1:
        return to_string(projectile);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void MapBuildingProjectile::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void MapBuildingProjectile::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        map_building = std::static_pointer_cast<MapBuilding>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        projectile = std::static_pointer_cast<Projectile>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> MapBuildingProjectile::printTree() const
{
    return createTreeItem();
}

Text MapBuildingProjectile::getName() const
{
    Text s;
    s = to_string(map_building);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool MapBuildingProjectile::operator==(const MapBuildingProjectile &rhs) const
{
    return
        map_building == rhs.map_building &&
        projectile == rhs.projectile &&
        quantity == rhs.quantity &&
        1;
}

Ptr<MapBuilding> MapBuildingProjectile::operator->() const
{
    if (map_building)
        return map_building;
    throw EXCEPTION("Value is missing");
}

void MapBuildingProjectile::copyFrom(const MapBuildingProjectile &rhs)
{
    map_building = rhs.map_building;
    projectile = rhs.projectile;
    quantity = rhs.quantity;
}

const char *MapBuildingProjectile::getSql()
{
    return
    " \
create table \"MapBuildingProjectiles\" ( \
\"map_building_id\" INTEGER, \
\"projectile_id\" INTEGER, \
\"quantity\" INTEGER, \
FOREIGN KEY (\"map_building_id\") REFERENCES \"MapBuildings\" (\"id\"), \
FOREIGN KEY (\"projectile_id\") REFERENCES \"Projectiles\" (\"id\") \
); \
    ";
}

MapBuildingWeapon::MapBuildingWeapon()
{
}

MapBuildingWeapon::MapBuildingWeapon(const MapBuildingWeapon &rhs)
{
    copyFrom(rhs);
}

MapBuildingWeapon &MapBuildingWeapon::operator=(const MapBuildingWeapon &rhs)
{
    copyFrom(rhs);
    return *this;
}

MapBuildingWeapon::~MapBuildingWeapon()
{
}

EObjectType MapBuildingWeapon::getType() const
{
    return object_type;
}

Text MapBuildingWeapon::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(map_building);
    case 1:
        return to_string(weapon);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void MapBuildingWeapon::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void MapBuildingWeapon::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        map_building = std::static_pointer_cast<MapBuilding>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        weapon = std::static_pointer_cast<Weapon>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> MapBuildingWeapon::printTree() const
{
    return createTreeItem();
}

Text MapBuildingWeapon::getName() const
{
    Text s;
    s = to_string(map_building);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool MapBuildingWeapon::operator==(const MapBuildingWeapon &rhs) const
{
    return
        map_building == rhs.map_building &&
        weapon == rhs.weapon &&
        quantity == rhs.quantity &&
        1;
}

Ptr<MapBuilding> MapBuildingWeapon::operator->() const
{
    if (map_building)
        return map_building;
    throw EXCEPTION("Value is missing");
}

void MapBuildingWeapon::copyFrom(const MapBuildingWeapon &rhs)
{
    map_building = rhs.map_building;
    weapon = rhs.weapon;
    quantity = rhs.quantity;
}

const char *MapBuildingWeapon::getSql()
{
    return
    " \
create table \"MapBuildingWeapons\" ( \
\"map_building_id\" INTEGER, \
\"weapon_id\" INTEGER, \
\"quantity\" INTEGER, \
FOREIGN KEY (\"map_building_id\") REFERENCES \"MapBuildings\" (\"id\"), \
FOREIGN KEY (\"weapon_id\") REFERENCES \"Weapons\" (\"id\") \
); \
    ";
}

MapGood::MapGood()
{
}

MapGood::MapGood(const MapGood &rhs)
{
    copyFrom(rhs);
}

MapGood &MapGood::operator=(const MapGood &rhs)
{
    copyFrom(rhs);
    return *this;
}

MapGood::~MapGood()
{
}

EObjectType MapGood::getType() const
{
    return object_type;
}

Text MapGood::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(map);
    case 3:
        return to_string(good);
    case 4:
        return to_string(x);
    case 5:
        return to_string(y);
    case 6:
        return to_string(z);
    case 7:
        return to_string(roll);
    case 8:
        return to_string(pitch);
    case 9:
        return to_string(yaw);
    case 10:
        return to_string(scale);
    case 11:
        return to_string(scale_x);
    case 12:
        return to_string(scale_y);
    case 13:
        return to_string(scale_z);
    default:
        return "";
    };
    return "";
}

void MapGood::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 4:
        this->x = std::stof(to_string(text));
        break;
    case 5:
        this->y = std::stof(to_string(text));
        break;
    case 6:
        this->z = std::stof(to_string(text));
        break;
    case 7:
        this->roll = std::stof(to_string(text));
        break;
    case 8:
        this->pitch = std::stof(to_string(text));
        break;
    case 9:
        this->yaw = std::stof(to_string(text));
        break;
    case 10:
        this->scale = std::stof(to_string(text));
        break;
    case 11:
        this->scale_x = std::stof(to_string(text));
        break;
    case 12:
        this->scale_y = std::stof(to_string(text));
        break;
    case 13:
        this->scale_z = std::stof(to_string(text));
        break;
    default:
        break;
    };
}

void MapGood::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 2:
        map = std::static_pointer_cast<Map>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 3:
        good = std::static_pointer_cast<Good>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> MapGood::printTree() const
{
    return createTreeItem();
}

Text MapGood::getName() const
{
    Text s;
    s = text_id;
    if (!s.empty())
        return s;
    s = to_string(good);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool MapGood::operator==(const MapGood &rhs) const
{
    return
        text_id == rhs.text_id &&
        map == rhs.map &&
        good == rhs.good &&
        x == rhs.x &&
        y == rhs.y &&
        z == rhs.z &&
        roll == rhs.roll &&
        pitch == rhs.pitch &&
        yaw == rhs.yaw &&
        scale == rhs.scale &&
        scale_x == rhs.scale_x &&
        scale_y == rhs.scale_y &&
        scale_z == rhs.scale_z &&
        1;
}

void MapGood::copyFrom(const MapGood &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    map = rhs.map;
    good = rhs.good;
    x = rhs.x;
    y = rhs.y;
    z = rhs.z;
    roll = rhs.roll;
    pitch = rhs.pitch;
    yaw = rhs.yaw;
    scale = rhs.scale;
    scale_x = rhs.scale_x;
    scale_y = rhs.scale_y;
    scale_z = rhs.scale_z;
}

const char *MapGood::getSql()
{
    return
    " \
create table \"MapGoods\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"map_id\" INTEGER, \
\"good_id\" INTEGER, \
\"x\" REAL, \
\"y\" REAL, \
\"z\" REAL, \
\"roll\" REAL, \
\"pitch\" REAL, \
\"yaw\" REAL, \
\"scale\" REAL DEFAULT \"1\", \
\"scale_x\" REAL DEFAULT \"1\", \
\"scale_y\" REAL DEFAULT \"1\", \
\"scale_z\" REAL DEFAULT \"1\", \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"map_id\") REFERENCES \"Maps\" (\"id\"), \
FOREIGN KEY (\"good_id\") REFERENCES \"Goods\" (\"id\") \
); \
    ";
}

MapObject::MapObject()
{
}

MapObject::MapObject(const MapObject &rhs)
{
    copyFrom(rhs);
}

MapObject &MapObject::operator=(const MapObject &rhs)
{
    copyFrom(rhs);
    return *this;
}

MapObject::~MapObject()
{
}

EObjectType MapObject::getType() const
{
    return object_type;
}

Text MapObject::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(map);
    case 3:
        return to_string(object);
    case 4:
        return to_string(x);
    case 5:
        return to_string(y);
    case 6:
        return to_string(z);
    case 7:
        return to_string(roll);
    case 8:
        return to_string(pitch);
    case 9:
        return to_string(yaw);
    case 10:
        return to_string(scale);
    case 11:
        return to_string(scale_x);
    case 12:
        return to_string(scale_y);
    case 13:
        return to_string(scale_z);
    default:
        return "";
    };
    return "";
}

void MapObject::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 4:
        this->x = std::stof(to_string(text));
        break;
    case 5:
        this->y = std::stof(to_string(text));
        break;
    case 6:
        this->z = std::stof(to_string(text));
        break;
    case 7:
        this->roll = std::stof(to_string(text));
        break;
    case 8:
        this->pitch = std::stof(to_string(text));
        break;
    case 9:
        this->yaw = std::stof(to_string(text));
        break;
    case 10:
        this->scale = std::stof(to_string(text));
        break;
    case 11:
        this->scale_x = std::stof(to_string(text));
        break;
    case 12:
        this->scale_y = std::stof(to_string(text));
        break;
    case 13:
        this->scale_z = std::stof(to_string(text));
        break;
    default:
        break;
    };
}

void MapObject::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 2:
        map = std::static_pointer_cast<Map>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 3:
        object = std::static_pointer_cast<Object>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> MapObject::printTree() const
{
    return createTreeItem();
}

Text MapObject::getName() const
{
    Text s;
    s = text_id;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool MapObject::operator==(const MapObject &rhs) const
{
    return
        text_id == rhs.text_id &&
        map == rhs.map &&
        object == rhs.object &&
        x == rhs.x &&
        y == rhs.y &&
        z == rhs.z &&
        roll == rhs.roll &&
        pitch == rhs.pitch &&
        yaw == rhs.yaw &&
        scale == rhs.scale &&
        scale_x == rhs.scale_x &&
        scale_y == rhs.scale_y &&
        scale_z == rhs.scale_z &&
        1;
}

void MapObject::copyFrom(const MapObject &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    map = rhs.map;
    object = rhs.object;
    x = rhs.x;
    y = rhs.y;
    z = rhs.z;
    roll = rhs.roll;
    pitch = rhs.pitch;
    yaw = rhs.yaw;
    scale = rhs.scale;
    scale_x = rhs.scale_x;
    scale_y = rhs.scale_y;
    scale_z = rhs.scale_z;
}

const char *MapObject::getSql()
{
    return
    " \
create table \"MapObjects\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"map_id\" INTEGER, \
\"object_id\" INTEGER, \
\"x\" REAL, \
\"y\" REAL, \
\"z\" REAL, \
\"roll\" REAL, \
\"pitch\" REAL, \
\"yaw\" REAL, \
\"scale\" REAL DEFAULT \"1\", \
\"scale_x\" REAL DEFAULT \"1\", \
\"scale_y\" REAL DEFAULT \"1\", \
\"scale_z\" REAL DEFAULT \"1\", \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"map_id\") REFERENCES \"Maps\" (\"id\"), \
FOREIGN KEY (\"object_id\") REFERENCES \"Objects\" (\"id\") \
); \
    ";
}

Mechanoid::Mechanoid()
{
    quests = std::make_shared<CTable<MechanoidQuest>>();
}

Mechanoid::Mechanoid(const Mechanoid &rhs)
{
    copyFrom(rhs);
}

Mechanoid &Mechanoid::operator=(const Mechanoid &rhs)
{
    copyFrom(rhs);
    return *this;
}

Mechanoid::~Mechanoid()
{
}

EObjectType Mechanoid::getType() const
{
    return object_type;
}

Text Mechanoid::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(name);
    case 3:
        return to_string(modification);
    case 4:
        return to_string(map);
    case 5:
        return to_string(clan);
    case 6:
        return to_string(building);
    case 7:
        return to_string(configuration);
    case 8:
        return to_string(group);
    case 9:
        return to_string(generation);
    case 10:
        return to_string(money);
    case 11:
        return to_string(rating);
    case 12:
        return to_string(rating_fight);
    case 13:
        return to_string(rating_courier);
    case 14:
        return to_string(rating_trade);
    case 15:
        return to_string(x);
    case 16:
        return to_string(y);
    case 17:
        return to_string(z);
    case 18:
        return to_string(roll);
    case 19:
        return to_string(pitch);
    case 20:
        return to_string(yaw);
    default:
        return "";
    };
    return "";
}

void Mechanoid::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 9:
        this->generation = std::stoi(to_string(text));
        break;
    case 10:
        this->money = std::stof(to_string(text));
        break;
    case 11:
        this->rating = std::stof(to_string(text));
        break;
    case 12:
        this->rating_fight = std::stof(to_string(text));
        break;
    case 13:
        this->rating_courier = std::stof(to_string(text));
        break;
    case 14:
        this->rating_trade = std::stof(to_string(text));
        break;
    case 15:
        this->x = std::stof(to_string(text));
        break;
    case 16:
        this->y = std::stof(to_string(text));
        break;
    case 17:
        this->z = std::stof(to_string(text));
        break;
    case 18:
        this->roll = std::stof(to_string(text));
        break;
    case 19:
        this->pitch = std::stof(to_string(text));
        break;
    case 20:
        this->yaw = std::stof(to_string(text));
        break;
    default:
        break;
    };
}

void Mechanoid::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 2:
        name = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 3:
        modification = std::static_pointer_cast<Modification>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 4:
        map = std::static_pointer_cast<ModificationMap>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 5:
        clan = std::static_pointer_cast<Clan>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 6:
        building = std::static_pointer_cast<MapBuilding>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 7:
        configuration = std::static_pointer_cast<Configuration>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 8:
        group = std::static_pointer_cast<Group>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> Mechanoid::printTree() const
{
    auto item = createTreeItem();

    Ptr<TreeItem> root;
    Ptr<TreeItem> tmp;

    root = std::make_shared<TreeItem>();
    root->name = "Quests";
    root->type = EObjectType::MechanoidQuest;
    root->parent = item.get();
    for (auto &v : *quests)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    return item;
}

Text Mechanoid::getName() const
{
    Text s;
    s = to_string(name);
    if (!s.empty())
        return s;
    s = text_id;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Mechanoid::operator==(const Mechanoid &rhs) const
{
    return
        text_id == rhs.text_id &&
        name == rhs.name &&
        modification == rhs.modification &&
        map == rhs.map &&
        clan == rhs.clan &&
        building == rhs.building &&
        configuration == rhs.configuration &&
        group == rhs.group &&
        generation == rhs.generation &&
        money == rhs.money &&
        rating == rhs.rating &&
        rating_fight == rhs.rating_fight &&
        rating_courier == rhs.rating_courier &&
        rating_trade == rhs.rating_trade &&
        x == rhs.x &&
        y == rhs.y &&
        z == rhs.z &&
        roll == rhs.roll &&
        pitch == rhs.pitch &&
        yaw == rhs.yaw &&
        1;
}

void Mechanoid::copyFrom(const Mechanoid &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    name = rhs.name;
    modification = rhs.modification;
    map = rhs.map;
    clan = rhs.clan;
    building = rhs.building;
    configuration = rhs.configuration;
    group = rhs.group;
    generation = rhs.generation;
    money = rhs.money;
    rating = rhs.rating;
    rating_fight = rhs.rating_fight;
    rating_courier = rhs.rating_courier;
    rating_trade = rhs.rating_trade;
    x = rhs.x;
    y = rhs.y;
    z = rhs.z;
    roll = rhs.roll;
    pitch = rhs.pitch;
    yaw = rhs.yaw;

    quests = std::make_shared<CTable<MechanoidQuest>>(*rhs.quests);
}

const char *Mechanoid::getSql()
{
    return
    " \
create table \"Mechanoids\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"name_id\" INTEGER, \
\"modification_id\" INTEGER, \
\"map_id\" INTEGER, \
\"clan_id\" INTEGER, \
\"building_id\" INTEGER, \
\"configuration_id\" INTEGER, \
\"group_id\" INTEGER, \
\"generation\" INTEGER, \
\"money\" REAL, \
\"rating\" REAL, \
\"rating_fight\" REAL, \
\"rating_courier\" REAL, \
\"rating_trade\" REAL, \
\"x\" REAL, \
\"y\" REAL, \
\"z\" REAL, \
\"roll\" REAL, \
\"pitch\" REAL, \
\"yaw\" REAL, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\"), \
FOREIGN KEY (\"modification_id\") REFERENCES \"Modifications\" (\"id\"), \
FOREIGN KEY (\"map_id\") REFERENCES \"ModificationMaps\" (\"id\"), \
FOREIGN KEY (\"clan_id\") REFERENCES \"Clans\" (\"id\"), \
FOREIGN KEY (\"building_id\") REFERENCES \"MapBuildings\" (\"id\"), \
FOREIGN KEY (\"configuration_id\") REFERENCES \"Configurations\" (\"id\"), \
FOREIGN KEY (\"group_id\") REFERENCES \"Groups\" (\"id\") \
); \
    ";
}

MechanoidQuest::MechanoidQuest()
{
}

MechanoidQuest::MechanoidQuest(const MechanoidQuest &rhs)
{
    copyFrom(rhs);
}

MechanoidQuest &MechanoidQuest::operator=(const MechanoidQuest &rhs)
{
    copyFrom(rhs);
    return *this;
}

MechanoidQuest::~MechanoidQuest()
{
}

EObjectType MechanoidQuest::getType() const
{
    return object_type;
}

Text MechanoidQuest::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(mechanoid);
    case 1:
        return to_string(quest);
    case 2:
        return to_string(state);
    default:
        return "";
    };
    return "";
}

void MechanoidQuest::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->state = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void MechanoidQuest::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        mechanoid = std::static_pointer_cast<Mechanoid>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        quest = std::static_pointer_cast<Quest>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> MechanoidQuest::printTree() const
{
    return createTreeItem();
}

Text MechanoidQuest::getName() const
{
    Text s;
    s = to_string(mechanoid);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool MechanoidQuest::operator==(const MechanoidQuest &rhs) const
{
    return
        mechanoid == rhs.mechanoid &&
        quest == rhs.quest &&
        state == rhs.state &&
        1;
}

Ptr<Mechanoid> MechanoidQuest::operator->() const
{
    if (mechanoid)
        return mechanoid;
    throw EXCEPTION("Value is missing");
}

void MechanoidQuest::copyFrom(const MechanoidQuest &rhs)
{
    mechanoid = rhs.mechanoid;
    quest = rhs.quest;
    state = rhs.state;
}

const char *MechanoidQuest::getSql()
{
    return
    " \
create table \"MechanoidQuests\" ( \
\"mechanoid_id\" INTEGER, \
\"quest_id\" INTEGER, \
\"state\" INTEGER, \
FOREIGN KEY (\"mechanoid_id\") REFERENCES \"Mechanoids\" (\"id\"), \
FOREIGN KEY (\"quest_id\") REFERENCES \"Quests\" (\"id\") \
); \
    ";
}

Modification::Modification()
{
    maps = std::make_shared<CTable<ModificationMap>>();
    clans = std::make_shared<CTable<Clan>>();
    mechanoids = std::make_shared<CTable<Mechanoid>>();
}

Modification::Modification(const Modification &rhs)
{
    copyFrom(rhs);
}

Modification &Modification::operator=(const Modification &rhs)
{
    copyFrom(rhs);
    return *this;
}

Modification::~Modification()
{
}

EObjectType Modification::getType() const
{
    return object_type;
}

Text Modification::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(name);
    case 2:
        return to_string(directory);
    case 3:
        return to_string(author);
    case 4:
        return to_string(date_created);
    case 5:
        return to_string(date_modified);
    case 6:
        return to_string(comment);
    case 7:
        return to_string(version);
    case 8:
        return to_string(script_language);
    case 9:
        return to_string(script_main);
    case 10:
        return to_string(player_mechanoid);
    case 11:
        return to_string(cooperative_player_configuration);
    default:
        return "";
    };
    return "";
}

void Modification::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 2:
        this->directory = to_string(text);
        break;
    case 3:
        this->author = to_string(text);
        break;
    case 4:
        this->date_created = to_string(text);
        break;
    case 5:
        this->date_modified = to_string(text);
        break;
    case 6:
        this->comment = to_string(text);
        break;
    case 7:
        this->version = to_string(text);
        break;
    case 8:
        this->script_language = to_string(text);
        break;
    case 9:
        this->script_main = to_string(text);
        break;
    default:
        break;
    };
}

void Modification::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 1:
        name = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 10:
        player_mechanoid = std::static_pointer_cast<Mechanoid>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 11:
        cooperative_player_configuration = std::static_pointer_cast<Configuration>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> Modification::printTree() const
{
    auto item = createTreeItem();

    Ptr<TreeItem> root;
    Ptr<TreeItem> tmp;

    root = std::make_shared<TreeItem>();
    root->name = "Maps";
    root->type = EObjectType::ModificationMap;
    root->parent = item.get();
    for (auto &v : *maps)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Clans";
    root->type = EObjectType::Clan;
    root->parent = item.get();
    for (auto &v : *clans)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Mechanoids";
    root->type = EObjectType::Mechanoid;
    root->parent = item.get();
    for (auto &v : *mechanoids)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    return item;
}

Text Modification::getName() const
{
    Text s;
    s = to_string(name);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Modification::operator==(const Modification &rhs) const
{
    return
        name == rhs.name &&
        directory == rhs.directory &&
        author == rhs.author &&
        date_created == rhs.date_created &&
        date_modified == rhs.date_modified &&
        comment == rhs.comment &&
        version == rhs.version &&
        script_language == rhs.script_language &&
        script_main == rhs.script_main &&
        player_mechanoid == rhs.player_mechanoid &&
        cooperative_player_configuration == rhs.cooperative_player_configuration &&
        1;
}

void Modification::copyFrom(const Modification &rhs)
{
    id = rhs.id;
    name = rhs.name;
    directory = rhs.directory;
    author = rhs.author;
    date_created = rhs.date_created;
    date_modified = rhs.date_modified;
    comment = rhs.comment;
    version = rhs.version;
    script_language = rhs.script_language;
    script_main = rhs.script_main;
    player_mechanoid = rhs.player_mechanoid;
    cooperative_player_configuration = rhs.cooperative_player_configuration;

    maps = std::make_shared<CTable<ModificationMap>>(*rhs.maps);
    clans = std::make_shared<CTable<Clan>>(*rhs.clans);
    mechanoids = std::make_shared<CTable<Mechanoid>>(*rhs.mechanoids);
}

const char *Modification::getSql()
{
    return
    " \
create table \"Modifications\" ( \
\"id\" INTEGER, \
\"name_id\" INTEGER, \
\"directory\" TEXT, \
\"author\" TEXT, \
\"date_created\" TEXT, \
\"date_modified\" TEXT, \
\"comment\" TEXT, \
\"version\" TEXT, \
\"script_language\" TEXT, \
\"script_main\" TEXT, \
\"player_mechanoid_id\" INTEGER, \
\"cooperative_player_configuration_id\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\"), \
FOREIGN KEY (\"player_mechanoid_id\") REFERENCES \"Mechanoids\" (\"id\"), \
FOREIGN KEY (\"cooperative_player_configuration_id\") REFERENCES \"Configurations\" (\"id\") \
); \
    ";
}

ModificationMap::ModificationMap()
{
}

ModificationMap::ModificationMap(const ModificationMap &rhs)
{
    copyFrom(rhs);
}

ModificationMap &ModificationMap::operator=(const ModificationMap &rhs)
{
    copyFrom(rhs);
    return *this;
}

ModificationMap::~ModificationMap()
{
}

EObjectType ModificationMap::getType() const
{
    return object_type;
}

Text ModificationMap::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(modification);
    case 2:
        return to_string(map);
    default:
        return "";
    };
    return "";
}

void ModificationMap::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void ModificationMap::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 1:
        modification = std::static_pointer_cast<Modification>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 2:
        map = std::static_pointer_cast<Map>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> ModificationMap::printTree() const
{
    return createTreeItem();
}

Text ModificationMap::getName() const
{
    Text s;
    s = to_string(map);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool ModificationMap::operator==(const ModificationMap &rhs) const
{
    return
        modification == rhs.modification &&
        map == rhs.map &&
        1;
}

Ptr<Map> ModificationMap::operator->() const
{
    if (map)
        return map;
    throw EXCEPTION("Value is missing");
}

void ModificationMap::copyFrom(const ModificationMap &rhs)
{
    id = rhs.id;
    modification = rhs.modification;
    map = rhs.map;
}

const char *ModificationMap::getSql()
{
    return
    " \
create table \"ModificationMaps\" ( \
\"id\" INTEGER, \
\"modification_id\" INTEGER, \
\"map_id\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"modification_id\") REFERENCES \"Modifications\" (\"id\"), \
FOREIGN KEY (\"map_id\") REFERENCES \"Maps\" (\"id\") \
); \
    ";
}

Modificator::Modificator()
{
}

Modificator::Modificator(const Modificator &rhs)
{
    copyFrom(rhs);
}

Modificator &Modificator::operator=(const Modificator &rhs)
{
    copyFrom(rhs);
    return *this;
}

Modificator::~Modificator()
{
}

EObjectType Modificator::getType() const
{
    return object_type;
}

Text Modificator::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(probability);
    case 5:
        return to_string(price);
    case 6:
        return to_string(k_price);
    case 7:
        return to_string(k_param1);
    case 8:
        return to_string(k_param2);
    case 9:
        return to_string(unicum_id);
    case 10:
        return to_string(mask);
    default:
        return "";
    };
    return "";
}

void Modificator::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 2:
        this->resource = to_string(text);
        break;
    case 4:
        this->probability = std::stof(to_string(text));
        break;
    case 5:
        this->price = std::stof(to_string(text));
        break;
    case 6:
        this->k_price = std::stof(to_string(text));
        break;
    case 7:
        this->k_param1 = std::stof(to_string(text));
        break;
    case 8:
        this->k_param2 = std::stof(to_string(text));
        break;
    case 9:
        this->unicum_id = std::stoi(to_string(text));
        break;
    case 10:
        this->mask = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void Modificator::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 3:
        name = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> Modificator::printTree() const
{
    return createTreeItem();
}

Text Modificator::getName() const
{
    Text s;
    s = to_string(name);
    if (!s.empty())
        return s;
    s = text_id;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Modificator::operator==(const Modificator &rhs) const
{
    return
        text_id == rhs.text_id &&
        resource == rhs.resource &&
        name == rhs.name &&
        probability == rhs.probability &&
        price == rhs.price &&
        k_price == rhs.k_price &&
        k_param1 == rhs.k_param1 &&
        k_param2 == rhs.k_param2 &&
        unicum_id == rhs.unicum_id &&
        mask == rhs.mask &&
        1;
}

void Modificator::copyFrom(const Modificator &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    resource = rhs.resource;
    name = rhs.name;
    probability = rhs.probability;
    price = rhs.price;
    k_price = rhs.k_price;
    k_param1 = rhs.k_param1;
    k_param2 = rhs.k_param2;
    unicum_id = rhs.unicum_id;
    mask = rhs.mask;
}

const char *Modificator::getSql()
{
    return
    " \
create table \"Modificators\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
\"probability\" REAL, \
\"price\" REAL, \
\"k_price\" REAL, \
\"k_param1\" REAL, \
\"k_param2\" REAL, \
\"unicum_id\" INTEGER, \
\"mask\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

Object::Object()
{
}

Object::Object(const Object &rhs)
{
    copyFrom(rhs);
}

Object &Object::operator=(const Object &rhs)
{
    copyFrom(rhs);
    return *this;
}

Object::~Object()
{
}

EObjectType Object::getType() const
{
    return object_type;
}

Text Object::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(type);
    case 5:
        return to_string(scale);
    case 6:
        return to_string(scale_x);
    case 7:
        return to_string(scale_y);
    case 8:
        return to_string(scale_z);
    default:
        return "";
    };
    return "";
}

void Object::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 2:
        this->resource = to_string(text);
        break;
    case 4:
        this->type = std::stoi(to_string(text));
        break;
    case 5:
        this->scale = std::stof(to_string(text));
        break;
    case 6:
        this->scale_x = std::stof(to_string(text));
        break;
    case 7:
        this->scale_y = std::stof(to_string(text));
        break;
    case 8:
        this->scale_z = std::stof(to_string(text));
        break;
    default:
        break;
    };
}

void Object::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 3:
        name = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> Object::printTree() const
{
    return createTreeItem();
}

Text Object::getName() const
{
    Text s;
    s = to_string(name);
    if (!s.empty())
        return s;
    s = text_id;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Object::operator==(const Object &rhs) const
{
    return
        text_id == rhs.text_id &&
        resource == rhs.resource &&
        name == rhs.name &&
        type == rhs.type &&
        scale == rhs.scale &&
        scale_x == rhs.scale_x &&
        scale_y == rhs.scale_y &&
        scale_z == rhs.scale_z &&
        1;
}

void Object::copyFrom(const Object &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    resource = rhs.resource;
    name = rhs.name;
    type = rhs.type;
    scale = rhs.scale;
    scale_x = rhs.scale_x;
    scale_y = rhs.scale_y;
    scale_z = rhs.scale_z;
}

const char *Object::getSql()
{
    return
    " \
create table \"Objects\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
\"type\" INTEGER, \
\"scale\" REAL DEFAULT \"1\", \
\"scale_x\" REAL DEFAULT \"1\", \
\"scale_y\" REAL DEFAULT \"1\", \
\"scale_z\" REAL DEFAULT \"1\", \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

Player::Player()
{
}

Player::Player(const Player &rhs)
{
    copyFrom(rhs);
}

Player &Player::operator=(const Player &rhs)
{
    copyFrom(rhs);
    return *this;
}

Player::~Player()
{
}

EObjectType Player::getType() const
{
    return object_type;
}

Text Player::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(mechanoid);
    default:
        return "";
    };
    return "";
}

void Player::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void Player::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 1:
        mechanoid = std::static_pointer_cast<Mechanoid>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> Player::printTree() const
{
    return createTreeItem();
}

Text Player::getName() const
{
    Text s;
    s = to_string(mechanoid);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Player::operator==(const Player &rhs) const
{
    return
        mechanoid == rhs.mechanoid &&
        1;
}

void Player::copyFrom(const Player &rhs)
{
    id = rhs.id;
    mechanoid = rhs.mechanoid;
}

const char *Player::getSql()
{
    return
    " \
create table \"Players\" ( \
\"id\" INTEGER, \
\"mechanoid_id\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"mechanoid_id\") REFERENCES \"Mechanoids\" (\"id\") \
); \
    ";
}

Projectile::Projectile()
{
}

Projectile::Projectile(const Projectile &rhs)
{
    copyFrom(rhs);
}

Projectile &Projectile::operator=(const Projectile &rhs)
{
    copyFrom(rhs);
    return *this;
}

Projectile::~Projectile()
{
}

EObjectType Projectile::getType() const
{
    return object_type;
}

Text Projectile::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(type);
    case 5:
        return to_string(subtype);
    case 6:
        return to_string(weight);
    case 7:
        return to_string(damage);
    case 8:
        return to_string(T);
    case 9:
        return to_string(speed);
    case 10:
        return to_string(scale);
    case 11:
        return to_string(numstate);
    case 12:
        return to_string(rotate);
    case 13:
        return to_string(life_time);
    case 14:
        return to_string(detonation_delay);
    case 15:
        return to_string(distance_detonation);
    case 16:
        return to_string(strength);
    case 17:
        return to_string(price);
    case 18:
        return to_string(notrade);
    default:
        return "";
    };
    return "";
}

void Projectile::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 2:
        this->resource = to_string(text);
        break;
    case 4:
        this->type = std::stoi(to_string(text));
        break;
    case 5:
        this->subtype = std::stoi(to_string(text));
        break;
    case 6:
        this->weight = std::stof(to_string(text));
        break;
    case 7:
        this->damage = std::stof(to_string(text));
        break;
    case 8:
        this->T = std::stof(to_string(text));
        break;
    case 9:
        this->speed = std::stof(to_string(text));
        break;
    case 10:
        this->scale = std::stof(to_string(text));
        break;
    case 11:
        this->numstate = std::stoi(to_string(text));
        break;
    case 12:
        this->rotate = std::stof(to_string(text));
        break;
    case 13:
        this->life_time = std::stof(to_string(text));
        break;
    case 14:
        this->detonation_delay = std::stof(to_string(text));
        break;
    case 15:
        this->distance_detonation = std::stof(to_string(text));
        break;
    case 16:
        this->strength = std::stof(to_string(text));
        break;
    case 17:
        this->price = std::stof(to_string(text));
        break;
    case 18:
        this->notrade = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void Projectile::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 3:
        name = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> Projectile::printTree() const
{
    return createTreeItem();
}

Text Projectile::getName() const
{
    Text s;
    s = to_string(name);
    if (!s.empty())
        return s;
    s = text_id;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Projectile::operator==(const Projectile &rhs) const
{
    return
        text_id == rhs.text_id &&
        resource == rhs.resource &&
        name == rhs.name &&
        type == rhs.type &&
        subtype == rhs.subtype &&
        weight == rhs.weight &&
        damage == rhs.damage &&
        T == rhs.T &&
        speed == rhs.speed &&
        scale == rhs.scale &&
        numstate == rhs.numstate &&
        rotate == rhs.rotate &&
        life_time == rhs.life_time &&
        detonation_delay == rhs.detonation_delay &&
        distance_detonation == rhs.distance_detonation &&
        strength == rhs.strength &&
        price == rhs.price &&
        notrade == rhs.notrade &&
        1;
}

void Projectile::copyFrom(const Projectile &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    resource = rhs.resource;
    name = rhs.name;
    type = rhs.type;
    subtype = rhs.subtype;
    weight = rhs.weight;
    damage = rhs.damage;
    T = rhs.T;
    speed = rhs.speed;
    scale = rhs.scale;
    numstate = rhs.numstate;
    rotate = rhs.rotate;
    life_time = rhs.life_time;
    detonation_delay = rhs.detonation_delay;
    distance_detonation = rhs.distance_detonation;
    strength = rhs.strength;
    price = rhs.price;
    notrade = rhs.notrade;
}

const char *Projectile::getSql()
{
    return
    " \
create table \"Projectiles\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
\"type\" INTEGER, \
\"subtype\" INTEGER, \
\"weight\" REAL, \
\"damage\" REAL, \
\"T\" REAL, \
\"speed\" REAL, \
\"scale\" REAL, \
\"numstate\" INTEGER, \
\"rotate\" REAL, \
\"life_time\" REAL, \
\"detonation_delay\" REAL, \
\"distance_detonation\" REAL, \
\"strength\" REAL, \
\"price\" REAL, \
\"notrade\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

Quest::Quest()
{
    rewards = std::make_shared<CTable<QuestReward>>();
}

Quest::Quest(const Quest &rhs)
{
    copyFrom(rhs);
}

Quest &Quest::operator=(const Quest &rhs)
{
    copyFrom(rhs);
    return *this;
}

Quest::~Quest()
{
}

EObjectType Quest::getType() const
{
    return object_type;
}

Text Quest::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(name);
    case 2:
        return to_string(title);
    case 3:
        return to_string(description);
    case 4:
        return to_string(time);
    default:
        return "";
    };
    return "";
}

void Quest::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 4:
        this->time = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void Quest::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 1:
        name = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 2:
        title = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 3:
        description = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> Quest::printTree() const
{
    auto item = createTreeItem();

    Ptr<TreeItem> root;
    Ptr<TreeItem> tmp;

    root = std::make_shared<TreeItem>();
    root->name = "Rewards";
    root->type = EObjectType::QuestReward;
    root->parent = item.get();
    for (auto &v : *rewards)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    return item;
}

Text Quest::getName() const
{
    Text s;
    s = to_string(name);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Quest::operator==(const Quest &rhs) const
{
    return
        name == rhs.name &&
        title == rhs.title &&
        description == rhs.description &&
        time == rhs.time &&
        1;
}

void Quest::copyFrom(const Quest &rhs)
{
    id = rhs.id;
    name = rhs.name;
    title = rhs.title;
    description = rhs.description;
    time = rhs.time;

    rewards = std::make_shared<CTable<QuestReward>>(*rhs.rewards);
}

const char *Quest::getSql()
{
    return
    " \
create table \"Quests\" ( \
\"id\" INTEGER, \
\"name_id\" INTEGER, \
\"title_id\" INTEGER, \
\"description_id\" INTEGER, \
\"time\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\"), \
FOREIGN KEY (\"title_id\") REFERENCES \"Strings\" (\"id\"), \
FOREIGN KEY (\"description_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

QuestReward::QuestReward()
{
    equipments = std::make_shared<CTable<QuestRewardEquipment>>();
    gliders = std::make_shared<CTable<QuestRewardGlider>>();
    goods = std::make_shared<CTable<QuestRewardGood>>();
    modificators = std::make_shared<CTable<QuestRewardModificator>>();
    projectiles = std::make_shared<CTable<QuestRewardProjectile>>();
    reputations = std::make_shared<CTable<QuestRewardReputation>>();
    weapons = std::make_shared<CTable<QuestRewardWeapon>>();
}

QuestReward::QuestReward(const QuestReward &rhs)
{
    copyFrom(rhs);
}

QuestReward &QuestReward::operator=(const QuestReward &rhs)
{
    copyFrom(rhs);
    return *this;
}

QuestReward::~QuestReward()
{
}

EObjectType QuestReward::getType() const
{
    return object_type;
}

Text QuestReward::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(quest);
    case 3:
        return to_string(money);
    case 4:
        return to_string(rating);
    default:
        return "";
    };
    return "";
}

void QuestReward::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 3:
        this->money = std::stof(to_string(text));
        break;
    case 4:
        this->rating = std::stof(to_string(text));
        break;
    default:
        break;
    };
}

void QuestReward::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 2:
        quest = std::static_pointer_cast<Quest>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> QuestReward::printTree() const
{
    auto item = createTreeItem();

    Ptr<TreeItem> root;
    Ptr<TreeItem> tmp;

    root = std::make_shared<TreeItem>();
    root->name = "Equipments";
    root->type = EObjectType::QuestRewardEquipment;
    root->parent = item.get();
    for (auto &v : *equipments)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Gliders";
    root->type = EObjectType::QuestRewardGlider;
    root->parent = item.get();
    for (auto &v : *gliders)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Goods";
    root->type = EObjectType::QuestRewardGood;
    root->parent = item.get();
    for (auto &v : *goods)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Modificators";
    root->type = EObjectType::QuestRewardModificator;
    root->parent = item.get();
    for (auto &v : *modificators)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Projectiles";
    root->type = EObjectType::QuestRewardProjectile;
    root->parent = item.get();
    for (auto &v : *projectiles)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Reputations";
    root->type = EObjectType::QuestRewardReputation;
    root->parent = item.get();
    for (auto &v : *reputations)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    root = std::make_shared<TreeItem>();
    root->name = "Weapons";
    root->type = EObjectType::QuestRewardWeapon;
    root->parent = item.get();
    for (auto &v : *weapons)
    {
        root->children.push_back(tmp = v->printTree());
        tmp->parent = root.get();
    }
    item->children.push_back(root);

    return item;
}

Text QuestReward::getName() const
{
    Text s;
    s = to_string(quest);
    if (!s.empty())
        return s;
    s = text_id;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool QuestReward::operator==(const QuestReward &rhs) const
{
    return
        text_id == rhs.text_id &&
        quest == rhs.quest &&
        money == rhs.money &&
        rating == rhs.rating &&
        1;
}

void QuestReward::copyFrom(const QuestReward &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    quest = rhs.quest;
    money = rhs.money;
    rating = rhs.rating;

    equipments = std::make_shared<CTable<QuestRewardEquipment>>(*rhs.equipments);
    gliders = std::make_shared<CTable<QuestRewardGlider>>(*rhs.gliders);
    goods = std::make_shared<CTable<QuestRewardGood>>(*rhs.goods);
    modificators = std::make_shared<CTable<QuestRewardModificator>>(*rhs.modificators);
    projectiles = std::make_shared<CTable<QuestRewardProjectile>>(*rhs.projectiles);
    reputations = std::make_shared<CTable<QuestRewardReputation>>(*rhs.reputations);
    weapons = std::make_shared<CTable<QuestRewardWeapon>>(*rhs.weapons);
}

const char *QuestReward::getSql()
{
    return
    " \
create table \"QuestRewards\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"quest_id\" INTEGER, \
\"money\" REAL, \
\"rating\" REAL, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"quest_id\") REFERENCES \"Quests\" (\"id\") \
); \
    ";
}

QuestRewardEquipment::QuestRewardEquipment()
{
}

QuestRewardEquipment::QuestRewardEquipment(const QuestRewardEquipment &rhs)
{
    copyFrom(rhs);
}

QuestRewardEquipment &QuestRewardEquipment::operator=(const QuestRewardEquipment &rhs)
{
    copyFrom(rhs);
    return *this;
}

QuestRewardEquipment::~QuestRewardEquipment()
{
}

EObjectType QuestRewardEquipment::getType() const
{
    return object_type;
}

Text QuestRewardEquipment::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(quest_reward);
    case 1:
        return to_string(equipment);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void QuestRewardEquipment::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void QuestRewardEquipment::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        quest_reward = std::static_pointer_cast<QuestReward>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        equipment = std::static_pointer_cast<Equipment>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> QuestRewardEquipment::printTree() const
{
    return createTreeItem();
}

Text QuestRewardEquipment::getName() const
{
    Text s;
    s = to_string(quest_reward);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool QuestRewardEquipment::operator==(const QuestRewardEquipment &rhs) const
{
    return
        quest_reward == rhs.quest_reward &&
        equipment == rhs.equipment &&
        quantity == rhs.quantity &&
        1;
}

Ptr<QuestReward> QuestRewardEquipment::operator->() const
{
    if (quest_reward)
        return quest_reward;
    throw EXCEPTION("Value is missing");
}

void QuestRewardEquipment::copyFrom(const QuestRewardEquipment &rhs)
{
    quest_reward = rhs.quest_reward;
    equipment = rhs.equipment;
    quantity = rhs.quantity;
}

const char *QuestRewardEquipment::getSql()
{
    return
    " \
create table \"QuestRewardEquipments\" ( \
\"quest_reward_id\" INTEGER, \
\"equipment_id\" INTEGER, \
\"quantity\" INTEGER, \
FOREIGN KEY (\"quest_reward_id\") REFERENCES \"QuestRewards\" (\"id\"), \
FOREIGN KEY (\"equipment_id\") REFERENCES \"Equipments\" (\"id\") \
); \
    ";
}

QuestRewardGlider::QuestRewardGlider()
{
}

QuestRewardGlider::QuestRewardGlider(const QuestRewardGlider &rhs)
{
    copyFrom(rhs);
}

QuestRewardGlider &QuestRewardGlider::operator=(const QuestRewardGlider &rhs)
{
    copyFrom(rhs);
    return *this;
}

QuestRewardGlider::~QuestRewardGlider()
{
}

EObjectType QuestRewardGlider::getType() const
{
    return object_type;
}

Text QuestRewardGlider::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(quest_reward);
    case 1:
        return to_string(glider);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void QuestRewardGlider::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void QuestRewardGlider::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        quest_reward = std::static_pointer_cast<QuestReward>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        glider = std::static_pointer_cast<Glider>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> QuestRewardGlider::printTree() const
{
    return createTreeItem();
}

Text QuestRewardGlider::getName() const
{
    Text s;
    s = to_string(quest_reward);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool QuestRewardGlider::operator==(const QuestRewardGlider &rhs) const
{
    return
        quest_reward == rhs.quest_reward &&
        glider == rhs.glider &&
        quantity == rhs.quantity &&
        1;
}

Ptr<QuestReward> QuestRewardGlider::operator->() const
{
    if (quest_reward)
        return quest_reward;
    throw EXCEPTION("Value is missing");
}

void QuestRewardGlider::copyFrom(const QuestRewardGlider &rhs)
{
    quest_reward = rhs.quest_reward;
    glider = rhs.glider;
    quantity = rhs.quantity;
}

const char *QuestRewardGlider::getSql()
{
    return
    " \
create table \"QuestRewardGliders\" ( \
\"quest_reward_id\" INTEGER, \
\"glider_id\" INTEGER, \
\"quantity\" INTEGER, \
FOREIGN KEY (\"quest_reward_id\") REFERENCES \"QuestRewards\" (\"id\"), \
FOREIGN KEY (\"glider_id\") REFERENCES \"Gliders\" (\"id\") \
); \
    ";
}

QuestRewardGood::QuestRewardGood()
{
}

QuestRewardGood::QuestRewardGood(const QuestRewardGood &rhs)
{
    copyFrom(rhs);
}

QuestRewardGood &QuestRewardGood::operator=(const QuestRewardGood &rhs)
{
    copyFrom(rhs);
    return *this;
}

QuestRewardGood::~QuestRewardGood()
{
}

EObjectType QuestRewardGood::getType() const
{
    return object_type;
}

Text QuestRewardGood::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(quest_reward);
    case 1:
        return to_string(good);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void QuestRewardGood::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void QuestRewardGood::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        quest_reward = std::static_pointer_cast<QuestReward>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        good = std::static_pointer_cast<Good>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> QuestRewardGood::printTree() const
{
    return createTreeItem();
}

Text QuestRewardGood::getName() const
{
    Text s;
    s = to_string(quest_reward);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool QuestRewardGood::operator==(const QuestRewardGood &rhs) const
{
    return
        quest_reward == rhs.quest_reward &&
        good == rhs.good &&
        quantity == rhs.quantity &&
        1;
}

Ptr<QuestReward> QuestRewardGood::operator->() const
{
    if (quest_reward)
        return quest_reward;
    throw EXCEPTION("Value is missing");
}

void QuestRewardGood::copyFrom(const QuestRewardGood &rhs)
{
    quest_reward = rhs.quest_reward;
    good = rhs.good;
    quantity = rhs.quantity;
}

const char *QuestRewardGood::getSql()
{
    return
    " \
create table \"QuestRewardGoods\" ( \
\"quest_reward_id\" INTEGER, \
\"good_id\" INTEGER, \
\"quantity\" INTEGER, \
FOREIGN KEY (\"quest_reward_id\") REFERENCES \"QuestRewards\" (\"id\"), \
FOREIGN KEY (\"good_id\") REFERENCES \"Goods\" (\"id\") \
); \
    ";
}

QuestRewardModificator::QuestRewardModificator()
{
}

QuestRewardModificator::QuestRewardModificator(const QuestRewardModificator &rhs)
{
    copyFrom(rhs);
}

QuestRewardModificator &QuestRewardModificator::operator=(const QuestRewardModificator &rhs)
{
    copyFrom(rhs);
    return *this;
}

QuestRewardModificator::~QuestRewardModificator()
{
}

EObjectType QuestRewardModificator::getType() const
{
    return object_type;
}

Text QuestRewardModificator::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(quest_reward);
    case 1:
        return to_string(modificator);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void QuestRewardModificator::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void QuestRewardModificator::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        quest_reward = std::static_pointer_cast<QuestReward>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        modificator = std::static_pointer_cast<Modificator>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> QuestRewardModificator::printTree() const
{
    return createTreeItem();
}

Text QuestRewardModificator::getName() const
{
    Text s;
    s = to_string(quest_reward);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool QuestRewardModificator::operator==(const QuestRewardModificator &rhs) const
{
    return
        quest_reward == rhs.quest_reward &&
        modificator == rhs.modificator &&
        quantity == rhs.quantity &&
        1;
}

Ptr<QuestReward> QuestRewardModificator::operator->() const
{
    if (quest_reward)
        return quest_reward;
    throw EXCEPTION("Value is missing");
}

void QuestRewardModificator::copyFrom(const QuestRewardModificator &rhs)
{
    quest_reward = rhs.quest_reward;
    modificator = rhs.modificator;
    quantity = rhs.quantity;
}

const char *QuestRewardModificator::getSql()
{
    return
    " \
create table \"QuestRewardModificators\" ( \
\"quest_reward_id\" INTEGER, \
\"modificator_id\" INTEGER, \
\"quantity\" INTEGER, \
FOREIGN KEY (\"quest_reward_id\") REFERENCES \"QuestRewards\" (\"id\"), \
FOREIGN KEY (\"modificator_id\") REFERENCES \"Modificators\" (\"id\") \
); \
    ";
}

QuestRewardProjectile::QuestRewardProjectile()
{
}

QuestRewardProjectile::QuestRewardProjectile(const QuestRewardProjectile &rhs)
{
    copyFrom(rhs);
}

QuestRewardProjectile &QuestRewardProjectile::operator=(const QuestRewardProjectile &rhs)
{
    copyFrom(rhs);
    return *this;
}

QuestRewardProjectile::~QuestRewardProjectile()
{
}

EObjectType QuestRewardProjectile::getType() const
{
    return object_type;
}

Text QuestRewardProjectile::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(quest_reward);
    case 1:
        return to_string(projectile);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void QuestRewardProjectile::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void QuestRewardProjectile::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        quest_reward = std::static_pointer_cast<QuestReward>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        projectile = std::static_pointer_cast<Projectile>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> QuestRewardProjectile::printTree() const
{
    return createTreeItem();
}

Text QuestRewardProjectile::getName() const
{
    Text s;
    s = to_string(quest_reward);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool QuestRewardProjectile::operator==(const QuestRewardProjectile &rhs) const
{
    return
        quest_reward == rhs.quest_reward &&
        projectile == rhs.projectile &&
        quantity == rhs.quantity &&
        1;
}

Ptr<QuestReward> QuestRewardProjectile::operator->() const
{
    if (quest_reward)
        return quest_reward;
    throw EXCEPTION("Value is missing");
}

void QuestRewardProjectile::copyFrom(const QuestRewardProjectile &rhs)
{
    quest_reward = rhs.quest_reward;
    projectile = rhs.projectile;
    quantity = rhs.quantity;
}

const char *QuestRewardProjectile::getSql()
{
    return
    " \
create table \"QuestRewardProjectiles\" ( \
\"quest_reward_id\" INTEGER, \
\"projectile_id\" INTEGER, \
\"quantity\" INTEGER, \
FOREIGN KEY (\"quest_reward_id\") REFERENCES \"QuestRewards\" (\"id\"), \
FOREIGN KEY (\"projectile_id\") REFERENCES \"Projectiles\" (\"id\") \
); \
    ";
}

QuestRewardReputation::QuestRewardReputation()
{
}

QuestRewardReputation::QuestRewardReputation(const QuestRewardReputation &rhs)
{
    copyFrom(rhs);
}

QuestRewardReputation &QuestRewardReputation::operator=(const QuestRewardReputation &rhs)
{
    copyFrom(rhs);
    return *this;
}

QuestRewardReputation::~QuestRewardReputation()
{
}

EObjectType QuestRewardReputation::getType() const
{
    return object_type;
}

Text QuestRewardReputation::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(quest_reward);
    case 1:
        return to_string(clan);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void QuestRewardReputation::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stof(to_string(text));
        break;
    default:
        break;
    };
}

void QuestRewardReputation::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        quest_reward = std::static_pointer_cast<QuestReward>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        clan = std::static_pointer_cast<Clan>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> QuestRewardReputation::printTree() const
{
    return createTreeItem();
}

Text QuestRewardReputation::getName() const
{
    Text s;
    s = to_string(quest_reward);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool QuestRewardReputation::operator==(const QuestRewardReputation &rhs) const
{
    return
        quest_reward == rhs.quest_reward &&
        clan == rhs.clan &&
        quantity == rhs.quantity &&
        1;
}

Ptr<QuestReward> QuestRewardReputation::operator->() const
{
    if (quest_reward)
        return quest_reward;
    throw EXCEPTION("Value is missing");
}

void QuestRewardReputation::copyFrom(const QuestRewardReputation &rhs)
{
    quest_reward = rhs.quest_reward;
    clan = rhs.clan;
    quantity = rhs.quantity;
}

const char *QuestRewardReputation::getSql()
{
    return
    " \
create table \"QuestRewardReputations\" ( \
\"quest_reward_id\" INTEGER, \
\"clan_id\" INTEGER, \
\"quantity\" REAL, \
FOREIGN KEY (\"quest_reward_id\") REFERENCES \"QuestRewards\" (\"id\"), \
FOREIGN KEY (\"clan_id\") REFERENCES \"Clans\" (\"id\") \
); \
    ";
}

QuestRewardWeapon::QuestRewardWeapon()
{
}

QuestRewardWeapon::QuestRewardWeapon(const QuestRewardWeapon &rhs)
{
    copyFrom(rhs);
}

QuestRewardWeapon &QuestRewardWeapon::operator=(const QuestRewardWeapon &rhs)
{
    copyFrom(rhs);
    return *this;
}

QuestRewardWeapon::~QuestRewardWeapon()
{
}

EObjectType QuestRewardWeapon::getType() const
{
    return object_type;
}

Text QuestRewardWeapon::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(quest_reward);
    case 1:
        return to_string(weapon);
    case 2:
        return to_string(quantity);
    default:
        return "";
    };
    return "";
}

void QuestRewardWeapon::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 2:
        this->quantity = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void QuestRewardWeapon::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 0:
        quest_reward = std::static_pointer_cast<QuestReward>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 1:
        weapon = std::static_pointer_cast<Weapon>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> QuestRewardWeapon::printTree() const
{
    return createTreeItem();
}

Text QuestRewardWeapon::getName() const
{
    Text s;
    s = to_string(quest_reward);
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool QuestRewardWeapon::operator==(const QuestRewardWeapon &rhs) const
{
    return
        quest_reward == rhs.quest_reward &&
        weapon == rhs.weapon &&
        quantity == rhs.quantity &&
        1;
}

Ptr<QuestReward> QuestRewardWeapon::operator->() const
{
    if (quest_reward)
        return quest_reward;
    throw EXCEPTION("Value is missing");
}

void QuestRewardWeapon::copyFrom(const QuestRewardWeapon &rhs)
{
    quest_reward = rhs.quest_reward;
    weapon = rhs.weapon;
    quantity = rhs.quantity;
}

const char *QuestRewardWeapon::getSql()
{
    return
    " \
create table \"QuestRewardWeapons\" ( \
\"quest_reward_id\" INTEGER, \
\"weapon_id\" INTEGER, \
\"quantity\" INTEGER, \
FOREIGN KEY (\"quest_reward_id\") REFERENCES \"QuestRewards\" (\"id\"), \
FOREIGN KEY (\"weapon_id\") REFERENCES \"Weapons\" (\"id\") \
); \
    ";
}

ScriptVariable::ScriptVariable()
{
}

ScriptVariable::ScriptVariable(const ScriptVariable &rhs)
{
    copyFrom(rhs);
}

ScriptVariable &ScriptVariable::operator=(const ScriptVariable &rhs)
{
    copyFrom(rhs);
    return *this;
}

ScriptVariable::~ScriptVariable()
{
}

EObjectType ScriptVariable::getType() const
{
    return object_type;
}

Text ScriptVariable::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(variable);
    case 2:
        return to_string(value_int);
    case 3:
        return to_string(value_float);
    case 4:
        return to_string(value_text);
    default:
        return "";
    };
    return "";
}

void ScriptVariable::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->variable = to_string(text);
        break;
    case 2:
        this->value_int = std::stoi(to_string(text));
        break;
    case 3:
        this->value_float = std::stof(to_string(text));
        break;
    case 4:
        this->value_text = to_string(text);
        break;
    default:
        break;
    };
}

void ScriptVariable::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    default:
        break;
    };
}

Ptr<TreeItem> ScriptVariable::printTree() const
{
    return createTreeItem();
}

Text ScriptVariable::getName() const
{
    Text s;
    s = variable;
    if (!s.empty())
        return s;
    s = value_text;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool ScriptVariable::operator==(const ScriptVariable &rhs) const
{
    return
        variable == rhs.variable &&
        value_int == rhs.value_int &&
        value_float == rhs.value_float &&
        value_text == rhs.value_text &&
        1;
}

void ScriptVariable::copyFrom(const ScriptVariable &rhs)
{
    id = rhs.id;
    variable = rhs.variable;
    value_int = rhs.value_int;
    value_float = rhs.value_float;
    value_text = rhs.value_text;
}

const char *ScriptVariable::getSql()
{
    return
    " \
create table \"ScriptVariables\" ( \
\"id\" INTEGER, \
\"variable\" TEXT, \
\"value_int\" INTEGER, \
\"value_float\" REAL, \
\"value_text\" TEXT, \
PRIMARY KEY (\"id\") \
); \
    ";
}

Setting::Setting()
{
}

Setting::Setting(const Setting &rhs)
{
    copyFrom(rhs);
}

Setting &Setting::operator=(const Setting &rhs)
{
    copyFrom(rhs);
    return *this;
}

Setting::~Setting()
{
}

EObjectType Setting::getType() const
{
    return object_type;
}

Text Setting::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(player);
    case 3:
        return to_string(value_int);
    case 4:
        return to_string(value_float);
    case 5:
        return to_string(value_text);
    default:
        return "";
    };
    return "";
}

void Setting::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 3:
        this->value_int = std::stoi(to_string(text));
        break;
    case 4:
        this->value_float = std::stof(to_string(text));
        break;
    case 5:
        this->value_text = to_string(text);
        break;
    case 6:
        this->value_blob = text;
        break;
    default:
        break;
    };
}

void Setting::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 2:
        player = std::static_pointer_cast<Player>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> Setting::printTree() const
{
    return createTreeItem();
}

Text Setting::getName() const
{
    Text s;
    s = text_id;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Setting::operator==(const Setting &rhs) const
{
    return
        text_id == rhs.text_id &&
        player == rhs.player &&
        value_int == rhs.value_int &&
        value_float == rhs.value_float &&
        value_text == rhs.value_text &&
        value_blob == rhs.value_blob &&
        1;
}

void Setting::copyFrom(const Setting &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    player = rhs.player;
    value_int = rhs.value_int;
    value_float = rhs.value_float;
    value_text = rhs.value_text;
    value_blob = rhs.value_blob;
}

const char *Setting::getSql()
{
    return
    " \
create table \"Settings\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"player_id\" INTEGER, \
\"value_int\" INTEGER, \
\"value_float\" REAL, \
\"value_text\" TEXT, \
\"value_blob\" BLOB, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"player_id\") REFERENCES \"Players\" (\"id\") \
); \
    ";
}

String::String()
{
}

String::String(const String &rhs)
{
    copyFrom(rhs);
}

String &String::operator=(const String &rhs)
{
    copyFrom(rhs);
    return *this;
}

String::~String()
{
}

EObjectType String::getType() const
{
    return object_type;
}

Text String::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(table);
    case 3:
        return to_string(ru);
    case 4:
        return to_string(en);
    default:
        return "";
    };
    return "";
}

void String::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 3:
        this->ru = to_string(text);
        break;
    case 4:
        this->en = to_string(text);
        break;
    default:
        break;
    };
}

void String::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 2:
        table = std::static_pointer_cast<Table>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> String::printTree() const
{
    return createTreeItem();
}

Text String::getName() const
{
    auto s = ((Text *)&ru)[gCurrentLocalizationId];
    if (!s.empty())
        return s;
    s = text_id;
    if (!s.empty())
        return s;
    for (int i = 0; i < static_cast<int>(LocalizationType::max); i++)
    {
        s = ((Text *)&ru)[i];
        if (!s.empty())
            return s;
    }
    return s;
}

bool String::operator==(const String &rhs) const
{
    return
        text_id == rhs.text_id &&
        table == rhs.table &&
        ru == rhs.ru &&
        en == rhs.en &&
        1;
}

void String::copyFrom(const String &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    table = rhs.table;
    ru = rhs.ru;
    en = rhs.en;
}

const char *String::getSql()
{
    return
    " \
create table \"Strings\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"table_id\" INTEGER, \
\"ru\" TEXT, \
\"en\" TEXT, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"table_id\") REFERENCES \"Tables\" (\"id\") \
); \
    ";
}

Table::Table()
{
}

Table::Table(const Table &rhs)
{
    copyFrom(rhs);
}

Table &Table::operator=(const Table &rhs)
{
    copyFrom(rhs);
    return *this;
}

Table::~Table()
{
}

EObjectType Table::getType() const
{
    return object_type;
}

Text Table::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text);
    default:
        return "";
    };
    return "";
}

void Table::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text = to_string(text);
        break;
    default:
        break;
    };
}

void Table::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    default:
        break;
    };
}

Ptr<TreeItem> Table::printTree() const
{
    return createTreeItem();
}

Text Table::getName() const
{
    Text s;
    s = text;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Table::operator==(const Table &rhs) const
{
    return
        text == rhs.text &&
        1;
}

void Table::copyFrom(const Table &rhs)
{
    id = rhs.id;
    text = rhs.text;
}

const char *Table::getSql()
{
    return
    " \
create table \"Tables\" ( \
\"id\" INTEGER, \
\"text\" TEXT, \
PRIMARY KEY (\"id\") \
); \
    ";
}

Weapon::Weapon()
{
}

Weapon::Weapon(const Weapon &rhs)
{
    copyFrom(rhs);
}

Weapon &Weapon::operator=(const Weapon &rhs)
{
    copyFrom(rhs);
    return *this;
}

Weapon::~Weapon()
{
}

EObjectType Weapon::getType() const
{
    return object_type;
}

Text Weapon::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(projectile);
    case 5:
        return to_string(type);
    case 6:
        return to_string(standard);
    case 7:
        return to_string(weight);
    case 8:
        return to_string(power);
    case 9:
        return to_string(firerate);
    case 10:
        return to_string(damage);
    case 11:
        return to_string(price);
    case 12:
        return to_string(fx);
    case 13:
        return to_string(shoottype);
    case 14:
        return to_string(shootscale);
    case 15:
        return to_string(xstate);
    case 16:
        return to_string(rcolor);
    case 17:
        return to_string(gcolor);
    case 18:
        return to_string(bcolor);
    case 19:
        return to_string(typearms);
    case 20:
        return to_string(tfire);
    case 21:
        return to_string(vtype);
    case 22:
        return to_string(spare);
    case 23:
        return to_string(reconstruction);
    case 24:
        return to_string(maxdistance);
    case 25:
        return to_string(angle);
    case 26:
        return to_string(fxtime);
    case 27:
        return to_string(damagetype);
    case 28:
        return to_string(fxmodeltime);
    case 29:
        return to_string(inside_mul);
    case 30:
        return to_string(inside_x);
    case 31:
        return to_string(inside_y);
    case 32:
        return to_string(inside_z);
    case 33:
        return to_string(notrade);
    default:
        return "";
    };
    return "";
}

void Weapon::setVariableString(int columnId, const Text &text)
{
    switch (columnId)
    {
    case 0:
        this->id = std::stoi(to_string(text));
        break;
    case 1:
        this->text_id = to_string(text);
        break;
    case 2:
        this->resource = to_string(text);
        break;
    case 5:
        this->type = std::stoi(to_string(text));
        break;
    case 6:
        this->standard = std::stoi(to_string(text));
        break;
    case 7:
        this->weight = std::stof(to_string(text));
        break;
    case 8:
        this->power = std::stof(to_string(text));
        break;
    case 9:
        this->firerate = std::stof(to_string(text));
        break;
    case 10:
        this->damage = std::stof(to_string(text));
        break;
    case 11:
        this->price = std::stof(to_string(text));
        break;
    case 12:
        this->fx = std::stof(to_string(text));
        break;
    case 13:
        this->shoottype = std::stoi(to_string(text));
        break;
    case 14:
        this->shootscale = std::stof(to_string(text));
        break;
    case 15:
        this->xstate = std::stoi(to_string(text));
        break;
    case 16:
        this->rcolor = std::stof(to_string(text));
        break;
    case 17:
        this->gcolor = std::stof(to_string(text));
        break;
    case 18:
        this->bcolor = std::stof(to_string(text));
        break;
    case 19:
        this->typearms = std::stoi(to_string(text));
        break;
    case 20:
        this->tfire = std::stof(to_string(text));
        break;
    case 21:
        this->vtype = std::stoi(to_string(text));
        break;
    case 22:
        this->spare = std::stof(to_string(text));
        break;
    case 23:
        this->reconstruction = std::stof(to_string(text));
        break;
    case 24:
        this->maxdistance = std::stof(to_string(text));
        break;
    case 25:
        this->angle = std::stof(to_string(text));
        break;
    case 26:
        this->fxtime = std::stof(to_string(text));
        break;
    case 27:
        this->damagetype = std::stoi(to_string(text));
        break;
    case 28:
        this->fxmodeltime = std::stof(to_string(text));
        break;
    case 29:
        this->inside_mul = std::stof(to_string(text));
        break;
    case 30:
        this->inside_x = std::stof(to_string(text));
        break;
    case 31:
        this->inside_y = std::stof(to_string(text));
        break;
    case 32:
        this->inside_z = std::stof(to_string(text));
        break;
    case 33:
        this->notrade = std::stoi(to_string(text));
        break;
    default:
        break;
    };
}

void Weapon::setVariableString(int columnId, IObjectBase *ptr)
{
    switch (columnId)
    {
    case 3:
        name = std::static_pointer_cast<String>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    case 4:
        projectile = std::static_pointer_cast<Projectile>(std::shared_ptr<IObjectBase>(ptr, [](auto p){}));
        break;
    default:
        break;
    };
}

Ptr<TreeItem> Weapon::printTree() const
{
    return createTreeItem();
}

Text Weapon::getName() const
{
    Text s;
    s = to_string(name);
    if (!s.empty())
        return s;
    s = text_id;
    if (!s.empty())
        return s;
    return IObjectBase::getName();
}

bool Weapon::operator==(const Weapon &rhs) const
{
    return
        text_id == rhs.text_id &&
        resource == rhs.resource &&
        name == rhs.name &&
        projectile == rhs.projectile &&
        type == rhs.type &&
        standard == rhs.standard &&
        weight == rhs.weight &&
        power == rhs.power &&
        firerate == rhs.firerate &&
        damage == rhs.damage &&
        price == rhs.price &&
        fx == rhs.fx &&
        shoottype == rhs.shoottype &&
        shootscale == rhs.shootscale &&
        xstate == rhs.xstate &&
        rcolor == rhs.rcolor &&
        gcolor == rhs.gcolor &&
        bcolor == rhs.bcolor &&
        typearms == rhs.typearms &&
        tfire == rhs.tfire &&
        vtype == rhs.vtype &&
        spare == rhs.spare &&
        reconstruction == rhs.reconstruction &&
        maxdistance == rhs.maxdistance &&
        angle == rhs.angle &&
        fxtime == rhs.fxtime &&
        damagetype == rhs.damagetype &&
        fxmodeltime == rhs.fxmodeltime &&
        inside_mul == rhs.inside_mul &&
        inside_x == rhs.inside_x &&
        inside_y == rhs.inside_y &&
        inside_z == rhs.inside_z &&
        notrade == rhs.notrade &&
        1;
}

void Weapon::copyFrom(const Weapon &rhs)
{
    id = rhs.id;
    text_id = rhs.text_id;
    resource = rhs.resource;
    name = rhs.name;
    projectile = rhs.projectile;
    type = rhs.type;
    standard = rhs.standard;
    weight = rhs.weight;
    power = rhs.power;
    firerate = rhs.firerate;
    damage = rhs.damage;
    price = rhs.price;
    fx = rhs.fx;
    shoottype = rhs.shoottype;
    shootscale = rhs.shootscale;
    xstate = rhs.xstate;
    rcolor = rhs.rcolor;
    gcolor = rhs.gcolor;
    bcolor = rhs.bcolor;
    typearms = rhs.typearms;
    tfire = rhs.tfire;
    vtype = rhs.vtype;
    spare = rhs.spare;
    reconstruction = rhs.reconstruction;
    maxdistance = rhs.maxdistance;
    angle = rhs.angle;
    fxtime = rhs.fxtime;
    damagetype = rhs.damagetype;
    fxmodeltime = rhs.fxmodeltime;
    inside_mul = rhs.inside_mul;
    inside_x = rhs.inside_x;
    inside_y = rhs.inside_y;
    inside_z = rhs.inside_z;
    notrade = rhs.notrade;
}

const char *Weapon::getSql()
{
    return
    " \
create table \"Weapons\" ( \
\"id\" INTEGER, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
\"projectile_id\" INTEGER, \
\"type\" INTEGER, \
\"standard\" INTEGER, \
\"weight\" REAL, \
\"power\" REAL, \
\"firerate\" REAL, \
\"damage\" REAL, \
\"price\" REAL, \
\"fx\" REAL, \
\"shoottype\" INTEGER, \
\"shootscale\" REAL, \
\"xstate\" INTEGER, \
\"rcolor\" REAL, \
\"gcolor\" REAL, \
\"bcolor\" REAL, \
\"typearms\" INTEGER, \
\"tfire\" REAL, \
\"vtype\" INTEGER, \
\"spare\" REAL, \
\"reconstruction\" REAL, \
\"maxdistance\" REAL, \
\"angle\" REAL, \
\"fxtime\" REAL, \
\"damagetype\" INTEGER, \
\"fxmodeltime\" REAL, \
\"inside_mul\" REAL, \
\"inside_x\" REAL, \
\"inside_y\" REAL, \
\"inside_z\" REAL, \
\"notrade\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\"), \
FOREIGN KEY (\"projectile_id\") REFERENCES \"Projectiles\" (\"id\") \
); \
    ";
}

