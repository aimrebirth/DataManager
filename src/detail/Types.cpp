/* DO NOT EDIT! This is an autogenerated file. */

Text IObject::getName() const
{
    return POLYGON4_NONAME;
}

int Building::getId() const
{
    return id;
}

void Building::setId(int id)
{
    this->id = id;
}

EObjectType Building::getType() const
{
    return EObjectType::Building;
}

Text Building::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(interactive);
    default:
        return "";
    }
    return "";
}

void Building::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        text_id = text.string();
        break;
    case 2:
        resource = text.string();
        break;
    case 3:
        name = std::static_pointer_cast<String>(ptr);
        break;
    case 4:
        interactive = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Building::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Building::getName() const
{
    Text n;
    n = to_string(name);
    if (!n.empty())
        return n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool Building::operator==(const Building &rhs) const
{
    return
        interactive == rhs.interactive &&
        name == rhs.name &&
        resource == rhs.resource &&
        text_id == rhs.text_id &&
        1;
}

int Building::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) text_id = cols[1];
    if (cols[2]) resource = cols[2];
    if (cols[3]) name.id = std::stoi(cols[3]);
    if (cols[4]) interactive = std::stoi(cols[4]);

    return 0;
}

const char *Building::getSql()
{
    return
    " \
create table \"Buildings\" ( \
\"id\" INTEGER NOT NULL, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
\"interactive\" INTEGER DEFAULT 0, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

EObjectType ClanMechanoid::getType() const
{
    return EObjectType::ClanMechanoid;
}

Text ClanMechanoid::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(clan);
    case 1:
        return to_string(mechanoid);
    default:
        return "";
    }
    return "";
}

void ClanMechanoid::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        clan = std::static_pointer_cast<Clan>(ptr);
        break;
    case 1:
        mechanoid = std::static_pointer_cast<Mechanoid>(ptr);
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *ClanMechanoid::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text ClanMechanoid::getName() const
{
    Text n;
    n = to_string(mechanoid);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool ClanMechanoid::operator==(const ClanMechanoid &rhs) const
{
    return
        clan == rhs.clan &&
        mechanoid == rhs.mechanoid &&
        1;
}

IdPtr<Clan> ClanMechanoid::operator->() const
{
    if (clan)
        return clan;
    throw EXCEPTION("Value is missing");
}

int ClanMechanoid::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) clan.id = std::stoi(cols[0]);
    if (cols[1]) mechanoid.id = std::stoi(cols[1]);

    return 0;
}

const char *ClanMechanoid::getSql()
{
    return
    " \
create table \"ClanMechanoids\" ( \
\"clan_id\" INTEGER NOT NULL, \
\"mechanoid_id\" INTEGER NOT NULL, \
PRIMARY KEY (\"mechanoid_id\"), \
FOREIGN KEY (\"clan_id\") REFERENCES \"Clans\" (\"id\"), \
FOREIGN KEY (\"mechanoid_id\") REFERENCES \"Mechanoids\" (\"id\") \
); \
    ";
}

EObjectType ClanReputation::getType() const
{
    return EObjectType::ClanReputation;
}

Text ClanReputation::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(clan);
    case 1:
        return to_string(clan2);
    case 2:
        return to_string(reputation);
    default:
        return "";
    }
    return "";
}

void ClanReputation::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        clan = std::static_pointer_cast<Clan>(ptr);
        break;
    case 1:
        clan2 = std::static_pointer_cast<Clan>(ptr);
        break;
    case 2:
        reputation = std::stof(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *ClanReputation::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text ClanReputation::getName() const
{
    Text n;
    n = clan.id < clan2.id ? (to_string(clan).wstring() + L" - " + to_string(clan2).wstring()) : (to_string(clan2).wstring() + L" - " + to_string(clan).wstring());
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool ClanReputation::operator==(const ClanReputation &rhs) const
{
    return
        clan == rhs.clan &&
        clan2 == rhs.clan2 &&
        reputation == rhs.reputation &&
        1;
}

int ClanReputation::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) clan.id = std::stoi(cols[0]);
    if (cols[1]) clan2.id = std::stoi(cols[1]);
    if (cols[2]) reputation = std::stof(cols[2]);

    return 0;
}

const char *ClanReputation::getSql()
{
    return
    " \
create table \"ClanReputations\" ( \
\"clan_id\" INTEGER NOT NULL, \
\"clan_id2\" INTEGER NOT NULL, \
\"reputation\" REAL, \
PRIMARY KEY (\"clan_id\", \"clan_id2\"), \
FOREIGN KEY (\"clan_id\") REFERENCES \"Clans\" (\"id\"), \
FOREIGN KEY (\"clan_id2\") REFERENCES \"Clans\" (\"id\") \
); \
    ";
}

int Clan::getId() const
{
    return id;
}

void Clan::setId(int id)
{
    this->id = id;
}

EObjectType Clan::getType() const
{
    return EObjectType::Clan;
}

Text Clan::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    default:
        return "";
    }
    return "";
}

void Clan::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        text_id = text.string();
        break;
    case 2:
        resource = text.string();
        break;
    case 3:
        name = std::static_pointer_cast<String>(ptr);
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Clan::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);

    QTreeWidgetItem *root;

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Mechanoids")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::ClanMechanoid));
    for (auto &mechanoid : mechanoids)
        mechanoid->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Reputations")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::ClanReputation));
    for (auto &reputation : reputations)
        reputation->printQtTreeView(root);

    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Clan::getName() const
{
    Text n;
    n = to_string(name);
    if (!n.empty())
        return n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool Clan::operator==(const Clan &rhs) const
{
    return
        name == rhs.name &&
        resource == rhs.resource &&
        text_id == rhs.text_id &&
        1;
}

int Clan::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) text_id = cols[1];
    if (cols[2]) resource = cols[2];
    if (cols[3]) name.id = std::stoi(cols[3]);

    return 0;
}

const char *Clan::getSql()
{
    return
    " \
create table \"Clans\" ( \
\"id\" INTEGER NOT NULL, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

EObjectType ConfigurationEquipment::getType() const
{
    return EObjectType::ConfigurationEquipment;
}

Text ConfigurationEquipment::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(configuration);
    case 1:
        return to_string(equipment);
    case 2:
        return to_string(quantity);
    default:
        return "";
    }
    return "";
}

void ConfigurationEquipment::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        configuration = std::static_pointer_cast<Configuration>(ptr);
        break;
    case 1:
        equipment = std::static_pointer_cast<Equipment>(ptr);
        break;
    case 2:
        quantity = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *ConfigurationEquipment::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text ConfigurationEquipment::getName() const
{
    Text n;
    n = to_string(equipment);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool ConfigurationEquipment::operator==(const ConfigurationEquipment &rhs) const
{
    return
        configuration == rhs.configuration &&
        equipment == rhs.equipment &&
        quantity == rhs.quantity &&
        1;
}

IdPtr<Configuration> ConfigurationEquipment::operator->() const
{
    if (configuration)
        return configuration;
    throw EXCEPTION("Value is missing");
}

int ConfigurationEquipment::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) configuration.id = std::stoi(cols[0]);
    if (cols[1]) equipment.id = std::stoi(cols[1]);
    if (cols[2]) quantity = std::stoi(cols[2]);

    return 0;
}

const char *ConfigurationEquipment::getSql()
{
    return
    " \
create table \"ConfigurationEquipments\" ( \
\"configuration_id\" INTEGER NOT NULL, \
\"equipment_id\" INTEGER NOT NULL, \
\"quantity\" INTEGER, \
PRIMARY KEY (\"configuration_id\", \"equipment_id\"), \
FOREIGN KEY (\"configuration_id\") REFERENCES \"Configurations\" (\"id\"), \
FOREIGN KEY (\"equipment_id\") REFERENCES \"Equipments\" (\"id\") \
); \
    ";
}

EObjectType ConfigurationGood::getType() const
{
    return EObjectType::ConfigurationGood;
}

Text ConfigurationGood::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(configuration);
    case 1:
        return to_string(good);
    case 2:
        return to_string(quantity);
    default:
        return "";
    }
    return "";
}

void ConfigurationGood::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        configuration = std::static_pointer_cast<Configuration>(ptr);
        break;
    case 1:
        good = std::static_pointer_cast<Good>(ptr);
        break;
    case 2:
        quantity = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *ConfigurationGood::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text ConfigurationGood::getName() const
{
    Text n;
    n = to_string(good);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool ConfigurationGood::operator==(const ConfigurationGood &rhs) const
{
    return
        configuration == rhs.configuration &&
        good == rhs.good &&
        quantity == rhs.quantity &&
        1;
}

IdPtr<Configuration> ConfigurationGood::operator->() const
{
    if (configuration)
        return configuration;
    throw EXCEPTION("Value is missing");
}

int ConfigurationGood::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) configuration.id = std::stoi(cols[0]);
    if (cols[1]) good.id = std::stoi(cols[1]);
    if (cols[2]) quantity = std::stoi(cols[2]);

    return 0;
}

const char *ConfigurationGood::getSql()
{
    return
    " \
create table \"ConfigurationGoods\" ( \
\"configuration_id\" INTEGER NOT NULL, \
\"good_id\" INTEGER NOT NULL, \
\"quantity\" INTEGER, \
PRIMARY KEY (\"configuration_id\", \"good_id\"), \
FOREIGN KEY (\"configuration_id\") REFERENCES \"Configurations\" (\"id\"), \
FOREIGN KEY (\"good_id\") REFERENCES \"Goods\" (\"id\") \
); \
    ";
}

EObjectType ConfigurationProjectile::getType() const
{
    return EObjectType::ConfigurationProjectile;
}

Text ConfigurationProjectile::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(configuration);
    case 1:
        return to_string(projectile);
    case 2:
        return to_string(quantity);
    default:
        return "";
    }
    return "";
}

void ConfigurationProjectile::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        configuration = std::static_pointer_cast<Configuration>(ptr);
        break;
    case 1:
        projectile = std::static_pointer_cast<Projectile>(ptr);
        break;
    case 2:
        quantity = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *ConfigurationProjectile::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text ConfigurationProjectile::getName() const
{
    Text n;
    n = to_string(projectile);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool ConfigurationProjectile::operator==(const ConfigurationProjectile &rhs) const
{
    return
        configuration == rhs.configuration &&
        projectile == rhs.projectile &&
        quantity == rhs.quantity &&
        1;
}

IdPtr<Configuration> ConfigurationProjectile::operator->() const
{
    if (configuration)
        return configuration;
    throw EXCEPTION("Value is missing");
}

int ConfigurationProjectile::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) configuration.id = std::stoi(cols[0]);
    if (cols[1]) projectile.id = std::stoi(cols[1]);
    if (cols[2]) quantity = std::stoi(cols[2]);

    return 0;
}

const char *ConfigurationProjectile::getSql()
{
    return
    " \
create table \"ConfigurationProjectiles\" ( \
\"configuration_id\" INTEGER NOT NULL, \
\"projectile_id\" INTEGER NOT NULL, \
\"quantity\" INTEGER, \
PRIMARY KEY (\"configuration_id\", \"projectile_id\"), \
FOREIGN KEY (\"configuration_id\") REFERENCES \"Configurations\" (\"id\"), \
FOREIGN KEY (\"projectile_id\") REFERENCES \"Projectiles\" (\"id\") \
); \
    ";
}

EObjectType ConfigurationWeapon::getType() const
{
    return EObjectType::ConfigurationWeapon;
}

Text ConfigurationWeapon::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(configuration);
    case 1:
        return to_string(weapon);
    case 2:
        return to_string(quantity);
    default:
        return "";
    }
    return "";
}

void ConfigurationWeapon::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        configuration = std::static_pointer_cast<Configuration>(ptr);
        break;
    case 1:
        weapon = std::static_pointer_cast<Weapon>(ptr);
        break;
    case 2:
        quantity = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *ConfigurationWeapon::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text ConfigurationWeapon::getName() const
{
    Text n;
    n = to_string(weapon);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool ConfigurationWeapon::operator==(const ConfigurationWeapon &rhs) const
{
    return
        configuration == rhs.configuration &&
        quantity == rhs.quantity &&
        weapon == rhs.weapon &&
        1;
}

IdPtr<Configuration> ConfigurationWeapon::operator->() const
{
    if (configuration)
        return configuration;
    throw EXCEPTION("Value is missing");
}

int ConfigurationWeapon::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) configuration.id = std::stoi(cols[0]);
    if (cols[1]) weapon.id = std::stoi(cols[1]);
    if (cols[2]) quantity = std::stoi(cols[2]);

    return 0;
}

const char *ConfigurationWeapon::getSql()
{
    return
    " \
create table \"ConfigurationWeapons\" ( \
\"configuration_id\" INTEGER NOT NULL, \
\"weapon_id\" INTEGER NOT NULL, \
\"quantity\" INTEGER, \
PRIMARY KEY (\"configuration_id\", \"weapon_id\"), \
FOREIGN KEY (\"configuration_id\") REFERENCES \"Configurations\" (\"id\"), \
FOREIGN KEY (\"weapon_id\") REFERENCES \"Weapons\" (\"id\") \
); \
    ";
}

int Configuration::getId() const
{
    return id;
}

void Configuration::setId(int id)
{
    this->id = id;
}

EObjectType Configuration::getType() const
{
    return EObjectType::Configuration;
}

Text Configuration::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(name);
    case 3:
        return to_string(glider);
    default:
        return "";
    }
    return "";
}

void Configuration::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        text_id = text.string();
        break;
    case 2:
        name = std::static_pointer_cast<String>(ptr);
        break;
    case 3:
        glider = std::static_pointer_cast<Glider>(ptr);
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Configuration::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);

    QTreeWidgetItem *root;

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Equipments")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::ConfigurationEquipment));
    for (auto &equipment : equipments)
        equipment->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Goods")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::ConfigurationGood));
    for (auto &good : goods)
        good->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Projectiles")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::ConfigurationProjectile));
    for (auto &projectile : projectiles)
        projectile->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Weapons")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::ConfigurationWeapon));
    for (auto &weapon : weapons)
        weapon->printQtTreeView(root);

    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Configuration::getName() const
{
    Text n;
    n = to_string(name);
    if (!n.empty())
        return n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool Configuration::operator==(const Configuration &rhs) const
{
    return
        glider == rhs.glider &&
        name == rhs.name &&
        text_id == rhs.text_id &&
        1;
}

int Configuration::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) text_id = cols[1];
    if (cols[2]) name.id = std::stoi(cols[2]);
    if (cols[3]) glider.id = std::stoi(cols[3]);

    return 0;
}

const char *Configuration::getSql()
{
    return
    " \
create table \"Configurations\" ( \
\"id\" INTEGER NOT NULL, \
\"text_id\" TEXT, \
\"name_id\" INTEGER, \
\"glider_id\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\"), \
FOREIGN KEY (\"glider_id\") REFERENCES \"Gliders\" (\"id\") \
); \
    ";
}

int Equipment::getId() const
{
    return id;
}

void Equipment::setId(int id)
{
    this->id = id;
}

EObjectType Equipment::getType() const
{
    return EObjectType::Equipment;
}

Text Equipment::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(type);
    case 5:
        return to_string(standard);
    case 6:
        return to_string(weight);
    case 7:
        return to_string(durability);
    case 8:
        return to_string(power);
    case 9:
        return to_string(value1);
    case 10:
        return to_string(value2);
    case 11:
        return to_string(value3);
    case 12:
        return to_string(manual);
    case 13:
        return to_string(price);
    case 14:
        return to_string(notrade);
    default:
        return "";
    }
    return "";
}

void Equipment::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        text_id = text.string();
        break;
    case 2:
        resource = text.string();
        break;
    case 3:
        name = std::static_pointer_cast<String>(ptr);
        break;
    case 4:
        type = std::stoi(text.string());
        break;
    case 5:
        standard = std::stoi(text.string());
        break;
    case 6:
        weight = std::stof(text.string());
        break;
    case 7:
        durability = std::stof(text.string());
        break;
    case 8:
        power = std::stof(text.string());
        break;
    case 9:
        value1 = std::stof(text.string());
        break;
    case 10:
        value2 = std::stof(text.string());
        break;
    case 11:
        value3 = std::stof(text.string());
        break;
    case 12:
        manual = std::stoi(text.string());
        break;
    case 13:
        price = std::stof(text.string());
        break;
    case 14:
        notrade = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Equipment::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Equipment::getName() const
{
    Text n;
    n = to_string(name);
    if (!n.empty())
        return n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool Equipment::operator==(const Equipment &rhs) const
{
    return
        durability == rhs.durability &&
        manual == rhs.manual &&
        name == rhs.name &&
        notrade == rhs.notrade &&
        power == rhs.power &&
        price == rhs.price &&
        resource == rhs.resource &&
        standard == rhs.standard &&
        text_id == rhs.text_id &&
        type == rhs.type &&
        value1 == rhs.value1 &&
        value2 == rhs.value2 &&
        value3 == rhs.value3 &&
        weight == rhs.weight &&
        1;
}

int Equipment::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) text_id = cols[1];
    if (cols[2]) resource = cols[2];
    if (cols[3]) name.id = std::stoi(cols[3]);
    if (cols[4]) type = std::stoi(cols[4]);
    if (cols[5]) standard = std::stoi(cols[5]);
    if (cols[6]) weight = std::stof(cols[6]);
    if (cols[7]) durability = std::stof(cols[7]);
    if (cols[8]) power = std::stof(cols[8]);
    if (cols[9]) value1 = std::stof(cols[9]);
    if (cols[10]) value2 = std::stof(cols[10]);
    if (cols[11]) value3 = std::stof(cols[11]);
    if (cols[12]) manual = std::stoi(cols[12]);
    if (cols[13]) price = std::stof(cols[13]);
    if (cols[14]) notrade = std::stoi(cols[14]);

    return 0;
}

const char *Equipment::getSql()
{
    return
    " \
create table \"Equipments\" ( \
\"id\" INTEGER NOT NULL, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
\"type\" INTEGER, \
\"standard\" INTEGER, \
\"weight\" REAL, \
\"durability\" REAL, \
\"power\" REAL, \
\"value1\" REAL, \
\"value2\" REAL, \
\"value3\" REAL, \
\"manual\" INTEGER, \
\"price\" REAL, \
\"notrade\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

int Glider::getId() const
{
    return id;
}

void Glider::setId(int id)
{
    this->id = id;
}

EObjectType Glider::getType() const
{
    return EObjectType::Glider;
}

Text Glider::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(standard);
    case 5:
        return to_string(weight);
    case 6:
        return to_string(maxweight);
    case 7:
        return to_string(rotatespeed);
    case 8:
        return to_string(armor);
    case 9:
        return to_string(price);
    case 10:
        return to_string(restore);
    case 11:
        return to_string(power);
    case 12:
        return to_string(special);
    default:
        return "";
    }
    return "";
}

void Glider::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        text_id = text.string();
        break;
    case 2:
        resource = text.string();
        break;
    case 3:
        name = std::static_pointer_cast<String>(ptr);
        break;
    case 4:
        standard = std::stoi(text.string());
        break;
    case 5:
        weight = std::stof(text.string());
        break;
    case 6:
        maxweight = std::stof(text.string());
        break;
    case 7:
        rotatespeed = std::stof(text.string());
        break;
    case 8:
        armor = std::stof(text.string());
        break;
    case 9:
        price = std::stoi(text.string());
        break;
    case 10:
        restore = std::stof(text.string());
        break;
    case 11:
        power = std::stof(text.string());
        break;
    case 12:
        special = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Glider::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Glider::getName() const
{
    Text n;
    n = to_string(name);
    if (!n.empty())
        return n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool Glider::operator==(const Glider &rhs) const
{
    return
        armor == rhs.armor &&
        maxweight == rhs.maxweight &&
        name == rhs.name &&
        power == rhs.power &&
        price == rhs.price &&
        resource == rhs.resource &&
        restore == rhs.restore &&
        rotatespeed == rhs.rotatespeed &&
        special == rhs.special &&
        standard == rhs.standard &&
        text_id == rhs.text_id &&
        weight == rhs.weight &&
        1;
}

int Glider::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) text_id = cols[1];
    if (cols[2]) resource = cols[2];
    if (cols[3]) name.id = std::stoi(cols[3]);
    if (cols[4]) standard = std::stoi(cols[4]);
    if (cols[5]) weight = std::stof(cols[5]);
    if (cols[6]) maxweight = std::stof(cols[6]);
    if (cols[7]) rotatespeed = std::stof(cols[7]);
    if (cols[8]) armor = std::stof(cols[8]);
    if (cols[9]) price = std::stoi(cols[9]);
    if (cols[10]) restore = std::stof(cols[10]);
    if (cols[11]) power = std::stof(cols[11]);
    if (cols[12]) special = std::stoi(cols[12]);

    return 0;
}

const char *Glider::getSql()
{
    return
    " \
create table \"Gliders\" ( \
\"id\" INTEGER NOT NULL, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
\"standard\" INTEGER, \
\"weight\" REAL, \
\"maxweight\" REAL, \
\"rotatespeed\" REAL, \
\"armor\" REAL, \
\"price\" INTEGER, \
\"restore\" REAL, \
\"power\" REAL, \
\"special\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

int Good::getId() const
{
    return id;
}

void Good::setId(int id)
{
    this->id = id;
}

EObjectType Good::getType() const
{
    return EObjectType::Good;
}

Text Good::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(price);
    case 5:
        return to_string(notrade);
    case 6:
        return to_string(weight);
    default:
        return "";
    }
    return "";
}

void Good::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        text_id = text.string();
        break;
    case 2:
        resource = text.string();
        break;
    case 3:
        name = std::static_pointer_cast<String>(ptr);
        break;
    case 4:
        price = std::stoi(text.string());
        break;
    case 5:
        notrade = std::stoi(text.string());
        break;
    case 6:
        weight = std::stof(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Good::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Good::getName() const
{
    Text n;
    n = to_string(name);
    if (!n.empty())
        return n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool Good::operator==(const Good &rhs) const
{
    return
        name == rhs.name &&
        notrade == rhs.notrade &&
        price == rhs.price &&
        resource == rhs.resource &&
        text_id == rhs.text_id &&
        weight == rhs.weight &&
        1;
}

int Good::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) text_id = cols[1];
    if (cols[2]) resource = cols[2];
    if (cols[3]) name.id = std::stoi(cols[3]);
    if (cols[4]) price = std::stoi(cols[4]);
    if (cols[5]) notrade = std::stoi(cols[5]);
    if (cols[6]) weight = std::stof(cols[6]);

    return 0;
}

const char *Good::getSql()
{
    return
    " \
create table \"Goods\" ( \
\"id\" INTEGER NOT NULL, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
\"price\" INTEGER, \
\"notrade\" INTEGER, \
\"weight\" REAL, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

EObjectType GroupMechanoid::getType() const
{
    return EObjectType::GroupMechanoid;
}

Text GroupMechanoid::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(group);
    case 1:
        return to_string(mechanoid);
    default:
        return "";
    }
    return "";
}

void GroupMechanoid::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        group = std::static_pointer_cast<Group>(ptr);
        break;
    case 1:
        mechanoid = std::static_pointer_cast<Mechanoid>(ptr);
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *GroupMechanoid::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text GroupMechanoid::getName() const
{
    Text n;
    n = to_string(mechanoid);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool GroupMechanoid::operator==(const GroupMechanoid &rhs) const
{
    return
        group == rhs.group &&
        mechanoid == rhs.mechanoid &&
        1;
}

IdPtr<Group> GroupMechanoid::operator->() const
{
    if (group)
        return group;
    throw EXCEPTION("Value is missing");
}

int GroupMechanoid::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) group.id = std::stoi(cols[0]);
    if (cols[1]) mechanoid.id = std::stoi(cols[1]);

    return 0;
}

const char *GroupMechanoid::getSql()
{
    return
    " \
create table \"GroupMechanoids\" ( \
\"group_id\" INTEGER NOT NULL, \
\"mechanoid_id\" INTEGER NOT NULL, \
PRIMARY KEY (\"mechanoid_id\"), \
FOREIGN KEY (\"group_id\") REFERENCES \"Groups\" (\"id\"), \
FOREIGN KEY (\"mechanoid_id\") REFERENCES \"Mechanoids\" (\"id\") \
); \
    ";
}

int Group::getId() const
{
    return id;
}

void Group::setId(int id)
{
    this->id = id;
}

EObjectType Group::getType() const
{
    return EObjectType::Group;
}

Text Group::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(name);
    default:
        return "";
    }
    return "";
}

void Group::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        text_id = text.string();
        break;
    case 2:
        name = std::static_pointer_cast<String>(ptr);
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Group::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);

    QTreeWidgetItem *root;

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Mechanoids")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::GroupMechanoid));
    for (auto &mechanoid : mechanoids)
        mechanoid->printQtTreeView(root);

    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Group::getName() const
{
    Text n;
    n = to_string(name);
    if (!n.empty())
        return n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool Group::operator==(const Group &rhs) const
{
    return
        name == rhs.name &&
        text_id == rhs.text_id &&
        1;
}

int Group::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) text_id = cols[1];
    if (cols[2]) name.id = std::stoi(cols[2]);

    return 0;
}

const char *Group::getSql()
{
    return
    " \
create table \"Groups\" ( \
\"id\" INTEGER NOT NULL, \
\"text_id\" TEXT, \
\"name_id\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

EObjectType MapBuildingEquipment::getType() const
{
    return EObjectType::MapBuildingEquipment;
}

Text MapBuildingEquipment::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(mapBuilding);
    case 1:
        return to_string(equipment);
    case 2:
        return to_string(quantity);
    default:
        return "";
    }
    return "";
}

void MapBuildingEquipment::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        mapBuilding = std::static_pointer_cast<MapBuilding>(ptr);
        break;
    case 1:
        equipment = std::static_pointer_cast<Equipment>(ptr);
        break;
    case 2:
        quantity = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *MapBuildingEquipment::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text MapBuildingEquipment::getName() const
{
    Text n;
    n = to_string(equipment);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool MapBuildingEquipment::operator==(const MapBuildingEquipment &rhs) const
{
    return
        equipment == rhs.equipment &&
        mapBuilding == rhs.mapBuilding &&
        quantity == rhs.quantity &&
        1;
}

IdPtr<MapBuilding> MapBuildingEquipment::operator->() const
{
    if (mapBuilding)
        return mapBuilding;
    throw EXCEPTION("Value is missing");
}

int MapBuildingEquipment::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) mapBuilding.id = std::stoi(cols[0]);
    if (cols[1]) equipment.id = std::stoi(cols[1]);
    if (cols[2]) quantity = std::stoi(cols[2]);

    return 0;
}

const char *MapBuildingEquipment::getSql()
{
    return
    " \
create table \"MapBuildingEquipments\" ( \
\"mapBuilding_id\" INTEGER NOT NULL, \
\"equipment_id\" INTEGER NOT NULL, \
\"quantity\" INTEGER, \
PRIMARY KEY (\"mapBuilding_id\", \"equipment_id\"), \
FOREIGN KEY (\"mapBuilding_id\") REFERENCES \"MapBuildings\" (\"id\"), \
FOREIGN KEY (\"equipment_id\") REFERENCES \"Equipments\" (\"id\") \
); \
    ";
}

EObjectType MapBuildingGlider::getType() const
{
    return EObjectType::MapBuildingGlider;
}

Text MapBuildingGlider::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(mapBuilding);
    case 1:
        return to_string(glider);
    case 2:
        return to_string(quantity);
    default:
        return "";
    }
    return "";
}

void MapBuildingGlider::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        mapBuilding = std::static_pointer_cast<MapBuilding>(ptr);
        break;
    case 1:
        glider = std::static_pointer_cast<Glider>(ptr);
        break;
    case 2:
        quantity = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *MapBuildingGlider::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text MapBuildingGlider::getName() const
{
    Text n;
    n = to_string(glider);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool MapBuildingGlider::operator==(const MapBuildingGlider &rhs) const
{
    return
        glider == rhs.glider &&
        mapBuilding == rhs.mapBuilding &&
        quantity == rhs.quantity &&
        1;
}

IdPtr<MapBuilding> MapBuildingGlider::operator->() const
{
    if (mapBuilding)
        return mapBuilding;
    throw EXCEPTION("Value is missing");
}

int MapBuildingGlider::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) mapBuilding.id = std::stoi(cols[0]);
    if (cols[1]) glider.id = std::stoi(cols[1]);
    if (cols[2]) quantity = std::stoi(cols[2]);

    return 0;
}

const char *MapBuildingGlider::getSql()
{
    return
    " \
create table \"MapBuildingGliders\" ( \
\"mapBuilding_id\" INTEGER NOT NULL, \
\"glider_id\" INTEGER NOT NULL, \
\"quantity\" INTEGER, \
PRIMARY KEY (\"mapBuilding_id\", \"glider_id\"), \
FOREIGN KEY (\"mapBuilding_id\") REFERENCES \"MapBuildings\" (\"id\"), \
FOREIGN KEY (\"glider_id\") REFERENCES \"Gliders\" (\"id\") \
); \
    ";
}

EObjectType MapBuildingGood::getType() const
{
    return EObjectType::MapBuildingGood;
}

Text MapBuildingGood::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(mapBuilding);
    case 1:
        return to_string(good);
    case 2:
        return to_string(quantity);
    default:
        return "";
    }
    return "";
}

void MapBuildingGood::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        mapBuilding = std::static_pointer_cast<MapBuilding>(ptr);
        break;
    case 1:
        good = std::static_pointer_cast<Good>(ptr);
        break;
    case 2:
        quantity = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *MapBuildingGood::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text MapBuildingGood::getName() const
{
    Text n;
    n = to_string(good);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool MapBuildingGood::operator==(const MapBuildingGood &rhs) const
{
    return
        good == rhs.good &&
        mapBuilding == rhs.mapBuilding &&
        quantity == rhs.quantity &&
        1;
}

IdPtr<MapBuilding> MapBuildingGood::operator->() const
{
    if (mapBuilding)
        return mapBuilding;
    throw EXCEPTION("Value is missing");
}

int MapBuildingGood::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) mapBuilding.id = std::stoi(cols[0]);
    if (cols[1]) good.id = std::stoi(cols[1]);
    if (cols[2]) quantity = std::stoi(cols[2]);

    return 0;
}

const char *MapBuildingGood::getSql()
{
    return
    " \
create table \"MapBuildingGoods\" ( \
\"mapBuilding_id\" INTEGER NOT NULL, \
\"good_id\" INTEGER NOT NULL, \
\"quantity\" INTEGER, \
PRIMARY KEY (\"mapBuilding_id\", \"good_id\"), \
FOREIGN KEY (\"mapBuilding_id\") REFERENCES \"MapBuildings\" (\"id\"), \
FOREIGN KEY (\"good_id\") REFERENCES \"Goods\" (\"id\") \
); \
    ";
}

EObjectType MapBuildingModificator::getType() const
{
    return EObjectType::MapBuildingModificator;
}

Text MapBuildingModificator::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(mapBuilding);
    case 1:
        return to_string(modificator);
    case 2:
        return to_string(quantity);
    default:
        return "";
    }
    return "";
}

void MapBuildingModificator::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        mapBuilding = std::static_pointer_cast<MapBuilding>(ptr);
        break;
    case 1:
        modificator = std::static_pointer_cast<Modificator>(ptr);
        break;
    case 2:
        quantity = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *MapBuildingModificator::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text MapBuildingModificator::getName() const
{
    Text n;
    n = to_string(modificator);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool MapBuildingModificator::operator==(const MapBuildingModificator &rhs) const
{
    return
        mapBuilding == rhs.mapBuilding &&
        modificator == rhs.modificator &&
        quantity == rhs.quantity &&
        1;
}

IdPtr<MapBuilding> MapBuildingModificator::operator->() const
{
    if (mapBuilding)
        return mapBuilding;
    throw EXCEPTION("Value is missing");
}

int MapBuildingModificator::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) mapBuilding.id = std::stoi(cols[0]);
    if (cols[1]) modificator.id = std::stoi(cols[1]);
    if (cols[2]) quantity = std::stoi(cols[2]);

    return 0;
}

const char *MapBuildingModificator::getSql()
{
    return
    " \
create table \"MapBuildingModificators\" ( \
\"mapBuilding_id\" INTEGER NOT NULL, \
\"modificator_id\" INTEGER NOT NULL, \
\"quantity\" INTEGER, \
PRIMARY KEY (\"mapBuilding_id\", \"modificator_id\"), \
FOREIGN KEY (\"mapBuilding_id\") REFERENCES \"MapBuildings\" (\"id\"), \
FOREIGN KEY (\"modificator_id\") REFERENCES \"Modificators\" (\"id\") \
); \
    ";
}

EObjectType MapBuildingProjectile::getType() const
{
    return EObjectType::MapBuildingProjectile;
}

Text MapBuildingProjectile::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(mapBuilding);
    case 1:
        return to_string(projectile);
    case 2:
        return to_string(quantity);
    default:
        return "";
    }
    return "";
}

void MapBuildingProjectile::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        mapBuilding = std::static_pointer_cast<MapBuilding>(ptr);
        break;
    case 1:
        projectile = std::static_pointer_cast<Projectile>(ptr);
        break;
    case 2:
        quantity = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *MapBuildingProjectile::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text MapBuildingProjectile::getName() const
{
    Text n;
    n = to_string(projectile);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool MapBuildingProjectile::operator==(const MapBuildingProjectile &rhs) const
{
    return
        mapBuilding == rhs.mapBuilding &&
        projectile == rhs.projectile &&
        quantity == rhs.quantity &&
        1;
}

IdPtr<MapBuilding> MapBuildingProjectile::operator->() const
{
    if (mapBuilding)
        return mapBuilding;
    throw EXCEPTION("Value is missing");
}

int MapBuildingProjectile::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) mapBuilding.id = std::stoi(cols[0]);
    if (cols[1]) projectile.id = std::stoi(cols[1]);
    if (cols[2]) quantity = std::stoi(cols[2]);

    return 0;
}

const char *MapBuildingProjectile::getSql()
{
    return
    " \
create table \"MapBuildingProjectiles\" ( \
\"mapBuilding_id\" INTEGER NOT NULL, \
\"projectile_id\" INTEGER NOT NULL, \
\"quantity\" INTEGER, \
PRIMARY KEY (\"mapBuilding_id\", \"projectile_id\"), \
FOREIGN KEY (\"mapBuilding_id\") REFERENCES \"MapBuildings\" (\"id\"), \
FOREIGN KEY (\"projectile_id\") REFERENCES \"Projectiles\" (\"id\") \
); \
    ";
}

EObjectType MapBuildingWeapon::getType() const
{
    return EObjectType::MapBuildingWeapon;
}

Text MapBuildingWeapon::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(mapBuilding);
    case 1:
        return to_string(weapon);
    case 2:
        return to_string(quantity);
    default:
        return "";
    }
    return "";
}

void MapBuildingWeapon::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        mapBuilding = std::static_pointer_cast<MapBuilding>(ptr);
        break;
    case 1:
        weapon = std::static_pointer_cast<Weapon>(ptr);
        break;
    case 2:
        quantity = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *MapBuildingWeapon::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text MapBuildingWeapon::getName() const
{
    Text n;
    n = to_string(weapon);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool MapBuildingWeapon::operator==(const MapBuildingWeapon &rhs) const
{
    return
        mapBuilding == rhs.mapBuilding &&
        quantity == rhs.quantity &&
        weapon == rhs.weapon &&
        1;
}

IdPtr<MapBuilding> MapBuildingWeapon::operator->() const
{
    if (mapBuilding)
        return mapBuilding;
    throw EXCEPTION("Value is missing");
}

int MapBuildingWeapon::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) mapBuilding.id = std::stoi(cols[0]);
    if (cols[1]) weapon.id = std::stoi(cols[1]);
    if (cols[2]) quantity = std::stoi(cols[2]);

    return 0;
}

const char *MapBuildingWeapon::getSql()
{
    return
    " \
create table \"MapBuildingWeapons\" ( \
\"mapBuilding_id\" INTEGER NOT NULL, \
\"weapon_id\" INTEGER NOT NULL, \
\"quantity\" INTEGER, \
PRIMARY KEY (\"mapBuilding_id\", \"weapon_id\"), \
FOREIGN KEY (\"mapBuilding_id\") REFERENCES \"MapBuildings\" (\"id\"), \
FOREIGN KEY (\"weapon_id\") REFERENCES \"Weapons\" (\"id\") \
); \
    ";
}

int MapBuilding::getId() const
{
    return id;
}

void MapBuilding::setId(int id)
{
    this->id = id;
}

EObjectType MapBuilding::getType() const
{
    return EObjectType::MapBuilding;
}

Text MapBuilding::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(map);
    case 3:
        return to_string(building);
    case 4:
        return to_string(x);
    case 5:
        return to_string(y);
    case 6:
        return to_string(z);
    case 7:
        return to_string(pitch);
    case 8:
        return to_string(yaw);
    case 9:
        return to_string(roll);
    case 10:
        return to_string(scale);
    case 11:
        return to_string(scale_x);
    case 12:
        return to_string(scale_y);
    case 13:
        return to_string(scale_z);
    default:
        return "";
    }
    return "";
}

void MapBuilding::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        text_id = text.string();
        break;
    case 2:
        map = std::static_pointer_cast<Map>(ptr);
        break;
    case 3:
        building = std::static_pointer_cast<Building>(ptr);
        break;
    case 4:
        x = std::stof(text.string());
        break;
    case 5:
        y = std::stof(text.string());
        break;
    case 6:
        z = std::stof(text.string());
        break;
    case 7:
        pitch = std::stof(text.string());
        break;
    case 8:
        yaw = std::stof(text.string());
        break;
    case 9:
        roll = std::stof(text.string());
        break;
    case 10:
        scale = std::stof(text.string());
        break;
    case 11:
        scale_x = std::stof(text.string());
        break;
    case 12:
        scale_y = std::stof(text.string());
        break;
    case 13:
        scale_z = std::stof(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *MapBuilding::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);

    QTreeWidgetItem *root;

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Equipments")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::MapBuildingEquipment));
    for (auto &equipment : equipments)
        equipment->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Gliders")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::MapBuildingGlider));
    for (auto &glider : gliders)
        glider->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Goods")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::MapBuildingGood));
    for (auto &good : goods)
        good->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Modificators")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::MapBuildingModificator));
    for (auto &modificator : modificators)
        modificator->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Projectiles")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::MapBuildingProjectile));
    for (auto &projectile : projectiles)
        projectile->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Weapons")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::MapBuildingWeapon));
    for (auto &weapon : weapons)
        weapon->printQtTreeView(root);

    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text MapBuilding::getName() const
{
    Text n;
    n = to_string(building);
    if (!n.empty())
        return n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool MapBuilding::operator==(const MapBuilding &rhs) const
{
    return
        building == rhs.building &&
        map == rhs.map &&
        pitch == rhs.pitch &&
        roll == rhs.roll &&
        scale == rhs.scale &&
        scale_x == rhs.scale_x &&
        scale_y == rhs.scale_y &&
        scale_z == rhs.scale_z &&
        text_id == rhs.text_id &&
        x == rhs.x &&
        y == rhs.y &&
        yaw == rhs.yaw &&
        z == rhs.z &&
        1;
}

int MapBuilding::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) text_id = cols[1];
    if (cols[2]) map.id = std::stoi(cols[2]);
    if (cols[3]) building.id = std::stoi(cols[3]);
    if (cols[4]) x = std::stof(cols[4]);
    if (cols[5]) y = std::stof(cols[5]);
    if (cols[6]) z = std::stof(cols[6]);
    if (cols[7]) pitch = std::stof(cols[7]);
    if (cols[8]) yaw = std::stof(cols[8]);
    if (cols[9]) roll = std::stof(cols[9]);
    if (cols[10]) scale = std::stof(cols[10]);
    if (cols[11]) scale_x = std::stof(cols[11]);
    if (cols[12]) scale_y = std::stof(cols[12]);
    if (cols[13]) scale_z = std::stof(cols[13]);

    return 0;
}

const char *MapBuilding::getSql()
{
    return
    " \
create table \"MapBuildings\" ( \
\"id\" INTEGER NOT NULL, \
\"text_id\" TEXT, \
\"map_id\" INTEGER NOT NULL, \
\"building_id\" INTEGER NOT NULL, \
\"x\" REAL, \
\"y\" REAL, \
\"z\" REAL, \
\"pitch\" REAL, \
\"yaw\" REAL, \
\"roll\" REAL, \
\"scale\" REAL DEFAULT 1, \
\"scale_x\" REAL DEFAULT 1, \
\"scale_y\" REAL DEFAULT 1, \
\"scale_z\" REAL DEFAULT 1, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"map_id\") REFERENCES \"Maps\" (\"id\"), \
FOREIGN KEY (\"building_id\") REFERENCES \"Buildings\" (\"id\") \
); \
    ";
}

int MapObject::getId() const
{
    return id;
}

void MapObject::setId(int id)
{
    this->id = id;
}

EObjectType MapObject::getType() const
{
    return EObjectType::MapObject;
}

Text MapObject::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(map);
    case 3:
        return to_string(object);
    case 4:
        return to_string(x);
    case 5:
        return to_string(y);
    case 6:
        return to_string(z);
    case 7:
        return to_string(pitch);
    case 8:
        return to_string(yaw);
    case 9:
        return to_string(roll);
    case 10:
        return to_string(scale);
    case 11:
        return to_string(scale_x);
    case 12:
        return to_string(scale_y);
    case 13:
        return to_string(scale_z);
    default:
        return "";
    }
    return "";
}

void MapObject::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        text_id = text.string();
        break;
    case 2:
        map = std::static_pointer_cast<Map>(ptr);
        break;
    case 3:
        object = std::static_pointer_cast<Object>(ptr);
        break;
    case 4:
        x = std::stof(text.string());
        break;
    case 5:
        y = std::stof(text.string());
        break;
    case 6:
        z = std::stof(text.string());
        break;
    case 7:
        pitch = std::stof(text.string());
        break;
    case 8:
        yaw = std::stof(text.string());
        break;
    case 9:
        roll = std::stof(text.string());
        break;
    case 10:
        scale = std::stof(text.string());
        break;
    case 11:
        scale_x = std::stof(text.string());
        break;
    case 12:
        scale_y = std::stof(text.string());
        break;
    case 13:
        scale_z = std::stof(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *MapObject::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text MapObject::getName() const
{
    Text n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool MapObject::operator==(const MapObject &rhs) const
{
    return
        map == rhs.map &&
        object == rhs.object &&
        pitch == rhs.pitch &&
        roll == rhs.roll &&
        scale == rhs.scale &&
        scale_x == rhs.scale_x &&
        scale_y == rhs.scale_y &&
        scale_z == rhs.scale_z &&
        text_id == rhs.text_id &&
        x == rhs.x &&
        y == rhs.y &&
        yaw == rhs.yaw &&
        z == rhs.z &&
        1;
}

int MapObject::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) text_id = cols[1];
    if (cols[2]) map.id = std::stoi(cols[2]);
    if (cols[3]) object.id = std::stoi(cols[3]);
    if (cols[4]) x = std::stof(cols[4]);
    if (cols[5]) y = std::stof(cols[5]);
    if (cols[6]) z = std::stof(cols[6]);
    if (cols[7]) pitch = std::stof(cols[7]);
    if (cols[8]) yaw = std::stof(cols[8]);
    if (cols[9]) roll = std::stof(cols[9]);
    if (cols[10]) scale = std::stof(cols[10]);
    if (cols[11]) scale_x = std::stof(cols[11]);
    if (cols[12]) scale_y = std::stof(cols[12]);
    if (cols[13]) scale_z = std::stof(cols[13]);

    return 0;
}

const char *MapObject::getSql()
{
    return
    " \
create table \"MapObjects\" ( \
\"id\" INTEGER NOT NULL, \
\"text_id\" TEXT, \
\"map_id\" INTEGER NOT NULL, \
\"object_id\" INTEGER NOT NULL, \
\"x\" REAL, \
\"y\" REAL, \
\"z\" REAL, \
\"pitch\" REAL, \
\"yaw\" REAL, \
\"roll\" REAL, \
\"scale\" REAL DEFAULT 1, \
\"scale_x\" REAL DEFAULT 1, \
\"scale_y\" REAL DEFAULT 1, \
\"scale_z\" REAL DEFAULT 1, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"map_id\") REFERENCES \"Maps\" (\"id\"), \
FOREIGN KEY (\"object_id\") REFERENCES \"Objects\" (\"id\") \
); \
    ";
}

int Map::getId() const
{
    return id;
}

void Map::setId(int id)
{
    this->id = id;
}

EObjectType Map::getType() const
{
    return EObjectType::Map;
}

Text Map::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(h_min);
    case 5:
        return to_string(h_max);
    default:
        return "";
    }
    return "";
}

void Map::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        text_id = text.string();
        break;
    case 2:
        resource = text.string();
        break;
    case 3:
        name = std::static_pointer_cast<String>(ptr);
        break;
    case 4:
        h_min = std::stof(text.string());
        break;
    case 5:
        h_max = std::stof(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Map::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);

    QTreeWidgetItem *root;

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Buildings")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::MapBuilding));
    for (auto &building : buildings)
        building->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Objects")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::MapObject));
    for (auto &object : objects)
        object->printQtTreeView(root);

    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Map::getName() const
{
    Text n;
    n = text_id;
    if (!n.empty())
        return n;
    n = to_string(name);
    if (!n.empty())
        return n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool Map::operator==(const Map &rhs) const
{
    return
        h_max == rhs.h_max &&
        h_min == rhs.h_min &&
        name == rhs.name &&
        resource == rhs.resource &&
        text_id == rhs.text_id &&
        1;
}

int Map::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) text_id = cols[1];
    if (cols[2]) resource = cols[2];
    if (cols[3]) name.id = std::stoi(cols[3]);
    if (cols[4]) h_min = std::stof(cols[4]);
    if (cols[5]) h_max = std::stof(cols[5]);

    return 0;
}

const char *Map::getSql()
{
    return
    " \
create table \"Maps\" ( \
\"id\" INTEGER NOT NULL, \
\"text_id\" TEXT NOT NULL, \
\"resource\" TEXT NOT NULL, \
\"name_id\" INTEGER, \
\"h_min\" REAL, \
\"h_max\" REAL, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

EObjectType MechanoidQuest::getType() const
{
    return EObjectType::MechanoidQuest;
}

Text MechanoidQuest::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(mechanoid);
    case 1:
        return to_string(quest);
    case 2:
        return to_string(state);
    default:
        return "";
    }
    return "";
}

void MechanoidQuest::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        mechanoid = std::static_pointer_cast<Mechanoid>(ptr);
        break;
    case 1:
        quest = std::static_pointer_cast<Quest>(ptr);
        break;
    case 2:
        state = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *MechanoidQuest::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text MechanoidQuest::getName() const
{
    Text n;
    n = to_string(quest);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool MechanoidQuest::operator==(const MechanoidQuest &rhs) const
{
    return
        mechanoid == rhs.mechanoid &&
        quest == rhs.quest &&
        state == rhs.state &&
        1;
}

IdPtr<Mechanoid> MechanoidQuest::operator->() const
{
    if (mechanoid)
        return mechanoid;
    throw EXCEPTION("Value is missing");
}

int MechanoidQuest::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) mechanoid.id = std::stoi(cols[0]);
    if (cols[1]) quest.id = std::stoi(cols[1]);
    if (cols[2]) state = std::stoi(cols[2]);

    return 0;
}

const char *MechanoidQuest::getSql()
{
    return
    " \
create table \"MechanoidQuests\" ( \
\"mechanoid_id\" INTEGER NOT NULL, \
\"quest_id\" INTEGER NOT NULL, \
\"state\" INTEGER, \
PRIMARY KEY (\"mechanoid_id\", \"quest_id\"), \
FOREIGN KEY (\"mechanoid_id\") REFERENCES \"Mechanoids\" (\"id\"), \
FOREIGN KEY (\"quest_id\") REFERENCES \"Quests\" (\"id\") \
); \
    ";
}

int Mechanoid::getId() const
{
    return id;
}

void Mechanoid::setId(int id)
{
    this->id = id;
}

EObjectType Mechanoid::getType() const
{
    return EObjectType::Mechanoid;
}

Text Mechanoid::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(name);
    case 3:
        return to_string(generation);
    case 4:
        return to_string(rating);
    case 5:
        return to_string(money);
    case 6:
        return to_string(configuration);
    case 7:
        return to_string(group);
    case 8:
        return to_string(clan);
    case 9:
        return to_string(rating_fight);
    case 10:
        return to_string(rating_courier);
    case 11:
        return to_string(rating_trade);
    case 12:
        return to_string(map);
    case 13:
        return to_string(mapBuilding);
    case 14:
        return to_string(x);
    case 15:
        return to_string(y);
    case 16:
        return to_string(z);
    case 17:
        return to_string(pitch);
    case 18:
        return to_string(yaw);
    case 19:
        return to_string(roll);
    default:
        return "";
    }
    return "";
}

void Mechanoid::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        text_id = text.string();
        break;
    case 2:
        name = std::static_pointer_cast<String>(ptr);
        break;
    case 3:
        generation = std::stoi(text.string());
        break;
    case 4:
        rating = std::stof(text.string());
        break;
    case 5:
        money = std::stof(text.string());
        break;
    case 6:
        configuration = std::static_pointer_cast<Configuration>(ptr);
        break;
    case 7:
        group = std::static_pointer_cast<Group>(ptr);
        break;
    case 8:
        clan = std::static_pointer_cast<Clan>(ptr);
        break;
    case 9:
        rating_fight = std::stof(text.string());
        break;
    case 10:
        rating_courier = std::stof(text.string());
        break;
    case 11:
        rating_trade = std::stof(text.string());
        break;
    case 12:
        map = std::static_pointer_cast<Map>(ptr);
        break;
    case 13:
        mapBuilding = std::static_pointer_cast<MapBuilding>(ptr);
        break;
    case 14:
        x = std::stof(text.string());
        break;
    case 15:
        y = std::stof(text.string());
        break;
    case 16:
        z = std::stof(text.string());
        break;
    case 17:
        pitch = std::stof(text.string());
        break;
    case 18:
        yaw = std::stof(text.string());
        break;
    case 19:
        roll = std::stof(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Mechanoid::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);

    QTreeWidgetItem *root;

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Quests")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::MechanoidQuest));
    for (auto &quest : quests)
        quest->printQtTreeView(root);

    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Mechanoid::getName() const
{
    Text n;
    n = to_string(name);
    if (!n.empty())
        return n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool Mechanoid::operator==(const Mechanoid &rhs) const
{
    return
        clan == rhs.clan &&
        configuration == rhs.configuration &&
        generation == rhs.generation &&
        group == rhs.group &&
        mapBuilding == rhs.mapBuilding &&
        map == rhs.map &&
        money == rhs.money &&
        name == rhs.name &&
        pitch == rhs.pitch &&
        rating == rhs.rating &&
        rating_courier == rhs.rating_courier &&
        rating_fight == rhs.rating_fight &&
        rating_trade == rhs.rating_trade &&
        roll == rhs.roll &&
        text_id == rhs.text_id &&
        x == rhs.x &&
        y == rhs.y &&
        yaw == rhs.yaw &&
        z == rhs.z &&
        1;
}

int Mechanoid::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) text_id = cols[1];
    if (cols[2]) name.id = std::stoi(cols[2]);
    if (cols[3]) generation = std::stoi(cols[3]);
    if (cols[4]) rating = std::stof(cols[4]);
    if (cols[5]) money = std::stof(cols[5]);
    if (cols[6]) configuration.id = std::stoi(cols[6]);
    if (cols[7]) group.id = std::stoi(cols[7]);
    if (cols[8]) clan.id = std::stoi(cols[8]);
    if (cols[9]) rating_fight = std::stof(cols[9]);
    if (cols[10]) rating_courier = std::stof(cols[10]);
    if (cols[11]) rating_trade = std::stof(cols[11]);
    if (cols[12]) map.id = std::stoi(cols[12]);
    if (cols[13]) mapBuilding.id = std::stoi(cols[13]);
    if (cols[14]) x = std::stof(cols[14]);
    if (cols[15]) y = std::stof(cols[15]);
    if (cols[16]) z = std::stof(cols[16]);
    if (cols[17]) pitch = std::stof(cols[17]);
    if (cols[18]) yaw = std::stof(cols[18]);
    if (cols[19]) roll = std::stof(cols[19]);

    return 0;
}

const char *Mechanoid::getSql()
{
    return
    " \
create table \"Mechanoids\" ( \
\"id\" INTEGER NOT NULL, \
\"text_id\" TEXT, \
\"name_id\" INTEGER, \
\"generation\" INTEGER, \
\"rating\" REAL, \
\"money\" REAL, \
\"configuration_id\" INTEGER, \
\"group_id\" INTEGER, \
\"clan_id\" INTEGER, \
\"rating_fight\" REAL, \
\"rating_courier\" REAL, \
\"rating_trade\" REAL, \
\"map_id\" INTEGER, \
\"mapBuilding_id\" INTEGER, \
\"x\" REAL, \
\"y\" REAL, \
\"z\" REAL, \
\"pitch\" REAL, \
\"yaw\" REAL, \
\"roll\" REAL, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"configuration_id\") REFERENCES \"Configurations\" (\"id\"), \
FOREIGN KEY (\"clan_id\") REFERENCES \"Clans\" (\"id\"), \
FOREIGN KEY (\"map_id\") REFERENCES \"Maps\" (\"id\"), \
FOREIGN KEY (\"mapBuilding_id\") REFERENCES \"MapBuildings\" (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\"), \
FOREIGN KEY (\"group_id\") REFERENCES \"Groups\" (\"id\") \
); \
    ";
}

EObjectType ModificationClan::getType() const
{
    return EObjectType::ModificationClan;
}

Text ModificationClan::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(modification);
    case 1:
        return to_string(clan);
    default:
        return "";
    }
    return "";
}

void ModificationClan::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        modification = std::static_pointer_cast<Modification>(ptr);
        break;
    case 1:
        clan = std::static_pointer_cast<Clan>(ptr);
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *ModificationClan::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text ModificationClan::getName() const
{
    Text n;
    n = to_string(clan);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool ModificationClan::operator==(const ModificationClan &rhs) const
{
    return
        clan == rhs.clan &&
        modification == rhs.modification &&
        1;
}

IdPtr<Modification> ModificationClan::operator->() const
{
    if (modification)
        return modification;
    throw EXCEPTION("Value is missing");
}

int ModificationClan::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) modification.id = std::stoi(cols[0]);
    if (cols[1]) clan.id = std::stoi(cols[1]);

    return 0;
}

const char *ModificationClan::getSql()
{
    return
    " \
create table \"ModificationClans\" ( \
\"modification_id\" INTEGER NOT NULL, \
\"clan_id\" INTEGER NOT NULL, \
PRIMARY KEY (\"modification_id\", \"clan_id\"), \
FOREIGN KEY (\"modification_id\") REFERENCES \"Modifications\" (\"id\"), \
FOREIGN KEY (\"clan_id\") REFERENCES \"Clans\" (\"id\") \
); \
    ";
}

EObjectType ModificationMap::getType() const
{
    return EObjectType::ModificationMap;
}

Text ModificationMap::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(modification);
    case 1:
        return to_string(map);
    default:
        return "";
    }
    return "";
}

void ModificationMap::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        modification = std::static_pointer_cast<Modification>(ptr);
        break;
    case 1:
        map = std::static_pointer_cast<Map>(ptr);
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *ModificationMap::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text ModificationMap::getName() const
{
    Text n;
    n = to_string(map);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool ModificationMap::operator==(const ModificationMap &rhs) const
{
    return
        map == rhs.map &&
        modification == rhs.modification &&
        1;
}

IdPtr<Modification> ModificationMap::operator->() const
{
    if (modification)
        return modification;
    throw EXCEPTION("Value is missing");
}

int ModificationMap::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) modification.id = std::stoi(cols[0]);
    if (cols[1]) map.id = std::stoi(cols[1]);

    return 0;
}

const char *ModificationMap::getSql()
{
    return
    " \
create table \"ModificationMaps\" ( \
\"modification_id\" INTEGER NOT NULL, \
\"map_id\" INTEGER NOT NULL, \
PRIMARY KEY (\"modification_id\", \"map_id\"), \
FOREIGN KEY (\"modification_id\") REFERENCES \"Modifications\" (\"id\"), \
FOREIGN KEY (\"map_id\") REFERENCES \"Maps\" (\"id\") \
); \
    ";
}

EObjectType ModificationMechanoid::getType() const
{
    return EObjectType::ModificationMechanoid;
}

Text ModificationMechanoid::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(modification);
    case 1:
        return to_string(mechanoid);
    default:
        return "";
    }
    return "";
}

void ModificationMechanoid::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        modification = std::static_pointer_cast<Modification>(ptr);
        break;
    case 1:
        mechanoid = std::static_pointer_cast<Mechanoid>(ptr);
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *ModificationMechanoid::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text ModificationMechanoid::getName() const
{
    Text n;
    n = to_string(mechanoid);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool ModificationMechanoid::operator==(const ModificationMechanoid &rhs) const
{
    return
        mechanoid == rhs.mechanoid &&
        modification == rhs.modification &&
        1;
}

IdPtr<Modification> ModificationMechanoid::operator->() const
{
    if (modification)
        return modification;
    throw EXCEPTION("Value is missing");
}

int ModificationMechanoid::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) modification.id = std::stoi(cols[0]);
    if (cols[1]) mechanoid.id = std::stoi(cols[1]);

    return 0;
}

const char *ModificationMechanoid::getSql()
{
    return
    " \
create table \"ModificationMechanoids\" ( \
\"modification_id\" INTEGER NOT NULL, \
\"mechanoid_id\" INTEGER NOT NULL, \
PRIMARY KEY (\"modification_id\", \"mechanoid_id\"), \
FOREIGN KEY (\"modification_id\") REFERENCES \"Modifications\" (\"id\"), \
FOREIGN KEY (\"mechanoid_id\") REFERENCES \"Mechanoids\" (\"id\") \
); \
    ";
}

int Modification::getId() const
{
    return id;
}

void Modification::setId(int id)
{
    this->id = id;
}

EObjectType Modification::getType() const
{
    return EObjectType::Modification;
}

Text Modification::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(name);
    case 2:
        return to_string(directory);
    case 3:
        return to_string(author);
    case 4:
        return to_string(date_created);
    case 5:
        return to_string(date_modified);
    case 6:
        return to_string(comment);
    case 7:
        return to_string(version);
    case 8:
        return to_string(script_language);
    case 9:
        return to_string(script_main);
    case 10:
        return to_string(player_mechanoid);
    case 11:
        return to_string(cooperative_player_configuration);
    default:
        return "";
    }
    return "";
}

void Modification::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        name = std::static_pointer_cast<String>(ptr);
        break;
    case 2:
        directory = text.string();
        break;
    case 3:
        author = text.string();
        break;
    case 4:
        date_created = text.string();
        break;
    case 5:
        date_modified = text.string();
        break;
    case 6:
        comment = text.string();
        break;
    case 7:
        version = text.string();
        break;
    case 8:
        script_language = text.string();
        break;
    case 9:
        script_main = text.string();
        break;
    case 10:
        player_mechanoid = std::static_pointer_cast<Mechanoid>(ptr);
        break;
    case 11:
        cooperative_player_configuration = std::static_pointer_cast<Configuration>(ptr);
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Modification::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);

    QTreeWidgetItem *root;

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Clans")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::ModificationClan));
    for (auto &clan : clans)
        clan->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Maps")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::ModificationMap));
    for (auto &map : maps)
        map->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Mechanoids")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::ModificationMechanoid));
    for (auto &mechanoid : mechanoids)
        mechanoid->printQtTreeView(root);

    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Modification::getName() const
{
    Text n;
    n = to_string(name);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool Modification::operator==(const Modification &rhs) const
{
    return
        author == rhs.author &&
        comment == rhs.comment &&
        cooperative_player_configuration == rhs.cooperative_player_configuration &&
        date_created == rhs.date_created &&
        date_modified == rhs.date_modified &&
        directory == rhs.directory &&
        name == rhs.name &&
        player_mechanoid == rhs.player_mechanoid &&
        script_language == rhs.script_language &&
        script_main == rhs.script_main &&
        version == rhs.version &&
        1;
}

int Modification::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) name.id = std::stoi(cols[1]);
    if (cols[2]) directory = cols[2];
    if (cols[3]) author = cols[3];
    if (cols[4]) date_created = cols[4];
    if (cols[5]) date_modified = cols[5];
    if (cols[6]) comment = cols[6];
    if (cols[7]) version = cols[7];
    if (cols[8]) script_language = cols[8];
    if (cols[9]) script_main = cols[9];
    if (cols[10]) player_mechanoid.id = std::stoi(cols[10]);
    if (cols[11]) cooperative_player_configuration.id = std::stoi(cols[11]);

    return 0;
}

const char *Modification::getSql()
{
    return
    " \
create table \"Modifications\" ( \
\"id\" INTEGER NOT NULL, \
\"name_id\" INTEGER, \
\"directory\" TEXT NOT NULL, \
\"author\" TEXT, \
\"date_created\" TEXT, \
\"date_modified\" TEXT, \
\"comment\" TEXT, \
\"version\" TEXT, \
\"script_language\" TEXT, \
\"script_main\" TEXT, \
\"player_mechanoid_id\" INTEGER, \
\"cooperative_player_configuration_id\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\"), \
FOREIGN KEY (\"player_mechanoid_id\") REFERENCES \"Mechanoids\" (\"id\"), \
FOREIGN KEY (\"cooperative_player_configuration_id\") REFERENCES \"Configurations\" (\"id\") \
); \
    ";
}

int Modificator::getId() const
{
    return id;
}

void Modificator::setId(int id)
{
    this->id = id;
}

EObjectType Modificator::getType() const
{
    return EObjectType::Modificator;
}

Text Modificator::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(probability);
    case 5:
        return to_string(price);
    case 6:
        return to_string(k_price);
    case 7:
        return to_string(k_param1);
    case 8:
        return to_string(k_param2);
    default:
        return "";
    }
    return "";
}

void Modificator::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        text_id = text.string();
        break;
    case 2:
        resource = text.string();
        break;
    case 3:
        name = std::static_pointer_cast<String>(ptr);
        break;
    case 4:
        probability = std::stof(text.string());
        break;
    case 5:
        price = std::stof(text.string());
        break;
    case 6:
        k_price = std::stof(text.string());
        break;
    case 7:
        k_param1 = std::stof(text.string());
        break;
    case 8:
        k_param2 = std::stof(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Modificator::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Modificator::getName() const
{
    Text n;
    n = to_string(name);
    if (!n.empty())
        return n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool Modificator::operator==(const Modificator &rhs) const
{
    return
        k_param1 == rhs.k_param1 &&
        k_param2 == rhs.k_param2 &&
        k_price == rhs.k_price &&
        name == rhs.name &&
        price == rhs.price &&
        probability == rhs.probability &&
        resource == rhs.resource &&
        text_id == rhs.text_id &&
        1;
}

int Modificator::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) text_id = cols[1];
    if (cols[2]) resource = cols[2];
    if (cols[3]) name.id = std::stoi(cols[3]);
    if (cols[4]) probability = std::stof(cols[4]);
    if (cols[5]) price = std::stof(cols[5]);
    if (cols[6]) k_price = std::stof(cols[6]);
    if (cols[7]) k_param1 = std::stof(cols[7]);
    if (cols[8]) k_param2 = std::stof(cols[8]);

    return 0;
}

const char *Modificator::getSql()
{
    return
    " \
create table \"Modificators\" ( \
\"id\" INTEGER NOT NULL, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
\"probability\" REAL, \
\"price\" REAL, \
\"k_price\" REAL, \
\"k_param1\" REAL, \
\"k_param2\" REAL, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

int Object::getId() const
{
    return id;
}

void Object::setId(int id)
{
    this->id = id;
}

EObjectType Object::getType() const
{
    return EObjectType::Object;
}

Text Object::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(type);
    default:
        return "";
    }
    return "";
}

void Object::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        text_id = text.string();
        break;
    case 2:
        resource = text.string();
        break;
    case 3:
        name = std::static_pointer_cast<String>(ptr);
        break;
    case 4:
        type = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Object::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Object::getName() const
{
    Text n;
    n = to_string(name);
    if (!n.empty())
        return n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool Object::operator==(const Object &rhs) const
{
    return
        name == rhs.name &&
        resource == rhs.resource &&
        text_id == rhs.text_id &&
        type == rhs.type &&
        1;
}

int Object::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) text_id = cols[1];
    if (cols[2]) resource = cols[2];
    if (cols[3]) name.id = std::stoi(cols[3]);
    if (cols[4]) type = std::stoi(cols[4]);

    return 0;
}

const char *Object::getSql()
{
    return
    " \
create table \"Objects\" ( \
\"id\" INTEGER NOT NULL, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
\"type\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

int Player::getId() const
{
    return id;
}

void Player::setId(int id)
{
    this->id = id;
}

EObjectType Player::getType() const
{
    return EObjectType::Player;
}

Text Player::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(mechanoid);
    default:
        return "";
    }
    return "";
}

void Player::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        mechanoid = std::static_pointer_cast<Mechanoid>(ptr);
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Player::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Player::getName() const
{
    Text n;
    n = to_string(mechanoid);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool Player::operator==(const Player &rhs) const
{
    return
        mechanoid == rhs.mechanoid &&
        1;
}

int Player::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) mechanoid.id = std::stoi(cols[1]);

    return 0;
}

const char *Player::getSql()
{
    return
    " \
create table \"Players\" ( \
\"id\" INTEGER NOT NULL, \
\"mechanoid_id\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"mechanoid_id\") REFERENCES \"Mechanoids\" (\"id\") \
); \
    ";
}

int Projectile::getId() const
{
    return id;
}

void Projectile::setId(int id)
{
    this->id = id;
}

EObjectType Projectile::getType() const
{
    return EObjectType::Projectile;
}

Text Projectile::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(type);
    case 5:
        return to_string(weight);
    case 6:
        return to_string(damage);
    case 7:
        return to_string(speed);
    case 8:
        return to_string(scale);
    case 9:
        return to_string(notrade);
    default:
        return "";
    }
    return "";
}

void Projectile::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        text_id = text.string();
        break;
    case 2:
        resource = text.string();
        break;
    case 3:
        name = std::static_pointer_cast<String>(ptr);
        break;
    case 4:
        type = std::stoi(text.string());
        break;
    case 5:
        weight = std::stof(text.string());
        break;
    case 6:
        damage = std::stof(text.string());
        break;
    case 7:
        speed = std::stof(text.string());
        break;
    case 8:
        scale = std::stof(text.string());
        break;
    case 9:
        notrade = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Projectile::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Projectile::getName() const
{
    Text n;
    n = to_string(name);
    if (!n.empty())
        return n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool Projectile::operator==(const Projectile &rhs) const
{
    return
        damage == rhs.damage &&
        name == rhs.name &&
        notrade == rhs.notrade &&
        resource == rhs.resource &&
        scale == rhs.scale &&
        speed == rhs.speed &&
        text_id == rhs.text_id &&
        type == rhs.type &&
        weight == rhs.weight &&
        1;
}

int Projectile::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) text_id = cols[1];
    if (cols[2]) resource = cols[2];
    if (cols[3]) name.id = std::stoi(cols[3]);
    if (cols[4]) type = std::stoi(cols[4]);
    if (cols[5]) weight = std::stof(cols[5]);
    if (cols[6]) damage = std::stof(cols[6]);
    if (cols[7]) speed = std::stof(cols[7]);
    if (cols[8]) scale = std::stof(cols[8]);
    if (cols[9]) notrade = std::stoi(cols[9]);

    return 0;
}

const char *Projectile::getSql()
{
    return
    " \
create table \"Projectiles\" ( \
\"id\" INTEGER NOT NULL, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
\"type\" INTEGER, \
\"weight\" REAL, \
\"damage\" REAL, \
\"speed\" REAL, \
\"scale\" REAL, \
\"notrade\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

EObjectType QuestRewardEquipment::getType() const
{
    return EObjectType::QuestRewardEquipment;
}

Text QuestRewardEquipment::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(questReward);
    case 1:
        return to_string(equipment);
    case 2:
        return to_string(quantity);
    default:
        return "";
    }
    return "";
}

void QuestRewardEquipment::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        questReward = std::static_pointer_cast<QuestReward>(ptr);
        break;
    case 1:
        equipment = std::static_pointer_cast<Equipment>(ptr);
        break;
    case 2:
        quantity = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *QuestRewardEquipment::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text QuestRewardEquipment::getName() const
{
    Text n;
    n = to_string(equipment);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool QuestRewardEquipment::operator==(const QuestRewardEquipment &rhs) const
{
    return
        equipment == rhs.equipment &&
        quantity == rhs.quantity &&
        questReward == rhs.questReward &&
        1;
}

IdPtr<QuestReward> QuestRewardEquipment::operator->() const
{
    if (questReward)
        return questReward;
    throw EXCEPTION("Value is missing");
}

int QuestRewardEquipment::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) questReward.id = std::stoi(cols[0]);
    if (cols[1]) equipment.id = std::stoi(cols[1]);
    if (cols[2]) quantity = std::stoi(cols[2]);

    return 0;
}

const char *QuestRewardEquipment::getSql()
{
    return
    " \
create table \"QuestRewardEquipments\" ( \
\"questReward_id\" INTEGER NOT NULL, \
\"equipment_id\" INTEGER NOT NULL, \
\"quantity\" INTEGER, \
PRIMARY KEY (\"questReward_id\", \"equipment_id\"), \
FOREIGN KEY (\"questReward_id\") REFERENCES \"QuestRewards\" (\"id\"), \
FOREIGN KEY (\"equipment_id\") REFERENCES \"Equipments\" (\"id\") \
); \
    ";
}

EObjectType QuestRewardGlider::getType() const
{
    return EObjectType::QuestRewardGlider;
}

Text QuestRewardGlider::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(questReward);
    case 1:
        return to_string(glider);
    case 2:
        return to_string(quantity);
    default:
        return "";
    }
    return "";
}

void QuestRewardGlider::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        questReward = std::static_pointer_cast<QuestReward>(ptr);
        break;
    case 1:
        glider = std::static_pointer_cast<Glider>(ptr);
        break;
    case 2:
        quantity = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *QuestRewardGlider::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text QuestRewardGlider::getName() const
{
    Text n;
    n = to_string(glider);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool QuestRewardGlider::operator==(const QuestRewardGlider &rhs) const
{
    return
        glider == rhs.glider &&
        quantity == rhs.quantity &&
        questReward == rhs.questReward &&
        1;
}

IdPtr<QuestReward> QuestRewardGlider::operator->() const
{
    if (questReward)
        return questReward;
    throw EXCEPTION("Value is missing");
}

int QuestRewardGlider::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) questReward.id = std::stoi(cols[0]);
    if (cols[1]) glider.id = std::stoi(cols[1]);
    if (cols[2]) quantity = std::stoi(cols[2]);

    return 0;
}

const char *QuestRewardGlider::getSql()
{
    return
    " \
create table \"QuestRewardGliders\" ( \
\"questReward_id\" INTEGER NOT NULL, \
\"glider_id\" INTEGER NOT NULL, \
\"quantity\" INTEGER, \
PRIMARY KEY (\"questReward_id\", \"glider_id\"), \
FOREIGN KEY (\"questReward_id\") REFERENCES \"QuestRewards\" (\"id\"), \
FOREIGN KEY (\"glider_id\") REFERENCES \"Gliders\" (\"id\") \
); \
    ";
}

EObjectType QuestRewardGood::getType() const
{
    return EObjectType::QuestRewardGood;
}

Text QuestRewardGood::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(questReward);
    case 1:
        return to_string(good);
    case 2:
        return to_string(quantity);
    default:
        return "";
    }
    return "";
}

void QuestRewardGood::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        questReward = std::static_pointer_cast<QuestReward>(ptr);
        break;
    case 1:
        good = std::static_pointer_cast<Good>(ptr);
        break;
    case 2:
        quantity = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *QuestRewardGood::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text QuestRewardGood::getName() const
{
    Text n;
    n = to_string(good);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool QuestRewardGood::operator==(const QuestRewardGood &rhs) const
{
    return
        good == rhs.good &&
        quantity == rhs.quantity &&
        questReward == rhs.questReward &&
        1;
}

IdPtr<QuestReward> QuestRewardGood::operator->() const
{
    if (questReward)
        return questReward;
    throw EXCEPTION("Value is missing");
}

int QuestRewardGood::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) questReward.id = std::stoi(cols[0]);
    if (cols[1]) good.id = std::stoi(cols[1]);
    if (cols[2]) quantity = std::stoi(cols[2]);

    return 0;
}

const char *QuestRewardGood::getSql()
{
    return
    " \
create table \"QuestRewardGoods\" ( \
\"questReward_id\" INTEGER NOT NULL, \
\"good_id\" INTEGER NOT NULL, \
\"quantity\" INTEGER, \
PRIMARY KEY (\"questReward_id\", \"good_id\"), \
FOREIGN KEY (\"questReward_id\") REFERENCES \"QuestRewards\" (\"id\"), \
FOREIGN KEY (\"good_id\") REFERENCES \"Goods\" (\"id\") \
); \
    ";
}

EObjectType QuestRewardModificator::getType() const
{
    return EObjectType::QuestRewardModificator;
}

Text QuestRewardModificator::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(questReward);
    case 1:
        return to_string(modificator);
    case 2:
        return to_string(quantity);
    default:
        return "";
    }
    return "";
}

void QuestRewardModificator::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        questReward = std::static_pointer_cast<QuestReward>(ptr);
        break;
    case 1:
        modificator = std::static_pointer_cast<Modificator>(ptr);
        break;
    case 2:
        quantity = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *QuestRewardModificator::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text QuestRewardModificator::getName() const
{
    Text n;
    n = to_string(modificator);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool QuestRewardModificator::operator==(const QuestRewardModificator &rhs) const
{
    return
        modificator == rhs.modificator &&
        quantity == rhs.quantity &&
        questReward == rhs.questReward &&
        1;
}

IdPtr<QuestReward> QuestRewardModificator::operator->() const
{
    if (questReward)
        return questReward;
    throw EXCEPTION("Value is missing");
}

int QuestRewardModificator::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) questReward.id = std::stoi(cols[0]);
    if (cols[1]) modificator.id = std::stoi(cols[1]);
    if (cols[2]) quantity = std::stoi(cols[2]);

    return 0;
}

const char *QuestRewardModificator::getSql()
{
    return
    " \
create table \"QuestRewardModificators\" ( \
\"questReward_id\" INTEGER NOT NULL, \
\"modificator_id\" INTEGER NOT NULL, \
\"quantity\" INTEGER, \
PRIMARY KEY (\"questReward_id\", \"modificator_id\"), \
FOREIGN KEY (\"questReward_id\") REFERENCES \"QuestRewards\" (\"id\"), \
FOREIGN KEY (\"modificator_id\") REFERENCES \"Modificators\" (\"id\") \
); \
    ";
}

EObjectType QuestRewardProjectile::getType() const
{
    return EObjectType::QuestRewardProjectile;
}

Text QuestRewardProjectile::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(questReward);
    case 1:
        return to_string(projectile);
    case 2:
        return to_string(quantity);
    default:
        return "";
    }
    return "";
}

void QuestRewardProjectile::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        questReward = std::static_pointer_cast<QuestReward>(ptr);
        break;
    case 1:
        projectile = std::static_pointer_cast<Projectile>(ptr);
        break;
    case 2:
        quantity = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *QuestRewardProjectile::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text QuestRewardProjectile::getName() const
{
    Text n;
    n = to_string(projectile);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool QuestRewardProjectile::operator==(const QuestRewardProjectile &rhs) const
{
    return
        projectile == rhs.projectile &&
        quantity == rhs.quantity &&
        questReward == rhs.questReward &&
        1;
}

IdPtr<QuestReward> QuestRewardProjectile::operator->() const
{
    if (questReward)
        return questReward;
    throw EXCEPTION("Value is missing");
}

int QuestRewardProjectile::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) questReward.id = std::stoi(cols[0]);
    if (cols[1]) projectile.id = std::stoi(cols[1]);
    if (cols[2]) quantity = std::stoi(cols[2]);

    return 0;
}

const char *QuestRewardProjectile::getSql()
{
    return
    " \
create table \"QuestRewardProjectiles\" ( \
\"questReward_id\" INTEGER NOT NULL, \
\"projectile_id\" INTEGER NOT NULL, \
\"quantity\" INTEGER, \
PRIMARY KEY (\"questReward_id\", \"projectile_id\"), \
FOREIGN KEY (\"questReward_id\") REFERENCES \"QuestRewards\" (\"id\"), \
FOREIGN KEY (\"projectile_id\") REFERENCES \"Projectiles\" (\"id\") \
); \
    ";
}

EObjectType QuestRewardReputation::getType() const
{
    return EObjectType::QuestRewardReputation;
}

Text QuestRewardReputation::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(questReward);
    case 1:
        return to_string(clan);
    case 2:
        return to_string(reputation);
    default:
        return "";
    }
    return "";
}

void QuestRewardReputation::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        questReward = std::static_pointer_cast<QuestReward>(ptr);
        break;
    case 1:
        clan = std::static_pointer_cast<Clan>(ptr);
        break;
    case 2:
        reputation = std::stof(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *QuestRewardReputation::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text QuestRewardReputation::getName() const
{
    Text n;
    return IObject::getName();
}

bool QuestRewardReputation::operator==(const QuestRewardReputation &rhs) const
{
    return
        clan == rhs.clan &&
        questReward == rhs.questReward &&
        reputation == rhs.reputation &&
        1;
}

int QuestRewardReputation::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) questReward.id = std::stoi(cols[0]);
    if (cols[1]) clan.id = std::stoi(cols[1]);
    if (cols[2]) reputation = std::stof(cols[2]);

    return 0;
}

const char *QuestRewardReputation::getSql()
{
    return
    " \
create table \"QuestRewardReputations\" ( \
\"questReward_id\" INTEGER NOT NULL, \
\"clan_id\" INTEGER NOT NULL, \
\"reputation\" REAL, \
PRIMARY KEY (\"questReward_id\", \"clan_id\"), \
FOREIGN KEY (\"questReward_id\") REFERENCES \"QuestRewards\" (\"id\"), \
FOREIGN KEY (\"clan_id\") REFERENCES \"Clans\" (\"id\") \
); \
    ";
}

EObjectType QuestRewardWeapon::getType() const
{
    return EObjectType::QuestRewardWeapon;
}

Text QuestRewardWeapon::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(questReward);
    case 1:
        return to_string(weapon);
    case 2:
        return to_string(quantity);
    default:
        return "";
    }
    return "";
}

void QuestRewardWeapon::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        questReward = std::static_pointer_cast<QuestReward>(ptr);
        break;
    case 1:
        weapon = std::static_pointer_cast<Weapon>(ptr);
        break;
    case 2:
        quantity = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *QuestRewardWeapon::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text QuestRewardWeapon::getName() const
{
    Text n;
    n = to_string(weapon);
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool QuestRewardWeapon::operator==(const QuestRewardWeapon &rhs) const
{
    return
        quantity == rhs.quantity &&
        questReward == rhs.questReward &&
        weapon == rhs.weapon &&
        1;
}

IdPtr<QuestReward> QuestRewardWeapon::operator->() const
{
    if (questReward)
        return questReward;
    throw EXCEPTION("Value is missing");
}

int QuestRewardWeapon::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) questReward.id = std::stoi(cols[0]);
    if (cols[1]) weapon.id = std::stoi(cols[1]);
    if (cols[2]) quantity = std::stoi(cols[2]);

    return 0;
}

const char *QuestRewardWeapon::getSql()
{
    return
    " \
create table \"QuestRewardWeapons\" ( \
\"questReward_id\" INTEGER NOT NULL, \
\"weapon_id\" INTEGER NOT NULL, \
\"quantity\" INTEGER, \
PRIMARY KEY (\"questReward_id\", \"weapon_id\"), \
FOREIGN KEY (\"questReward_id\") REFERENCES \"QuestRewards\" (\"id\"), \
FOREIGN KEY (\"weapon_id\") REFERENCES \"Weapons\" (\"id\") \
); \
    ";
}

int QuestReward::getId() const
{
    return id;
}

void QuestReward::setId(int id)
{
    this->id = id;
}

EObjectType QuestReward::getType() const
{
    return EObjectType::QuestReward;
}

Text QuestReward::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(quest);
    case 2:
        return to_string(text_id);
    case 3:
        return to_string(money);
    case 4:
        return to_string(rating);
    default:
        return "";
    }
    return "";
}

void QuestReward::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        quest = std::static_pointer_cast<Quest>(ptr);
        break;
    case 2:
        text_id = text.string();
        break;
    case 3:
        money = std::stoi(text.string());
        break;
    case 4:
        rating = std::stof(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *QuestReward::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);

    QTreeWidgetItem *root;

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Equipments")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::QuestRewardEquipment));
    for (auto &equipment : equipments)
        equipment->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Gliders")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::QuestRewardGlider));
    for (auto &glider : gliders)
        glider->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Goods")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::QuestRewardGood));
    for (auto &good : goods)
        good->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Modificators")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::QuestRewardModificator));
    for (auto &modificator : modificators)
        modificator->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Projectiles")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::QuestRewardProjectile));
    for (auto &projectile : projectiles)
        projectile->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Reputations")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::QuestRewardReputation));
    for (auto &reputation : reputations)
        reputation->printQtTreeView(root);

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Weapons")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::QuestRewardWeapon));
    for (auto &weapon : weapons)
        weapon->printQtTreeView(root);

    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text QuestReward::getName() const
{
    Text n;
    n = to_string(quest);
    if (!n.empty())
        return n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool QuestReward::operator==(const QuestReward &rhs) const
{
    return
        money == rhs.money &&
        quest == rhs.quest &&
        rating == rhs.rating &&
        text_id == rhs.text_id &&
        1;
}

int QuestReward::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) quest.id = std::stoi(cols[1]);
    if (cols[2]) text_id = cols[2];
    if (cols[3]) money = std::stoi(cols[3]);
    if (cols[4]) rating = std::stof(cols[4]);

    return 0;
}

const char *QuestReward::getSql()
{
    return
    " \
create table \"QuestRewards\" ( \
\"id\" INTEGER NOT NULL, \
\"quest_id\" INTEGER, \
\"text_id\" TEXT, \
\"money\" INTEGER, \
\"rating\" REAL, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"quest_id\") REFERENCES \"Quests\" (\"id\") \
); \
    ";
}

int Quest::getId() const
{
    return id;
}

void Quest::setId(int id)
{
    this->id = id;
}

EObjectType Quest::getType() const
{
    return EObjectType::Quest;
}

Text Quest::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(name);
    case 3:
        return to_string(title);
    case 4:
        return to_string(description);
    case 5:
        return to_string(time);
    default:
        return "";
    }
    return "";
}

void Quest::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        text_id = text.string();
        break;
    case 2:
        name = std::static_pointer_cast<String>(ptr);
        break;
    case 3:
        title = std::static_pointer_cast<String>(ptr);
        break;
    case 4:
        description = std::static_pointer_cast<String>(ptr);
        break;
    case 5:
        time = std::stoi(text.string());
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Quest::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);

    QTreeWidgetItem *root;

    root = new QTreeWidgetItem(item, QStringList(QCoreApplication::translate("DB", "Rewards")));
    root->setData(0, Qt::UserRole, static_cast<int>(EObjectType::QuestReward));
    for (auto &reward : rewards)
        reward->printQtTreeView(root);

    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Quest::getName() const
{
    Text n;
    n = to_string(name);
    if (!n.empty())
        return n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool Quest::operator==(const Quest &rhs) const
{
    return
        description == rhs.description &&
        name == rhs.name &&
        text_id == rhs.text_id &&
        time == rhs.time &&
        title == rhs.title &&
        1;
}

int Quest::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) text_id = cols[1];
    if (cols[2]) name.id = std::stoi(cols[2]);
    if (cols[3]) title.id = std::stoi(cols[3]);
    if (cols[4]) description.id = std::stoi(cols[4]);
    if (cols[5]) time = std::stoi(cols[5]);

    return 0;
}

const char *Quest::getSql()
{
    return
    " \
create table \"Quests\" ( \
\"id\" INTEGER NOT NULL, \
\"text_id\" TEXT, \
\"name_id\" INTEGER, \
\"title_id\" INTEGER, \
\"description_id\" INTEGER, \
\"time\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\"), \
FOREIGN KEY (\"title_id\") REFERENCES \"Strings\" (\"id\"), \
FOREIGN KEY (\"description_id\") REFERENCES \"Strings\" (\"id\") \
); \
    ";
}

EObjectType ScriptVariable::getType() const
{
    return EObjectType::ScriptVariable;
}

Text ScriptVariable::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(variable);
    case 1:
        return to_string(value);
    default:
        return "";
    }
    return "";
}

void ScriptVariable::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        variable = text.string();
        break;
    case 1:
        value = text.string();
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *ScriptVariable::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text ScriptVariable::getName() const
{
    Text n;
    n = variable;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool ScriptVariable::operator==(const ScriptVariable &rhs) const
{
    return
        value == rhs.value &&
        variable == rhs.variable &&
        1;
}

int ScriptVariable::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) variable = cols[0];
    if (cols[1]) value = cols[1];

    return 0;
}

const char *ScriptVariable::getSql()
{
    return
    " \
create table \"ScriptVariables\" ( \
\"variable\" TEXT NOT NULL, \
\"value\" TEXT, \
PRIMARY KEY (\"variable\") \
); \
    ";
}

EObjectType Setting::getType() const
{
    return EObjectType::Setting;
}

Text Setting::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(player);
    default:
        return "";
    }
    return "";
}

void Setting::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        player = std::static_pointer_cast<Player>(ptr);
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Setting::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Setting::getName() const
{
    Text n;
    return IObject::getName();
}

bool Setting::operator==(const Setting &rhs) const
{
    return
        player == rhs.player &&
        1;
}

int Setting::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) player.id = std::stoi(cols[0]);

    return 0;
}

const char *Setting::getSql()
{
    return
    " \
create table \"Settings\" ( \
\"player_id\" INTEGER NOT NULL, \
PRIMARY KEY (\"player_id\"), \
FOREIGN KEY (\"player_id\") REFERENCES \"Players\" (\"id\") \
); \
    ";
}

int String::getId() const
{
    return id;
}

void String::setId(int id)
{
    this->id = id;
}

EObjectType String::getType() const
{
    return EObjectType::String;
}

Text String::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(ru);
    case 2:
        return to_string(en);
    default:
        return "";
    }
    return "";
}

void String::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        ru = text.string();
        break;
    case 2:
        en = text.string();
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *String::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text String::getName() const
{
    auto s = ((Text *)&ru)[gCurrentLocalizationId];
    if (!s.empty())
        return s;
    for (int i = 0; i < static_cast<int>(LocalizationType::max); i++)
    {
        s = ((Text *)&ru)[i];
        if (!s.empty())
            return s;
    }
    return s;
}

bool String::operator==(const String &rhs) const
{
    return
        en == rhs.en &&
        ru == rhs.ru &&
        1;
}

int String::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) ru = cols[1];
    if (cols[2]) en = cols[2];

    return 0;
}

const char *String::getSql()
{
    return
    " \
create table \"Strings\" ( \
\"id\" INTEGER NOT NULL, \
\"ru\" TEXT, \
\"en\" TEXT, \
PRIMARY KEY (\"id\") \
); \
    ";
}

int Weapon::getId() const
{
    return id;
}

void Weapon::setId(int id)
{
    this->id = id;
}

EObjectType Weapon::getType() const
{
    return EObjectType::Weapon;
}

Text Weapon::getVariableString(int columnId) const
{
    switch (columnId)
    {
    case 0:
        return to_string(id);
    case 1:
        return to_string(text_id);
    case 2:
        return to_string(resource);
    case 3:
        return to_string(name);
    case 4:
        return to_string(type);
    case 5:
        return to_string(standard);
    case 6:
        return to_string(weight);
    case 7:
        return to_string(power);
    case 8:
        return to_string(firerate);
    case 9:
        return to_string(damage);
    case 10:
        return to_string(price);
    case 11:
        return to_string(projectile);
    default:
        return "";
    }
    return "";
}

void Weapon::setVariableString(int columnId, Text text, Ptr<IObject> ptr)
{
    switch (columnId)
    {
    case 0:
        id = std::stoi(text.string());
        break;
    case 1:
        text_id = text.string();
        break;
    case 2:
        resource = text.string();
        break;
    case 3:
        name = std::static_pointer_cast<String>(ptr);
        break;
    case 4:
        type = std::stoi(text.string());
        break;
    case 5:
        standard = std::stoi(text.string());
        break;
    case 6:
        weight = std::stof(text.string());
        break;
    case 7:
        power = std::stof(text.string());
        break;
    case 8:
        firerate = std::stof(text.string());
        break;
    case 9:
        damage = std::stof(text.string());
        break;
    case 10:
        price = std::stof(text.string());
        break;
    case 11:
        projectile = std::static_pointer_cast<Projectile>(ptr);
        break;
    default:
        break;
    }
}

#ifdef USE_QT
QTreeWidgetItem *Weapon::printQtTreeView(QTreeWidgetItem *parent) const
{
    auto item = new QTreeWidgetItem(parent, QStringList(QString::fromStdWString(getName())));
    item->setData(0, Qt::UserRole, (uint64_t)this);
    item->sortChildren(0, Qt::AscendingOrder);
    return item;
}
#endif

Text Weapon::getName() const
{
    Text n;
    n = to_string(name);
    if (!n.empty())
        return n;
    n = text_id;
    if (!n.empty())
        return n;
    return IObject::getName();
}

bool Weapon::operator==(const Weapon &rhs) const
{
    return
        damage == rhs.damage &&
        firerate == rhs.firerate &&
        name == rhs.name &&
        power == rhs.power &&
        price == rhs.price &&
        projectile == rhs.projectile &&
        resource == rhs.resource &&
        standard == rhs.standard &&
        text_id == rhs.text_id &&
        type == rhs.type &&
        weight == rhs.weight &&
        1;
}

int Weapon::loadFromSqlite3(int ncols, char **cols, char **names)
{
    if (cols[0]) id = std::stoi(cols[0]);
    if (cols[1]) text_id = cols[1];
    if (cols[2]) resource = cols[2];
    if (cols[3]) name.id = std::stoi(cols[3]);
    if (cols[4]) type = std::stoi(cols[4]);
    if (cols[5]) standard = std::stoi(cols[5]);
    if (cols[6]) weight = std::stof(cols[6]);
    if (cols[7]) power = std::stof(cols[7]);
    if (cols[8]) firerate = std::stof(cols[8]);
    if (cols[9]) damage = std::stof(cols[9]);
    if (cols[10]) price = std::stof(cols[10]);
    if (cols[11]) projectile.id = std::stoi(cols[11]);

    return 0;
}

const char *Weapon::getSql()
{
    return
    " \
create table \"Weapons\" ( \
\"id\" INTEGER NOT NULL, \
\"text_id\" TEXT, \
\"resource\" TEXT, \
\"name_id\" INTEGER, \
\"type\" INTEGER, \
\"standard\" INTEGER, \
\"weight\" REAL, \
\"power\" REAL, \
\"firerate\" REAL, \
\"damage\" REAL, \
\"price\" REAL, \
\"projectile_id\" INTEGER, \
PRIMARY KEY (\"id\"), \
FOREIGN KEY (\"name_id\") REFERENCES \"Strings\" (\"id\"), \
FOREIGN KEY (\"projectile_id\") REFERENCES \"Projectiles\" (\"id\") \
); \
    ";
}

