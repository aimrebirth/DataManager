/*
 * Polygon-4 Data Manager
 * Copyright (C) 2015-2016 lzwdgc
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <Polygon4/DataManager/Schema/Schema.h>

#include <Polygon4/DataManager/Schema/Print.h>

#include "Ast.h"

const std::string dll = "DLL_EXPORT";
const std::string dataClassPtr = "IdPtr";
const std::string storageImpl = "StorageImpl";
const std::string iObject = "IObjectBase";
const std::string idAccess = ".id";
const std::string String = "String";
const std::string containerAccess = ".";
const std::string sqlBegin = "R\"sql(";
const std::string sqlEnd = ")sql\"";
const std::string objectType = "EObjectType";
const std::string variableType = "EVariableType";
const std::string objectArray = "CObjectArray";

std::string ctableType(const std::string &s)
{
    return "CTable<" + s + ">";
}

std::string splitWords(std::string s)
{
    std::string r;
    for (size_t i = 0; i < s.size(); i++)
    {
        if (isupper(s[i]) && i)
            r += " ";
        r += s[i];
    }
    return r;
}

DataType dataTypeFromName(const Name &name)
{
    if (name == "int" ||
        name == "int32_t" ||
        name == "uint32_t" ||
        name.find("int") != Name::npos)
        return DataType::Integer;
    if (name == "float" || name.find("double") != Name::npos)
        return DataType::Real;
    if (name == "bool")
        return DataType::Bool;
    if (name == "Text")
        return DataType::Text;
    if (name == "Blob")
        return DataType::Blob;
    return DataType::Complex;
}

std::string dataTypeToSqlite3(DataType t)
{
    std::string s;
    switch (t)
    {
    case DataType::Integer:
    case DataType::Complex:
    case DataType::Bool:
    case DataType::Enum:
        s += "INTEGER";
        break;
    case DataType::Real:
        s += "REAL";
        break;
    case DataType::Text:
        s += "TEXT";
        break;
    case DataType::Blob:
    case DataType::ComplexArray:
    case DataType::Array:
        s += "BLOB";
        break;
    default:
        assert(false && "Type not found");
        break;
    }
    return s;
}

ModuleContext Schema::printObjectInterfaces() const
{
    ModuleContext mc;
    mc.hpp.addLine(autogenerated_warning);
    mc.hpp.addLine();
    mc.hpp.addLine(pragma_once);
    mc.hpp.addLine();
    mc.hpp.beginNamespace("polygon4");
    for (auto &c : getClasses())
    {
        auto name = c.getCppName();
        auto nameUpper = name;
        std::transform(name.begin(), name.end(), nameUpper.begin(), ::toupper);
        mc.hpp.addLineNoSpace("#ifndef POLYGON4_" + nameUpper + "_INTERFACE");
        mc.hpp.addLineNoSpace("DECLARE_INTERFACE_STUB(" + name + ");");
        mc.hpp.addLineNoSpace("#endif");
        mc.hpp.addLine();
    }
    mc.hpp.endNamespace();
    return mc;
}

ModuleContext Schema::printForwardDeclarations() const
{
    auto cls = getClasses();

    ModuleContext mc;
    mc.hpp.before().addLine(autogenerated_warning);
    mc.hpp.before().addLine();
    mc.hpp.before().addLine(pragma_once);
    mc.hpp.before().addLine();
    mc.hpp.before().beginNamespace("polygon4");
    mc.hpp.before().beginNamespace("detail");
    for (auto &c : cls)
        mc.hpp.addLine("class " + c.getCppName() + ";");
    mc.hpp.addLine();
    mc.hpp.after().endNamespace("detail");
    mc.hpp.after().endNamespace("polygon4");
    return mc;
}

ModuleContext Schema::printTypes() const
{
    auto cls = getClasses();

    ModuleContext mc;
    mc.hpp.before().addLine(autogenerated_warning);
    mc.hpp.before().addLine();
    mc.hpp.before().addLine(pragma_once);
    mc.hpp.before().addLine();
    mc.hpp.before().beginNamespace("polygon4");
    mc.hpp.before().beginNamespace("detail");

    mc.cpp.addLine(autogenerated_warning);
    mc.cpp.addLine();
    mc.cpp.addLine("const float float_eps = 0.00001f;");
    mc.cpp.addLine();
    for (auto &c : cls)
        mc += c.print();

    mc.hpp.after().endNamespace("detail");
    mc.hpp.after().endNamespace("polygon4");
    return mc;
}

ModuleContext Schema::printEnums() const
{
    auto cls = getClasses();

    ModuleContext mc;
    mc.hpp.before().addLine(autogenerated_warning);
    mc.hpp.before().addLine();
    mc.hpp.before().addLine(pragma_once);
    mc.hpp.before().addLine();
    mc.hpp.before().beginNamespace("polygon4");
    mc.hpp.before().beginNamespace("detail");
    mc.hpp.before().addLine("EnumTable DLL_EXPORT getOrderedMap(const std::string &type_name);");
    mc.hpp.before().addLine();
    for (auto &e : enums)
        mc += e.print();
    
    // variables
    /*{
        std::map<std::string, Variable> vars;
        mc.hpp.beginBlock("enum class " + variableType + " : EnumType");
        for (auto &c : cls)
        {
            auto vs = c.getVariables();
            for (auto &v : vs)
            {
                auto i = vars.find(v.getName());
                if (i != vars.end())
                {
                    assert(i->second.getType() == v.getType());
                }
                vars[v.getName()] = v;
            }
        }
        for (auto &v : vars)
        {
            mc.hpp.addLine(v.first + ",");
        }
        mc.hpp.endBlock(true);
    }*/

    mc.hpp.after().endNamespace("detail");
    for (auto &e : enums)
    {
        mc.hpp.after().addLine("String tr(detail::" + e.getCppName() + " e);");
    }
    mc.hpp.after().addLine();
    mc.hpp.after().endNamespace("polygon4");

    mc.cpp.before().addLine(autogenerated_warning);
    mc.cpp.before().addLine();
    mc.cpp.before().beginNamespace("polygon4");
    mc.cpp.before().beginNamespace("detail");
    for (auto &e : enums)
        mc += e.printTableRecord();

    // getOrderedMap()
    {
        mc.cpp.after().beginFunction("EnumTable getOrderedMap(const std::string &type_name)");
        mc.cpp.after().addLine("EnumTable et;");
        mc.cpp.after().addLine("std::string ending;");
        for (auto &e : enums)
        {
            mc.cpp.after().addLine("ending = \"" + e.getEnding() + "\";");
            mc.cpp.after().addLine("CREATE_TABLE(" + e.getCppName() + ");");
        }
        mc.cpp.after().addLine("return et;");
        mc.cpp.after().endFunction();
    }

    mc.cpp.after().endNamespace("detail");
    for (auto &e : enums)
    {
        mc.cpp.after().beginFunction("String tr(detail::" + e.getCppName() + " e)");
        mc.cpp.after().addLine("auto i = detail::" + e.getTableName() + ".find(e);");
        mc.cpp.after().addLine("if (i != detail::" + e.getTableName() + ".end())");
        mc.cpp.after().increaseIndent();
        mc.cpp.after().addLine("return tr(i->second);");
        mc.cpp.after().decreaseIndent();
        mc.cpp.after().addLine("return MISSING_VALUE;");
        mc.cpp.after().endFunction();
    }
    mc.cpp.after().endNamespace("polygon4");

    return mc;
}

ModuleContext Schema::printStorage() const
{
    const auto cls = getClasses();

    ModuleContext mc;
    mc.hpp.addLine(autogenerated_warning);
    mc.hpp.addLine();
    mc.hpp.addLine(pragma_once);
    mc.hpp.addLine();
    mc.hpp.beginBlock("class Storage");
    mc.hpp.addLineNoSpace("public:");
    for (auto &c : cls)
        mc.hpp.addLine(ctableType(c.getCppName()) + " " + c.getCppArrayVariableName() + ";");
    mc.hpp.addLine();
    mc.hpp.addLineNoSpace("public:");
    mc.hpp.addLine("Storage();");
    mc.hpp.addLine("virtual ~Storage();");
    mc.hpp.addLine();
    mc.hpp.addLine("virtual void create() const = 0;");
    mc.hpp.addLine("virtual void clear() = 0;");
    mc.hpp.addLine();
    mc.hpp.addLine("virtual void load(ProgressCallback callback = ProgressCallback()) = 0;");
    mc.hpp.addLine("virtual void save(ProgressCallback callback = ProgressCallback()) const = 0;");
    mc.hpp.addLine();
    mc.hpp.addLine("virtual Ptr<TreeItem> printTree() const = 0;");
    mc.hpp.addLine();
    mc.hpp.addLine("virtual Ptr<TreeItem> addRecord(TreeItem *item) = 0;");
    mc.hpp.addLine("virtual bool deleteRecord(TreeItem *item) = 0;");
    mc.hpp.addLine();
    mc.hpp.addLine("virtual OrderedObjectMap getOrderedMap(" + objectType + " type, CheckFunction f = CheckFunction()) const = 0;");
    mc.hpp.addLine();

    // printAddDeleteRecordVirtual()
    {
        for (auto &c : cls)
            mc += c.printAddDeleteRecordVirtual();
        mc.hpp.addLine();
        mc.hpp.addLine("virtual " + dataClassPtr + "<" + iObject + "> addRecord(" + iObject + " *parent = nullptr) = 0;");
        mc.hpp.addLine("virtual void deleteRecord(" + iObject + " *data) = 0;");
    }
    mc.hpp.endBlock(true);

    mc.cpp.addLine(autogenerated_warning);
    mc.cpp.addLine();
    mc.cpp.beginFunction("Storage::Storage()");
    for (auto &c : cls)
        mc.cpp.addLine(c.getCppArrayVariableName() + ".setName(\"" + c.getCppName() + "\");");
    mc.cpp.endFunction();
    mc.cpp.beginFunction("Storage::~Storage()");
    mc.cpp.endBlock();
    return mc;
}

ModuleContext Schema::printStorageImplementation() const
{
    const auto cls = getClasses();

    ModuleContext mc;
    mc.hpp.addLine(autogenerated_warning);
    mc.hpp.addLine();
    mc.hpp.addLine(pragma_once);
    mc.hpp.addLine();
    mc.hpp.beginFunction("class StorageImpl : public Storage");
    mc.hpp.addLineNoSpace("private:");
    mc.hpp.addLine("std::shared_ptr<Database> db;");
    mc.hpp.addLine();
    mc.hpp.addLineNoSpace("private:");

    mc.cpp.addLine(autogenerated_warning);
    mc.cpp.addLine();
    for (auto &c : cls)
    {
        mc += c.printIo();
        mc.hpp.addLine();
    }

    mc.hpp.addLineNoSpace("public:");
    mc.hpp.addLine("StorageImpl(std::shared_ptr<Database> db) : db(db) {}");
    mc.hpp.addLine();
    mc.hpp.addLine("void setDb(std::shared_ptr<Database> db) { this->db = db; }");
    mc.hpp.addLine();

    // create()
    {
        mc.hpp.addLine("virtual void create() const override;");

        mc.cpp.beginFunction("void " + storageImpl + "::create() const");
        for (auto &c : cls)
            mc.cpp.addLine("db->execute(" + c.getCppName() + "::getSql()" + ");");
        mc.cpp.endFunction();
    }

    // clear()
    {
        mc.hpp.addLine("virtual void clear() override;");

        mc.cpp.beginFunction("void " + storageImpl + "::clear()");
        for (auto &c : cls)
            mc.cpp.addLine(c.getCppArrayVariableName() + ".clear();");
        mc.cpp.endFunction();
    }

    // load()
    {
        double step = 100.0 / (cls.size() * 3.0);
        double progress = 0;

        mc.hpp.addLine("virtual void load(ProgressCallback callback = ProgressCallback()) override;");

        mc.cpp.beginFunction("void " + storageImpl + "::load(ProgressCallback callback)");
        for (auto &c : cls)
        {
            mc.cpp.addLine("_load" + c.getSqlName() + "();");
            mc.cpp.addLine("PROGRESS_CALLBACK(" + std::to_string(progress += step) + ");");
        }
        mc.cpp.addLine();
        for (auto &c : cls)
        {
            mc.cpp.addLine("_load" + c.getSqlName() + "Ptrs();");
            mc.cpp.addLine("PROGRESS_CALLBACK(" + std::to_string(progress += step) + ");");
        }
        mc.cpp.addLine();
        for (auto &c : cls)
        {
            mc.cpp.addLine("_load" + c.getSqlName() + "Arrays();");
            mc.cpp.addLine("PROGRESS_CALLBACK(" + std::to_string(progress += step) + ");");
        }
        mc.cpp.endFunction();
    }

    // save()
    {
        double step = 100.0 / cls.size();
        double progress = 0;

        mc.hpp.addLine("virtual void save(ProgressCallback callback = ProgressCallback()) const override;");

        mc.cpp.beginFunction("void " + storageImpl + "::save(ProgressCallback callback) const");
        for (auto &c : cls)
        {
            mc.cpp.addLine("_save" + c.getSqlName() + "();");
            mc.cpp.addLine("PROGRESS_CALLBACK(" + std::to_string(progress += step) + ");");
        }
        mc.cpp.endFunction();
    }

    // printAddDeleteRecord()
    {
        mc.hpp.addLine();
        for (auto &c : cls)
            mc += c.printAddDeleteRecord();
        mc.hpp.addLine();

        // addRecord()
        {
            mc.hpp.addLine("virtual " + dataClassPtr + "<" + iObject + "> addRecord(" + iObject + " *parent = nullptr) override;");

            mc.cpp.beginFunction("" + dataClassPtr + "<" + iObject + "> " + storageImpl + "::addRecord(" + iObject + " *parent)");
            mc.cpp.addLine("" + dataClassPtr + "<" + iObject + "> p;");
            mc.cpp.addLine("" + objectType + " type = parent->getType();");
            mc.cpp.beginBlock("switch (type)", false);
            for (auto &c : cls)
            {
                mc.cpp.addLine("case " + objectType + "::" + c.getCppName() + ":");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("p = add" + c.getCppName() + "(" + (c.getParent() ? "parent" : "") + ");");
                mc.cpp.addLine("break;");
                mc.cpp.decreaseIndent();
            }
            mc.cpp.addLine("default:");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("break;");
            mc.cpp.endBlock();
            mc.cpp.addLine("return p;");
            mc.cpp.endFunction();
        }

        // deleteRecord()
        {
            mc.hpp.addLine("virtual void deleteRecord(" + iObject + " *data) override;");

            mc.cpp.beginFunction("void " + storageImpl + "::deleteRecord(" + iObject + " *data)");
            mc.cpp.addLine("" + objectType + " type = data->getType();");
            mc.cpp.beginBlock("switch (type)", false);
            for (auto &c : cls)
            {
                mc.cpp.addLine("case " + objectType + "::" + c.getCppName() + ":");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("delete" + c.getCppName() + "(data);");
                mc.cpp.addLine("break;");
                mc.cpp.decreaseIndent();
            }
            mc.cpp.addLine("default:");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("break;");
            mc.cpp.endBlock();
            mc.cpp.endFunction();
        }
    }
    
    // printTree()
    {
        mc.hpp.addLine();

        // printTree()
        {
            mc.hpp.addLine("virtual Ptr<TreeItem> printTree() const override;");

            mc.cpp.beginFunction("Ptr<TreeItem> " + storageImpl + "::printTree() const");
            mc.cpp.addLine("Ptr<TreeItem> root = std::make_shared<TreeItem>();");
            mc.cpp.addLine("Ptr<TreeItem> item;");
            mc.cpp.addLine("Ptr<TreeItem> tmp;");
            for (auto &c : cls)
            {
                if (!c.getFlags()[fTreeView])
                    continue;
                mc.cpp.addLine();
                mc.cpp.addLine("item = std::make_shared<TreeItem>();");
                mc.cpp.addLine("item->name = \"" + splitWords(c.getCppArrayName()) + "\";");
                mc.cpp.addLine("item->type = " + objectType + "::" + c.getCppName() + ";");
                mc.cpp.addLine("item->parent = root.get();");
                mc.cpp.addLine("auto " + c.getCppArrayVariableName() + " = getOrderedMap(" + objectType + "::" + c.getCppName() + ");");
                if (c.getFlags()[fSplitBy])
                {
                    auto split_var = c.getSplitByVariable();
                    auto var_type = split_var.getType()->getCppName();
                    mc.cpp.beginBlock();
                    mc.cpp.addLine("std::unordered_map<" + var_type + ", Ptr<TreeItem>> categories;");
                    mc.cpp.beginBlock("for (auto &v : " + c.getCppArrayVariableName() + ")");
                    mc.cpp.addLine("tmp = v.second->printTree();");
                    mc.cpp.addLine("auto o = (" + c.getCppName() + " *)tmp->object;");
                    mc.cpp.addLine("if (!categories[o->" + split_var.getName() + "])");
                    mc.cpp.increaseIndent();
                    mc.cpp.addLine("categories[o->" + split_var.getName() + "] = std::make_shared<TreeItem>();");
                    mc.cpp.decreaseIndent();
                    mc.cpp.addLine("categories[o->" + split_var.getName() + "]->children.push_back(tmp);");
                    mc.cpp.addLine("tmp->parent = categories[o->" + split_var.getName() + "].get();");
                    mc.cpp.endBlock();
                    mc.cpp.beginBlock("for (auto &v : categories)");
                    mc.cpp.addLine("v.second->type = " + objectType + "::None;");
                    mc.cpp.addLine("v.second->name = polygon4::tr(v.first);");
                    mc.cpp.addLine("item->children.push_back(v.second);");
                    mc.cpp.addLine("v.second->parent = item.get();");
                    mc.cpp.endBlock();
                    mc.cpp.endBlock();
                }
                else
                {
                    mc.cpp.addLine("for (auto &v : " + c.getCppArrayVariableName() + ")");
                    mc.cpp.beginBlock();
                    mc.cpp.addLine("item->children.push_back(tmp = v.second->printTree());");
                    mc.cpp.addLine("tmp->parent = item.get();");
                    mc.cpp.endBlock();
                }
                mc.cpp.addLine("root->children.push_back(item);");
            }
            mc.cpp.addLine();
            mc.cpp.addLine("return root;");
            mc.cpp.endFunction();
        }

        // addRecord()
        {
            mc.hpp.addLine("virtual Ptr<TreeItem> addRecord(TreeItem *item) override;");

            mc.cpp.beginFunction("Ptr<TreeItem> " + storageImpl + "::addRecord(TreeItem *item)");
            mc.cpp.beginBlock("if (!item)");
            mc.cpp.addLine("return nullptr;");
            mc.cpp.endBlock();
            mc.cpp.beginBlock("while ((item && item->object) || item->type == polygon4::detail::EObjectType::None)");
            mc.cpp.addLine("item = item->parent;");
            mc.cpp.endBlock();
            mc.cpp.beginBlock("if (item->flags[fReadOnly])");
            mc.cpp.addLine("return nullptr;");
            mc.cpp.endBlock();
            mc.cpp.beginBlock("if (item->type == polygon4::detail::EObjectType::InlineVariables)");
            mc.cpp.addLine("return nullptr;");
            mc.cpp.endBlock();
            mc.cpp.beginBlock("if (item->inlineVariable && item->object)");
            mc.cpp.addLine("return nullptr;");
            mc.cpp.endBlock();
            mc.cpp.addLine();
            mc.cpp.addLine("Ptr<TreeItem> tmp;");
            mc.cpp.beginBlock("switch (item->type)", false);
            for (auto &c : cls)
            {
                mc.cpp.addLine("case " + objectType + "::" + c.getCppName() + ":");
                mc.cpp.beginBlock();
                if (c.getParent())
                {
                    mc.cpp.addLine("auto p = item;");
                    mc.cpp.addLine("while (!p->parent->object)");
                    mc.cpp.increaseIndent();
                    mc.cpp.addLine("p = p->parent;");
                    mc.cpp.decreaseIndent();
                }
                auto sw = [&](const std::string &item)
                {
                    mc.cpp.beginBlock("switch (" + item + "->type)", false);
                    for (auto &c2 : cls)
                    {
                        const auto vars = c2.getVariables();
                        const auto vars_inline = vars({ fInline });
                        for (auto &v : vars_inline)
                        {
                            if (v.hasFlags({ fArray }))
                                continue;
                            if (v.getType()->getCppName() != c.getCppName())
                                continue;
                            mc.cpp.addLine("case " + objectType + "::" + c2.getCppName() + ":");
                            mc.cpp.beginBlock();
                            auto &ivs = v.getInitialValues();
                            for (auto &iv : ivs)
                            {
                                auto &iv_var = iv.first;
                                std::string enum_name;
                                if (iv_var.getType()->getCppName() == objectType)
                                    enum_name = objectType + "::";
                                mc.cpp.addLine("v->" + iv.first.getName() + " = " + enum_name + iv.second + ";");
                            }
                            mc.cpp.addLine("break;");
                            mc.cpp.endBlock();
                        }
                    }
                    mc.cpp.addLine("default:");
                    mc.cpp.increaseIndent();
                    mc.cpp.addLine("break;");
                    mc.cpp.endBlock();
                };
                mc.cpp.addLine("auto v = add" + c.getCppName() + "(" + (c.getParent() ? "p->parent->object" : "") + ");");
                mc.cpp.beginBlock("if (item->inlineVariable)");
                mc.cpp.addLine("*(" + dataClassPtr + "<" + c.getCppName() + ">*)item->inlineVariable = v;");
                mc.cpp.addLine("item->object = v.get();");
                //mc.cpp.addLine("auto i = std::find_if(item->parent->children.begin(), item->parent->children.end(), " \
                    "[item](const auto &c) { return c.get() == item; }); ");
                //mc.cpp.addLine("tmp = *i;");                
                // FIXME: ?
                //mc.cpp.addLine("item = item->parent;");
                //mc.cpp.addLine("while (!item->object)");
                //mc.cpp.increaseIndent();
                //mc.cpp.addLine("item = item->parent;");
                //mc.cpp.decreaseIndent();
                //sw("item");
                mc.cpp.endBlock();
                mc.cpp.beginBlock("else");
                mc.cpp.addLine("item->children.push_back(tmp = v->printTree());");
                mc.cpp.addLine("tmp->parent = item;");
                mc.cpp.endBlock();
                mc.cpp.beginBlock("if (item->objectArrayVariable)");
                mc.cpp.addLine("auto vec = (" + objectArray + "<" + c.getCppName() + ">*)item->objectArrayVariable;");
                //mc.cpp.addLine("while (!item->object)");
                //mc.cpp.increaseIndent();
                //mc.cpp.addLine("item = item->parent;");
                //mc.cpp.decreaseIndent();
                //sw("item");
                mc.cpp.addLine("vec->push_back(v);");
                mc.cpp.endBlock();
                mc.cpp.addLine("break;");
                mc.cpp.endBlock();
            }
            mc.cpp.addLine("default:");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("break;");
            mc.cpp.endBlock();
            mc.cpp.addLine("return tmp;");
            mc.cpp.endFunction();
        }

        // deleteRecord()
        {
            mc.hpp.addLine("virtual bool deleteRecord(TreeItem *item) override;");

            mc.cpp.beginFunction("bool " + storageImpl + "::deleteRecord(TreeItem *item)");
            mc.cpp.beginBlock("if (!item || !item->object)");
            mc.cpp.addLine("return false;");
            mc.cpp.endBlock();
            mc.cpp.beginBlock("if (item->flags[fReadOnly])");
            mc.cpp.addLine("return false;");
            mc.cpp.endBlock();
            mc.cpp.emptyLines(1);
            mc.cpp.addLine("auto parent = item->parent;");            
            mc.cpp.beginBlock("switch (item->type)", false);
            for (auto &c : cls)
            {
                mc.cpp.addLine("case " + objectType + "::" + c.getCppName() + ":");
                mc.cpp.beginBlock();
                mc.cpp.beginBlock("if (parent && parent->objectArrayVariable)");
                mc.cpp.addLine("auto vec = (" + objectArray + "<" + c.getCppName() + ">*)parent->objectArrayVariable;");
                mc.cpp.beginBlock("for (auto i = vec->begin(); i != vec->end(); ++i)");
                mc.cpp.beginBlock("if (i->ptr == item->object)");
                mc.cpp.addLine("vec->erase(i);");
                mc.cpp.addLine("break;");
                mc.cpp.endBlock();
                mc.cpp.endBlock();
                mc.cpp.endBlock();
                mc.cpp.addLine("delete" + c.getCppName() + "(item->object);");
                mc.cpp.beginBlock("if (item->inlineVariable)");
                mc.cpp.addLine("*(" + dataClassPtr + "<" + c.getCppName() + ">*)item->inlineVariable = " + dataClassPtr + "<" + c.getCppName() + ">();");
                mc.cpp.addLine("item->object = nullptr;");
                mc.cpp.addLine("item->name.clear();");
                mc.cpp.endBlock();
                mc.cpp.addLine("break;");
                mc.cpp.endBlock();
            }
            mc.cpp.addLine("default:");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("break;");
            mc.cpp.endBlock();
            mc.cpp.addLine("return true;");
            mc.cpp.endFunction();
        }
    }

    // printGetOrderedMap()
    if (1)
    {
        mc.hpp.addLine();
        mc.hpp.addLine("virtual OrderedObjectMap getOrderedMap(" + objectType + " type, CheckFunction f = CheckFunction()) const override;");

        auto prnt = [&](bool f)
        {
            mc.cpp.beginBlock("switch (type)", false);
            for (auto &c : cls)
            {
                mc.cpp.addLine("case " + objectType + "::" + c.getCppName() + ":");
                mc.cpp.increaseIndent();
                mc.cpp.addLine("return " + c.getCppArrayVariableName() + ".getOrderedObjectMap(" + (f ? "f" : "") + ");");
                mc.cpp.decreaseIndent();
            }
            mc.cpp.addLine("default:");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return OrderedObjectMap();");
            mc.cpp.endBlock();
        };

        mc.cpp.addLine();
        mc.cpp.beginFunction("OrderedObjectMap " + storageImpl + "::getOrderedMap(" + objectType + " type, CheckFunction f) const");
        mc.cpp.beginBlock("if (f)");
        prnt(true);
        mc.cpp.endBlock();
        mc.cpp.beginBlock("else");
        prnt(false);
        mc.cpp.endBlock();
        mc.cpp.endFunction();
    }

    mc.hpp.endBlock(true);
    return mc;
}

ModuleContext Class::print() const
{
    ModuleContext mc;
    const auto vars = getVariables();
    const auto vars_container = getVariables(true);
    const auto vars_inline = vars({ fInline });

    // enums
    if (flags[fCreateEnum])
    {
        mc.hpp.beginBlock("enum class " + getEnumName() + " : EnumType");
        for (auto &v : vars)
        {
            if (v.getFlags()[fEnumItem])
                mc.hpp.addLine(v.getName() + ",");
        }
        mc.hpp.addLine();
        mc.hpp.addLine("max,");
        mc.hpp.endBlock(true);
        mc.hpp.emptyLines(1);
    }

    // class, data
    {
        mc.hpp.beginBlock("class " + dll + " " + getCppName() + " : public I" + getCppName());
        mc.hpp.addLine("// data");
        mc.hpp.addLineNoSpace("public:");
        printVariables(mc);
    }

    // containers
    if (!vars_container.empty())
    {
        mc.hpp.emptyLines(1);
        for (auto &v : vars_container)
            mc.hpp.addLine(v.print() + ";");
    }

    mc.hpp.emptyLines(1);
    mc.hpp.addLine("// constructors");
    mc.hpp.addLineNoSpace("public:");

    // constructors
    {
        mc.hpp.addLine(getCppName() + "();");
        mc.hpp.addLine(getCppName() + "(const " + getCppName() + " &);");
        mc.hpp.addLine(getCppName() + " &operator=(const " + getCppName() + " &);");
        mc.hpp.addLine(getCppName() + "(" + getCppName() + " &&) = default;");
        mc.hpp.addLine(getCppName() + " &operator=(" + getCppName() + " &&) = default;");
        mc.hpp.addLine("virtual ~" + getCppName() + "();");

        // default ctor
        mc.cpp.beginFunction(getCppName() + "::" + getCppName() + "()");
        mc.cpp.endFunction();

        // copy ctor
        mc.cpp.beginFunction(getCppName() + "::" + getCppName() + "(const " + getCppName() + " &rhs)");
        mc.cpp.addLine("copyFrom(rhs);");
        mc.cpp.endFunction();

        // copy assign
        mc.cpp.beginFunction(getCppName() + " &" + getCppName() + "::operator=(const " + getCppName() + " &rhs)");
        mc.cpp.addLine("copyFrom(rhs);");
        mc.cpp.addLine("return *this;");
        mc.cpp.endFunction();

        // dtor: prevent different destructors for dll and exe
        mc.cpp.beginFunction(getCppName() + "::~" + getCppName() + "()");
        mc.cpp.endFunction();
    }

    mc.hpp.emptyLines(1);
    mc.hpp.addLine("// functions");
    mc.hpp.addLineNoSpace("public:");

    // hasId()
    if (hasIdField)
    {
        mc.hpp.addLine("virtual bool hasId() const override;");

        mc.cpp.beginFunction("bool " + getCppName() + "::hasId() const");
        mc.cpp.addLine("return true;");
        mc.cpp.endFunction();
    }

    // getType()
    {
        mc.hpp.addLine("virtual " + objectType + " getType() const override;");

        mc.cpp.beginFunction("" + objectType + " " + getCppName() + "::getType() const");
        mc.cpp.addLine("return object_type;");
        mc.cpp.endFunction();
    }

    // getVariableString()
    {
        mc.hpp.addLine("virtual Text getVariableString(int columnId) const override;");

        mc.cpp.beginFunction("Text " + getCppName() + "::getVariableString(int columnId) const");
        mc.cpp.beginBlock("switch (columnId)", false);
        for (auto &v : vars)
        {
            if (v.getFlags()[fArray])
                continue;
            if (v.getDataType() == DataType::Blob)
                continue;
            mc.cpp.addLine("case " + std::to_string(v.getId()) + ":");
            mc.cpp.increaseIndent();
            if (v.getDataType() == DataType::Enum)
                mc.cpp.addLine("return to_string(static_cast<int>(" + v.getPrefixedName() + "));");
            else if (v.getType()->isText())
                mc.cpp.addLine("return " + v.getPrefixedName() + ";");
            else
                mc.cpp.addLine("return to_string(" + v.getPrefixedName() + ");");
            mc.cpp.decreaseIndent();
        }
        mc.cpp.addLine("default:");
        mc.cpp.increaseIndent();
        mc.cpp.addLine(R"(return "";)");
        mc.cpp.endBlock(true);
        mc.cpp.addLine(R"(return "";)");
        mc.cpp.endFunction();
    }

    // setVariableString()
    {
        mc.hpp.addLine("virtual void setVariableString(int columnId, const Text &text) override;");

        mc.cpp.beginFunction("void " + getCppName() + "::setVariableString(int columnId, const Text &text)");
        mc.cpp.beginBlock("switch (columnId)", false);
        for (auto &v : vars)
        {
            if (v.isFk())
                continue;
            mc.cpp.addLine("case " + std::to_string(v.getId()) + ":");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("this->" + v.printSet() + ";");
            mc.cpp.addLine("break;");
            mc.cpp.decreaseIndent();
        }
        mc.cpp.addLine("default:");
        mc.cpp.increaseIndent();
        mc.cpp.addLine("break;");
        mc.cpp.endBlock(true);
        mc.cpp.endFunction();
    }

    // setVariableString() -> IObjectBase
    if (hasFks)
    {
        mc.hpp.addLine("virtual void setVariableString(int columnId, " + iObject + " *ptr) override;");

        mc.cpp.beginFunction("void " + getCppName() + "::setVariableString(int columnId, " + iObject + " *ptr)");
        mc.cpp.beginBlock("switch (columnId)", false);
        for (auto &v : vars)
        {
            if (!v.isFk() || v.hasFlags({ fArray }))
                continue;
            mc.cpp.addLine("case " + std::to_string(v.getId()) + ":");
            mc.cpp.increaseIndent();
            mc.cpp.addLine(v.printSetPtr() + ";");
            for (auto &d : v.getSlaveVariables())
                mc.cpp.addLine(d->getName() + ".clear();");
            mc.cpp.addLine("break;");
            mc.cpp.decreaseIndent();
        }
        mc.cpp.addLine("default:");
        mc.cpp.increaseIndent();
        mc.cpp.addLine("break;");
        mc.cpp.endBlock(true);
        mc.cpp.endFunction();
    }

    // getVariable()
    if (hasFks)
    {
        mc.hpp.addLine("virtual " + iObject + " *getVariable(int columnId) const override;");

        mc.cpp.beginFunction(iObject + " *" + getCppName() + "::getVariable(int columnId) const");
        mc.cpp.beginBlock("switch (columnId)", false);
        for (auto &v : vars)
        {
            if (!v.isFk() || v.hasFlags({ fArray }))
                continue;
            mc.cpp.addLine("case " + std::to_string(v.getId()) + ":");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return " + v.getName() + ".ptr;");
            mc.cpp.decreaseIndent();
        }
        mc.cpp.addLine("default:");
        mc.cpp.increaseIndent();
        mc.cpp.addLine("return nullptr;");
        mc.cpp.endBlock(true);
        mc.cpp.endFunction();
    }

    // getVariableType()
    if (hasFks)
    {
        mc.hpp.addLine("virtual " + objectType + " getVariableType(int columnId) const override;");

        mc.cpp.beginFunction("" + objectType + " " + getCppName() + "::getVariableType(int columnId) const");
        mc.cpp.beginBlock("switch (columnId)", false);
        for (auto &v : vars)
        {
            if (!v.isFk())
                continue;
            mc.cpp.addLine("case " + std::to_string(v.getId()) + ":");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return " + objectType + "::" + v.getType()->getCppName() + ";");
            mc.cpp.decreaseIndent();
        }
        mc.cpp.addLine("default:");
        mc.cpp.increaseIndent();
        mc.cpp.addLine("return " + objectType + "::None;");
        mc.cpp.endBlock(true);
        mc.cpp.endFunction();
    }

    // printTree()
    if (!vars_container.empty() || !vars_inline.empty())
    {
        mc.hpp.addLine("virtual Ptr<TreeItem> printTree() const override;");

        mc.cpp.beginFunction("Ptr<TreeItem> " + getCppName() + "::printTree() const");
        mc.cpp.addLine("auto item = createTreeItem();");
        mc.cpp.addLine();
        mc.cpp.addLine("Ptr<TreeItem> root;");
        mc.cpp.addLine("Ptr<TreeItem> tmp;");
        if (!vars_inline.empty())
        {
            mc.cpp.addLine("Ptr<TreeItem> inline_var;");
            mc.cpp.addLine();
            mc.cpp.addLine("inline_var = std::make_shared<TreeItem>();");
            mc.cpp.addLine("inline_var->name = \"Inline variables\";");
            mc.cpp.addLine("inline_var->type = " + objectType + "::InlineVariables;");
            mc.cpp.addLine("inline_var->parent = item.get();");
            mc.cpp.addLine("item->children.push_back(inline_var);");
            for (auto &v : vars_inline)
            {
                mc.cpp.emptyLines(1);
                if (v.hasFlags({ fArray }))
                {
                    mc.cpp.addLine("root = std::make_shared<TreeItem>();");
                    mc.cpp.addLine("root->name = \"" + v.getName() + "\";");
                    mc.cpp.addLine("root->type = " + objectType + "::" + v.getType()->getCppName() + ";");
                    mc.cpp.addLine("root->parent = inline_var.get();");
                    mc.cpp.addLine("root->objectArrayVariable = (void*)&" + v.getName() + ";");
                    mc.cpp.addLine("inline_var->children.push_back(root);");

                    mc.cpp.beginBlock("for (auto &v : " + v.getName() + ")");
                    mc.cpp.addLine("auto root2 = std::make_shared<TreeItem>();");
                    mc.cpp.addLine("root2->name = v->getName();");
                    mc.cpp.addLine("root2->defaultName = v->" + v.getArrayKey()->getName() + ";");
                    mc.cpp.addLine("root2->type = " + objectType + "::" + v.getType()->getCppName() + ";");
                    mc.cpp.addLine("root2->object = v.get();");
                    mc.cpp.addLine("root2->parent = root.get();");
                    mc.cpp.addLine("root->children.push_back(root2);");
                    mc.cpp.endBlock();
                }
                else
                {
                    mc.cpp.addLine("root = std::make_shared<TreeItem>();");
                    mc.cpp.addLine("root->defaultName = \"" + v.getName() + "\";");
                    mc.cpp.addLine("root->type = " + objectType + "::" + v.getType()->getCppName() + ";");
                    mc.cpp.addLine("root->object = " + v.getName() + ".get();");
                    mc.cpp.addLine("root->inlineVariable = (void*)&" + v.getName() + ";");
                    mc.cpp.addLine("root->parent = inline_var.get();");
                    mc.cpp.addLine("inline_var->children.push_back(root);");
                }
            }
        }
        if (!vars_container.empty())
        {
            if (!subtreeItem.empty())
            {
                mc.cpp.emptyLines(1);
                mc.cpp.addLine("auto subtree_item = std::make_shared<TreeItem>();");
                mc.cpp.addLine("subtree_item->parent = item.get();");
                mc.cpp.addLine("subtree_item->name = \"" + subtreeItem + "\";");
                mc.cpp.addLine("item->children.push_back(subtree_item);");
                mc.cpp.addLine("std::swap(item, subtree_item);");
            }
            for (auto &v : vars_container)
            {
                mc.cpp.emptyLines(1);
                mc.cpp.addLine("root = std::make_shared<TreeItem>();");
                mc.cpp.addLine("root->name = \"" + splitWords(v.getNameWithCaptitalLetter()) + "\";");
                mc.cpp.addLine("root->type = " + objectType + "::" + v.getType()->getCppName() + ";");
                mc.cpp.addLine("root->parent = item.get();");
                mc.cpp.addLine("for (auto &v : " + v.getName() + ")");
                mc.cpp.beginBlock();
                mc.cpp.addLine("root->children.push_back(tmp = v->printTree());");
                mc.cpp.addLine("tmp->parent = root.get();");
                if (v.hasFlags({ fReadOnly }))
                {
                    mc.cpp.addLine("tmp->flags[fReadOnly] = true;");
                    mc.cpp.addLine("tmp->parent->flags[fReadOnly] = true;");
                }
                if (v.hasFlags({ fNoChildren }))
                {
                    mc.cpp.addLine("tmp->flags[fNoChildren] = true;");
                }
                if (v.hasFlags({ fObjectName }))
                {
                    mc.cpp.addLine("tmp->name = to_string(v->" + v.getObjectName() + ");");
                }
                mc.cpp.endBlock();
                mc.cpp.addLine("item->children.push_back(root);");
            }
            if (!subtreeItem.empty())
            {
                mc.cpp.emptyLines(1);
                mc.cpp.addLine("std::swap(item, subtree_item);");
            }
        }
        mc.cpp.emptyLines(1);
        mc.cpp.addLine("return item;");
        mc.cpp.endFunction();
    }

    // getName()
    {
        mc.hpp.addLine("virtual Text getName() const override;");

        mc.cpp.beginFunction("Text " + getCppName() + "::getName() const");
        mc.cpp.addLine("Text s;");

        std::string return_add;
        auto checkReturn = [&]
        {
            mc.cpp.addLine("if (!s.empty())");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("return s" + return_add + ";");
            mc.cpp.decreaseIndent();
        };
        auto printTextColumn = [&](const auto &v)
        {
            if (v.getName().empty())
                return;
            if (v.getDataType() == DataType::Text)
                mc.cpp.addLine("s = " + v.getName() + ";");
            else
                mc.cpp.addLine("s = to_string(" + v.getName() + ");");
            checkReturn();
        };

        bool end_printed = false;
        for (auto &nameType : namesOrder)
        {
            switch (nameType)
            {
            case ObjectName::Custom:
            {
                if (!objectName.empty())
                {
                    mc.cpp.addLine("s = " + objectName + ";");
                    checkReturn();
                }
                break;
            }
            case ObjectName::Name:
                printTextColumn(getNameVariable());
                break;
            case ObjectName::Text:
                printTextColumn(getTextVariable());
                break;
            case ObjectName::Parent:
                if (flags[fProxy])
                {
                    mc.cpp.addLine("s = to_string(" + getChildVariable().getName() + ");");
                    checkReturn();
                }
                break;
            case ObjectName::None:
                mc.cpp.addLine("return " + iObject + "::getName()" + return_add + ";");
                end_printed = true;
                break;
            default:
                assert(false);
                break;
            }
        }
        if (!end_printed)
            mc.cpp.addLine("return " + iObject + "::getName()" + return_add + ";");
        mc.cpp.endFunction();
    }

    // getClass()
    {
        mc.hpp.addLine("virtual const Class &getClass() const override;");

        mc.cpp.beginFunction("const Class &" + getCppName() + "::getClass() const");
        mc.cpp.addLine("return schema->getClass(\"" + getCppName() + "\");");
        mc.cpp.endFunction();
    }

    // getOrderedObjectMap()
    if (hasFks)
    {
        mc.hpp.emptyLines(1);
        mc.hpp.addLine("virtual std::tuple<bool, OrderedObjectMap> getOrderedObjectMap(int columnId, Storage *storage = nullptr) const override;");

        mc.cpp.beginFunction("std::tuple<bool, OrderedObjectMap> " + getCppName() + "::getOrderedObjectMap(int columnId, Storage *storage) const");
        mc.cpp.addLine("OrderedObjectMap m;");
        mc.cpp.beginBlock("switch (columnId)", false);
        std::string fail = "return std::make_tuple(false, m);";
        for (auto &v : vars)
        {
            if (!v.isFk())
                continue;
            mc.cpp.addLine("case " + std::to_string(v.getId()) + ":");
            mc.cpp.increaseIndent();
            if (v.hasFlags({ fGetOrderedObjectMap }))
            {
                mc.cpp.addLine("return std::make_tuple(true, " + v.getGetOrderedObjectMap() + ");");
            }
            else if (v.getType()->getCppName() == String)
            {
                mc.cpp.addLine("if (!storage)");
                mc.cpp.increaseIndent();
                mc.cpp.addLine(fail);
                mc.cpp.decreaseIndent();
                mc.cpp.addLine("return std::make_tuple(true, storage->strings.getOrderedObjectMap([](const String *s)");
                mc.cpp.addLine("{");
                mc.cpp.increaseIndent();
                auto type = getCppName();
                if (!v.getEnumTypeName().empty())
                    type = v.getEnumTypeName();
                mc.cpp.addLine("bool r = s->object == " + objectType + "::" + type + ";");
                mc.cpp.addLine("r |= s->object == " + objectType + "::Any;");
                mc.cpp.addLine("return r;");
                mc.cpp.decreaseIndent();
                mc.cpp.addLine("}));");
            }
            else
            {
                mc.cpp.addLine("if (!storage)");
                mc.cpp.increaseIndent();
                mc.cpp.addLine(fail);
                mc.cpp.decreaseIndent();
                mc.cpp.addLine("return std::make_tuple(true, storage->" + v.getType()->getCppArrayVariableName() + ".getOrderedObjectMap());");
            }
            mc.cpp.decreaseIndent();
        }
        mc.cpp.addLine("default:");
        mc.cpp.increaseIndent();
        mc.cpp.addLine(fail);
        mc.cpp.endBlock(true);
        mc.cpp.endFunction();
    }

    // getOrderedObjectMap() -> getChildOrderedObjectMap
    {
        if (!hasFks)
            mc.hpp.emptyLines(1);
        for (auto &v : vars_container)
        {
            if (!v.getType()->hasFlags({ fProxy }))
                break;

            mc.hpp.addLine("OrderedObjectMap get" + v.getNameWithCaptitalLetter() +  "() const;");

            auto cv = ((Class *)v.getType())->getChildVariable();
            mc.cpp.beginFunction("OrderedObjectMap " + getCppName() + "::get" + v.getNameWithCaptitalLetter() + "() const");
            mc.cpp.addLine("OrderedObjectMap m;");
            mc.cpp.addLine("for (auto &v : " + v.getName() + ")");
            mc.cpp.increaseIndent();
            mc.cpp.addLine("m.insert({ v->" + cv.getName() + "->getName(), v->" + cv.getName() + ".get() });");
            mc.cpp.decreaseIndent();
            mc.cpp.addLine("return m;");
            mc.cpp.endFunction();
        }
    }

    // operator==()
    {
        mc.hpp.emptyLines(1);
        mc.hpp.addLine("bool operator==(const " + getCppName() + " &rhs) const;");

        mc.cpp.beginFunction("bool " + getCppName() + "::operator==(const " + getCppName() + " &rhs) const");
        mc.cpp.addLine("return");
        mc.cpp.increaseIndent();
        for (auto &v : vars)
        {
            if (v.getPrefixedName() != "id")
            {
                mc.cpp.addLine(v.getPrefixedName() + " == rhs." + v.getPrefixedName() + " &&");
            }
        }
        mc.cpp.addLine("1;");
        mc.cpp.decreaseIndent();
        mc.cpp.endFunction();
    }

    // protected
    if (!vars_container.empty())
    {
        mc.hpp.emptyLines(1);
        mc.hpp.addLineNoSpace("protected:");

        // init children
        for (auto &v : vars_container)
        {
            mc.hpp.addLine("template <class T, class... Args>");
            mc.hpp.addLine("void init" + v.getNameWithCaptitalLetter() + "(Args&&... args);");
            mc.hpp.addLine();

            auto &c = mc.hpp.after();
            c.addLine("template <class T, class... Args>");
            c.beginFunction("void " + getCppName() + "::init" + v.getNameWithCaptitalLetter() + "(Args&&... args)");
            c.addLine("for (auto &v : " + v.getName() + ")");
            c.beginBlock();
            auto vclass = (Class *)v.getType();
            if (vclass->getFlags()[fProxy])
            {
                std::string var_name = vclass->getChild()->getCppVariableName();
                for (auto &v2 : vclass->getVariables())
                {
                    if (vclass->getChild()->getName() == v2.getType()->getName())
                    {
                        var_name = v2.getName();
                        break;
                    }
                }
                c.addLine("auto p = v->" + var_name + ".get();");
            }
            else
                c.addLine("auto p = v.second.get();");
            c.addLine("replace<T>(p, std::forward<Args>(args)...);");
            c.endBlock();
            c.endFunction();
        }
    }

    // private
    mc.hpp.emptyLines(1);
    mc.hpp.addLineNoSpace("private:");

    // copyFrom()
    {
        mc.hpp.addLine("void copyFrom(const " + getCppName() + " &rhs);");

        mc.cpp.beginFunction("void " + getCppName() + "::copyFrom(const " + getCppName() + " &rhs)");
        for (auto &v : vars)
            mc.cpp.addLine(v.getPrefixedName() + " = rhs." + v.getPrefixedName() + ";");
        if (!vars_container.empty())
        {
            mc.cpp.addLine();
            for (auto &v : vars_container)
            {
                mc.cpp.addLine(v.getPrefixedName() + " = rhs." + v.getPrefixedName() + ";");
            }
        }
        mc.cpp.endFunction();
    }

    // private
    mc.hpp.emptyLines(1);
    mc.hpp.addLineNoSpace("private:");

    // friends
    mc.hpp.addLine("friend class " + storageImpl + ";");

    // static functions & data
    mc.hpp.emptyLines(1);
    mc.hpp.addLineNoSpace("public:");

    // type
    mc.hpp.addLine("static const " + objectType + " object_type = " + objectType + "::" + getCppName() + ";");
    mc.hpp.addLine(std::string("static const bool replaceable = ") + (hasFlags({ fReplaceable }) ? "true" : "false") + ";");
    mc.hpp.emptyLines(1);

    // getSql()
    {
        mc.hpp.addLine("static std::string getSql();");

        mc.cpp.beginFunction("std::string " + getCppName() + "::getSql()");
        auto sql = printSql();
        mc.cpp.addLine("std::string sql = R\"sql(");
        mc.cpp.decreaseIndent();
        mc.cpp.addLine(sql);
        mc.cpp.increaseIndent();
        mc.cpp.addLine(")sql\";");
        mc.cpp.addLine("return sql;");
        mc.cpp.endFunction();
    }

    // end class
    mc.hpp.endBlock(true);
    mc.hpp.addLine();
    return mc;
}

ModuleContext Class::printIo() const
{
    ModuleContext mc;
    const auto vars = getVariables();
    const auto vars_container = variables({ fContainer }, false, false);

    mc.hpp.increaseIndent();

    // printLoad()
    {
        mc.hpp.addLine("void _load" + getSqlName() + "();");

        mc.cpp.beginFunction("void " + storageImpl + "::_load" + getSqlName() + "()");
        mc.cpp.addLine("LOG_TRACE(logger, \"Loading " + getSqlName() + "\");");
        mc.cpp.addLine("const std::string query = \"select * from " + getSqlName() + ";\"" + ";");
        mc.cpp.addLine("auto db3 = db->getDb();");
        mc.cpp.addLine("sqlite3_stmt *stmt;");
        mc.cpp.addLine("sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);");
        mc.cpp.addLine("while (sqlite3_step(stmt) == SQLITE_ROW)");
        mc.cpp.beginBlock();
        mc.cpp.addLine("auto v = " + getCppArrayVariableName() + ".create();");
        for (auto &v : vars)
            v.printLoadSqlite3(mc.cpp, "v");
        mc.cpp.addLine(getCppArrayVariableName() + ".insert(v);");
        mc.cpp.endBlock();
        mc.cpp.addLine("sqlite3_finalize(stmt);");
        mc.cpp.endFunction();
    }

    // printLoadPtrs()
    {
        mc.hpp.addLine("void _load" + getSqlName() + "Ptrs();");

        mc.cpp.beginFunction("void " + storageImpl + "::_load" + getSqlName() + "Ptrs()");
        if (hasFks)
        {
            mc.cpp.addLine("for (auto &" + getCppVariableName() + " : " + getCppArrayVariableName() + ")");
            mc.cpp.beginBlock();
            bool prev = false;
            for (auto &v : vars)
            {
                if (!v.isFk())
                    continue;
                std::string var = getCppVariableName();
                std::string name2 = v.getType()->getCppArrayVariableName();
                if (prev)
                    mc.cpp.addLine();
                if (v.hasFlags({ fArray }))
                {
                    auto var_name = var + "->" + v.getName();
                    mc.cpp.beginBlock("for (size_t i = 0; i < " + var_name + ".size(); ++i)");
                    mc.cpp.addLine("auto &v = " + var_name + "[i]" + ";");
                    mc.cpp.addLine("auto " + v.getName() + " = " + name2 + ".find(v" + idAccess + ");");
                    mc.cpp.beginBlock("if (" + v.getName() + " != " + name2 + ".end())");
                    mc.cpp.addLine("v = *" + v.getName() + ";");
                    mc.cpp.endBlock();
                    /*mc.cpp.beginBlock("else");
                    mc.cpp.addLine("v = add" + v.getType()->getCppName() + "();");
                    for (auto &iv : v.getInitialValues())
                    {
                        auto &iv_var = iv.first;
                        std::string enum_name;
                        if (iv_var.getType()->getCppName() == objectType)
                            enum_name = objectType + "::";
                        mc.cpp.addLine("v->" + iv.first.getName() + " = " + enum_name + iv.second + ";");
                    }
                    mc.cpp.endBlock();*/
                    mc.cpp.addLine(var_name + ".add_key(v->" + v.getArrayKey()->getName() + ", i)" + ";");
                    mc.cpp.endBlock();
                }
                else
                {
                    mc.cpp.addLine("auto " + v.getName() + " = " + name2 + ".find(" + var + "->" + v.getName() + idAccess + ");");
                    mc.cpp.beginBlock("if (" + v.getName() + " != " + name2 + ".end())");
                    mc.cpp.addLine(var + "->" + v.getName() + " = *" + v.getName() + ";");
                    mc.cpp.endBlock();
                    /*if (v.hasFlags({ fInline }))
                    {
                        mc.cpp.beginBlock("else");
                        mc.cpp.addLine(var + "->" + v.getName() + " = add" + v.getType()->getCppName() + "();");
                        for (auto &iv : v.getInitialValues())
                        {
                            auto &iv_var = iv.first;
                            std::string enum_name;
                            if (iv_var.getType()->getCppName() == objectType)
                                enum_name = objectType + "::";
                            mc.cpp.addLine(var + "->" + v.getName() + "->" + iv.first.getName() + " = " + enum_name + iv.second + ";");
                        }
                        mc.cpp.endBlock();
                    }*/
                }
                prev = true;
            }
            mc.cpp.endBlock();
        }
        mc.cpp.endFunction();
    }

    // printLoadArrays()
    {
        mc.hpp.addLine("void _load" + getSqlName() + "Arrays();");

        mc.cpp.beginFunction("void " + storageImpl + "::_load" + getSqlName() + "Arrays()");
        if (!vars_container.empty())
        {
            mc.cpp.beginBlock("for (auto &" + getCppVariableName() + " : " + getCppArrayVariableName() + ")");
            for (auto &v : vars_container)
            {
                auto t = (Class *)v.getType();
                mc.cpp.addLine("for (auto &" + t->getCppVariableName() + " : " + t->getCppArrayVariableName() + ")");
                mc.cpp.increaseIndent();
                std::string var_name = getCppVariableName();
                for (auto &v2 : t->getVariables())
                {
                    if (this->getName() == v2.getType()->getName())
                    {
                        var_name = v2.getName();
                        break;
                    }
                }
                mc.cpp.addLine(
                    "if (" + getCppVariableName() + "->id" + " == " +
                    t->getCppVariableName() + "->" + var_name + idAccess + ")");
                mc.cpp.increaseIndent();
                mc.cpp.addLine(
                    getCppVariableName() + "->" + v.getName() + containerAccess +
                    "insert(" + t->getCppVariableName() + ");");
                mc.cpp.decreaseIndent();
                mc.cpp.decreaseIndent();
            }
            mc.cpp.endBlock();
        }
        mc.cpp.endFunction();
    }

    // printSave()
    {
        mc.hpp.addLine("void _save" + getSqlName() + "() const;");

        mc.cpp.beginFunction("void " + storageImpl + "::_save" + getSqlName() + "() const");
        mc.cpp.addLine("db->execute(\"BEGIN;\");");
        mc.cpp.addLine("db->execute(\"delete from " + getSqlName() + ";\");");
        mc.cpp.addNoNewLine("const std::string query = \"insert into " + getSqlName() + " values (");
        for (int i = 0; i < vars.size(); i++)
            mc.cpp.addText("?, ");
        mc.cpp.trimEnd(2);
        mc.cpp.addText(");\";");
        mc.cpp.addLine("auto db3 = db->getDb();");
        mc.cpp.addLine("sqlite3_stmt *stmt;");
        mc.cpp.addLine("sqlite3_prepare_v2(db3, query.c_str(), query.size() + 1, &stmt, 0);");
        mc.cpp.beginBlock("for (auto &" + getCppVariableName() + " : " + getCppArrayVariableName() + ")");
        mc.cpp.addLine("auto &v = " + getCppVariableName() + (hasIdField ? ".second" : "") + ";");
        for (auto &v : vars)
            v.printSaveSqlite3(mc.cpp, "v");
        mc.cpp.addLine("sqlite3_step(stmt);");
        mc.cpp.addLine("sqlite3_reset(stmt);");
        mc.cpp.endBlock();
        mc.cpp.addLine("sqlite3_finalize(stmt);");
        mc.cpp.addLine("db->execute(\"COMMIT;\");");
        mc.cpp.endFunction();
    }
    
    return mc;
}

ModuleContext Class::printAddDeleteRecordVirtual() const
{
    std::string param;
    std::string param_name;
    if (parent)
    {
        param_name = "parent";
        param = "" + iObject + " *" + param_name + " = nullptr";
    }
    ModuleContext mc;
    mc.hpp.increaseIndent();
    mc.hpp.addLine("virtual " + dataClassPtr + "<" + getCppName() + "> add" + getCppName() + "(" + param + ") = 0;");
    mc.hpp.addLine("virtual void delete" + getCppName() + "(" + iObject + " *object) = 0;");
    mc.hpp.decreaseIndent();
    return mc;
}

ModuleContext Class::printAddDeleteRecord() const
{
    const auto vars = getVariables();
    const auto vars_inline = vars({ fInline });
    
    std::string param_name, param_h, param;

    if (getParent())
    {
        param_name = "parent";
        param_h = "" + iObject + " *" + param_name + " = nullptr";
        param = "" + iObject + " *" + param_name;
    }

    ModuleContext mc;
    mc.hpp.increaseIndent();
    
    // add record
    {
        mc.hpp.addLine("virtual " + dataClassPtr + "<" + getCppName() + "> add" + getCppName() + "(" + param_h + ") override;");

        mc.cpp.beginFunction("" + dataClassPtr + "<" + getCppName() + "> " + storageImpl + "::add" + getCppName() + "(" + param + ")");
        mc.cpp.addLine("auto v = " + getCppArrayVariableName() + ".createAtEnd();");
        /*for (auto &v : vars_inline)
        {
            if (v.hasFlags({ fArray }))
                continue;
            mc.cpp.addLine("v->" + v.getName() + " = " + v.getType()->getCppArrayVariableName() + ".createAtEnd();");
            auto &ivs = v.getInitialValues();
            for (auto &iv : ivs)
            {
                auto &iv_var = iv.first;
                std::string enum_name;
                if (iv_var.getType()->getCppName() == objectType)
                    enum_name = objectType + "::";
                mc.cpp.addLine("v->" + v.getName() + "->" + iv.first.getName() + " = " + enum_name + iv.second + ";");
            }
        }*/
        if (getParent())
        {
            std::string param_name = "parent";
            std::string param_h = "" + iObject + " *" + param_name + " = nullptr";
            std::string param = "" + iObject + " *" + param_name;

            std::string var = parent->getCppVariableName();
            mc.cpp.addLine(parent->getCppName() + " *" + var + " = (" + parent->getCppName() + " *)" + param_name + ";");
            std::string var_name1 = parent->getCppArrayVariableName();
            for (auto &v2 : parent->getVariables(true))
            {
                if (this->getName() == v2.getType()->getName())
                {
                    var_name1 = v2.getName();
                    break;
                }
            }
            mc.cpp.addLine(var + "->" + var_name1 + containerAccess + "insert(v);");
            std::string var_name2 = var;
            for (auto &v2 : getVariables())
            {
                if (parent->getName() == v2.getType()->getName())
                {
                    var_name2 = v2.getName();
                    break;
                }
            }
            mc.cpp.addLine("v->" + var_name2 + " = " + parent->getCppArrayVariableName() + "[" + var + "->id];");
        }
        mc.cpp.addLine("return v;");
        mc.cpp.endFunction();
    }

    // delete record
    {
        mc.hpp.addLine("virtual void delete" + getCppName() + "(" + iObject + " *object) override;");

        mc.cpp.beginFunction("void " + storageImpl + "::delete" + getCppName() + "(" + iObject + " *o)");
        mc.cpp.addLine("auto v = (" + getCppName() + " *)o;");
        for (auto &v : vars_inline)
        {
            if (v.hasFlags({ fArray }))
            {
                mc.cpp.addLine("for (auto &v2 : v->" + v.getName() + ")");
                mc.cpp.increaseIndent();
                mc.cpp.addLine(v.getType()->getCppArrayVariableName() + ".erase(v2" + idAccess + ");");
                mc.cpp.decreaseIndent();
            }
            else
            {
                mc.cpp.addLine(v.getType()->getCppArrayVariableName() + ".erase(v->" + v.getName() + idAccess + ");");
            }
        }
        mc.cpp.addLine(getCppArrayVariableName() + ".erase(v->id);");
        mc.cpp.endFunction();
    }

    return mc;
}

void Class::printVariables(ModuleContext &mc) const
{
    for (auto &v : variables({ fContainer }, true, false))
    {
        if (v.isId())
            continue;
        if (v.getType()->getFlags()[fInline])
        {
            v.getType()->printVariables(mc);
            continue;
        }
        mc.hpp.addLine(v.print() + ";");
    }
}

std::string Class::printSql() const
{
    auto quoted = [](const std::string &s)
    {
        return "\"" + s + "\"";
    };
    auto braced = [](const std::string &s)
    {
        return "(" + s + ")";
    };

    const auto vars = getVariables();
    bool hasPks = false;
    bool hasFks = false;

    std::string s;
    s += "create table " + quoted(getSqlName()) + " (" + "\n";

    // fields
    for (auto &v : vars)
    {
        s += quoted(v.getSqlName()) + " " + dataTypeToSqlite3(v.getDataType());
        auto d = v.getRawDefaultValue();
        if (!d.empty())
        {
            s += " DEFAULT ";
            if (v.getDataType() == DataType::Enum)
            {
                s += "\"" + sqlEnd + " + std::to_string(static_cast<int>(" + d + ")) + " + sqlBegin + "\"";
            }
            else
                s += quoted(d);
        }
        s += ",\n";

        hasPks |= v.getFlags()[fPrimaryKey];
        hasFks |= v.isFk();
    }

    // pks
    if (hasPks)
    {
        s += "PRIMARY KEY ";
        std::string p;
        for (auto &v : vars)
        {
            if (v.getFlags()[fPrimaryKey])
            {
                p += quoted(v.getSqlName()) + ", ";
            }
        }
        p.resize(p.size() - 2);
        s += braced(p) + ",\n";
    }

    // fks
    if (hasFks)
    {
        for (auto &v : vars)
        {
            if (v.isFk())
            {
                s += "FOREIGN KEY " + braced(quoted(v.getSqlName())) + " REFERENCES " +
                    quoted(v.getType()->getCppArrayName()) + " " + braced(quoted("id"));
                s += ",\n";
            }
        }
    }

    s.resize(s.size() - 2);
    s += "\n);";
    return s;
}

void Class::initialize()
{
    for (auto &v : variables)
    {
        if (v.isId())
            hasIdField = true;
        if (v.isFk())
            hasFks = true;
        if (v.getType()->hasFlags({ fInline }))
        {
            auto c = (Class *)v.getType();
            for (auto &v : c->variables)
            {
                if (v.isId())
                    hasIdField = true;
                if (v.isFk())
                    hasFks = true;
            }
        }
        if (v.getType()->hasFlags({ fPrefixed }))
        {
            auto c = (Class *)v.getType();
            for (auto &v2 : c->variables)
                v2.setPrefix(v.getName());
        }
    }
}

Variables Class::getVariables(bool container) const
{
    Variables r;
    auto vars = variables({ fContainer }, !container, false);
    for (auto &v : vars)
    {
        if (v.getType()->hasFlags({ fInline }))
        {
            auto v2 = ((Class *)v.getType())->getVariables();
            r.insert(r.end(), v2.begin(), v2.end());
            continue;
        }
        if (v.getType()->hasFlags({ fPrefixed }))
        {
            auto v2 = ((Class *)v.getType())->getVariables();
            r.insert(r.end(), v2.begin(), v2.end());
            continue;
        }
        r.push_back(v);
    }
    int id = 0;
    for (auto &v : r)
        v.setId(id++);
    return r;
}

ModuleContext Enum::print() const
{
    ModuleContext mc;
    mc.hpp.beginBlock("enum class " + getCppName() + " : EnumType");

    std::map<int, EnumItem> mf;
    std::vector<EnumItem> me;
    for (auto &i : items)
    {
        if (i.id != i.default_id)
            mf[i.id] = i;
        else
            me.push_back(i);
    }
    for (auto &i : mf)
        mc.hpp.addLine(i.second.name + " = " + std::to_string(i.second.id) + ",");
    for (auto &i : me)
        mc.hpp.addLine(i.name + ",");

    mc.hpp.endBlock(true);
    mc.hpp.addLine();
    return mc;
}

ModuleContext Enum::printTableRecord() const
{
    ModuleContext mc;
    mc.cpp.beginBlock("const EnumTextTable<" + getCppName() + "> " + getTableName() + " =");
    for (auto &i : items)
        mc.cpp.addLine("{ " + getCppName() + "::" + i.name + ", \"" + i.name + "\" },");
    mc.cpp.endBlock(true);
    mc.cpp.addLine();
    mc.cpp.beginBlock("EnumExcludeTable<" + getCppName() + "> " + getExcludeTableName() + " =");
    for (auto &i : items)
        if (i.flags[fNotInTable])
            mc.cpp.addLine(getCppName() + "::" + i.name + ",");
    mc.cpp.endBlock(true);
    mc.cpp.addLine();
    return mc;
}

std::string Variable::print() const
{
    std::string s;
    if (flags[fArray])
    {
        s += objectArray + "<" + type->getCppName() + ", " + arrayKey->getType()->getCppName() + "> " + getName();
        return s;
    }
    if (flags[fContainer])
    {
        s += ctableType(type->getCppName()) + " " + getName();
        return s;
    }
    if (isFk())
    {
        s += "" + dataClassPtr + "<" + type->getCppName() + "> " + getName();
    }
    else
    {
        s += type->getCppName() + " " + getName();
        if (getDataType() == DataType::Integer ||
            getDataType() == DataType::Real ||
            getDataType() == DataType::Bool)
            s += " = " + getDefaultValue();
        auto dv = getDefaultValue();
        if (!dv.empty())
        {
            if (getDataType() == DataType::Enum)
            {
                s += " = " + getDefaultValue();
            }
        }
    }
    return s;
}

std::string Variable::printSet() const
{
    std::string s;
    if (isFk())
        s += getPrefixedName() + idAccess + " = std::stoi(text)";
    else
    {
        s += getPrefixedName() + " = ";
        switch (getDataType())
        {
        case DataType::Integer:
            s += "std::stoi(text)";
            break;
        case DataType::Real:
            s += "std::stof(text)";
            break;
        case DataType::Text:
            s += "text";
            break;
        case DataType::Bool:
            s += "to_bool(text)";
            break;
        case DataType::Enum:
            s += "static_cast<" + getType()->getCppName() + ">(std::stoi(text))";
            break;
        case DataType::Blob:
            s += "text";
            break;
        default:
            assert(false);
            break;
        }
    }
    return s;
}

std::string Variable::printSetPtr() const
{
    std::string s;
    if (isFk())
    {
        s += getPrefixedName() + " = ptr";
    }
    return s;
}

std::string Variable::getDefaultValue() const
{
    std::string s;
    switch (getDataType())
    {
    case DataType::Integer:
        s += defaultValue.empty() ? "0" : defaultValue;
        break;
    case DataType::Real:
        s += defaultValue.empty() ? "0.0f" : defaultValue;
        break;
    case DataType::Text:
        s += defaultValue;
        break;
    case DataType::Bool:
        s += defaultValue.empty() ? "false" : defaultValue;
        break;
    case DataType::Blob:
        break;
    case DataType::Enum:
        s += defaultValue.empty() ? "" : defaultValue;
        break;
    case DataType::Complex:
        break;
    default:
        assert(false);
        break;
    }
    return s;
}

void Variable::printLoadSqlite3(Context &ctx, const std::string &var) const
{
    auto t = getDataType();
    if (isFk() && !flags[fArray])
        t = DataType::Integer;
    switch (t)
    {
    case DataType::Bool:
        ctx.addLine(var + "->" + getPrefixedName() + " = !!sqlite3_column_int(stmt, " + std::to_string(id) + ");");
        break;
    case DataType::Integer:
        ctx.addLine(var + "->" + getPrefixedName() + " = sqlite3_column_int(stmt, " + std::to_string(id) + ");");
        break;
    case DataType::Real:
        ctx.addLine(var + "->" + getPrefixedName() + " = (float)sqlite3_column_double(stmt, " + std::to_string(id) + ");");
        break;
    case DataType::Text:
        ctx.addLine(var + "->" + getPrefixedName() + " = sqlite3_column_text(stmt, " + std::to_string(id) + ");");
        break;
    case DataType::ComplexArray:
        ctx.beginBlock();
        ctx.addLine("auto size = sqlite3_column_bytes(stmt, " + std::to_string(id) + ") / sizeof(int);");
        ctx.addLine("auto data = (int *)sqlite3_column_blob(stmt, " + std::to_string(id) + ");");
        ctx.addLine("std::vector<int> ids(data, data + size);");
        ctx.addLine("for (auto &id : ids)");
        ctx.increaseIndent();
        ctx.addLine(var + "->" + getPrefixedName() + ".push_back(id);");
        ctx.decreaseIndent();
        ctx.endBlock();
        break;
    case DataType::Blob:
        ctx.addLine(var + "->" + getPrefixedName() + 
            " = Blob(sqlite3_column_blob(stmt, " + std::to_string(id) + "), sqlite3_column_bytes(stmt, " + std::to_string(id) + "));");
        break;
    case DataType::Enum:
        ctx.addLine(var + "->" + getPrefixedName() + 
            " = static_cast<" + getType()->getCppName() + ">(sqlite3_column_int(stmt, " + std::to_string(id) + "));");
        break;
    default:
        assert(false && "Type not found");
        break;
    }
}

void Variable::printSaveSqlite3(Context &ctx, const std::string &var) const
{
    auto t = getDataType();

    if (isFk() && !flags[fArray])
    {
        ctx.addLine("sqlite3_bind_int(stmt, " + std::to_string(id + 1) + ", " + var + "->" + getPrefixedName() + idAccess + ");");
    }
    else
    {
        switch (t)
        {
        case DataType::Integer:
        case DataType::Bool:
            ctx.addLine("sqlite3_bind_int(stmt, " + std::to_string(id + 1) + ", " + var + "->" + getPrefixedName() + ");");
            break;
        case DataType::Real:
            ctx.addLine("sqlite3_bind_double(stmt, " + std::to_string(id + 1) + ", " + var + "->" + getPrefixedName() + ");");
            break;
        case DataType::Text:
            ctx.addLine("sqlite3_bind_text(stmt, " + std::to_string(id + 1) + ", " + var + "->" + getPrefixedName() +
                ".toString().c_str()" + ", -1, SQLITE_TRANSIENT);");
            break;
        case DataType::Blob:
            ctx.addLine("sqlite3_bind_blob(stmt, " + std::to_string(id + 1) + ", " +
                var + "->" + getPrefixedName() + ".getRawData()" + ", " +
                var + "->" + getPrefixedName() + ".getLength()" +
                ", SQLITE_TRANSIENT);");
            break;
        case DataType::ComplexArray:
            ctx.beginBlock();
            ctx.addLine("std::vector<int> ids;");
            ctx.addLine("for (auto &v : " + var + "->" + getPrefixedName() + ")");
            ctx.increaseIndent();
            ctx.addLine("ids.emplace_back(v.id);");
            ctx.decreaseIndent();
            ctx.addLine("sqlite3_bind_blob(stmt, " + std::to_string(id + 1) + ", " +
                "ids.data(), ids.size() * sizeof(decltype(ids)::value_type), SQLITE_TRANSIENT);");
            ctx.endBlock();
            break;
        case DataType::Enum:
            ctx.addLine("sqlite3_bind_int(stmt, " + std::to_string(id + 1) + ", static_cast<int>(" + var + "->" + getPrefixedName() + "));");
            break;
        default:
            assert(false && "Type not found");
            break;
        }
    }
}
