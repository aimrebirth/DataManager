/* DO NOT EDIT! This is an autogenerated file. */

class StorageImpl : public Storage
{
private:
    Ptr<Database> db;

private:
    void _loadBuildings()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Building> building = std::make_shared<Building>();
            if (cols[0]) building->id = std::stoi(cols[0]);
            if (cols[1]) building->text_id = cols[1];
            if (cols[2]) building->resource = cols[2];
            if (cols[3]) building->name.id = std::stoi(cols[3]);

            Storage *storage = (Storage *)o;
            storage->buildings[building->id] = building;
            return 0;
        };
        db->execute("select * from Buildings;", this, callback);
    }
    void _loadBuildingsPtrs()
    {
        for (auto &building : buildings)
        {
            building.second->name.ptr = strings[building.second->name.id];
        }
    }
    void _loadBuildingsArrays()
    {
    }
    void _saveBuildings()
    {
        if (buildings.empty())
            return;
        std::string query;
        query += "insert or replace into Buildings values\n";
        for (auto &building : buildings)
        {
            query += "(";
            query += "'" + std::to_string(building.second->id) + "',";
            query += "'" + building.second->text_id.string() + "',";
            query += "'" + building.second->resource.string() + "',";
            query += "'" + std::to_string(building.second->name.id) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadClanReputations()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<ClanReputation> clanReputation = std::make_shared<ClanReputation>();
            if (cols[0]) clanReputation->clan.id = std::stoi(cols[0]);
            if (cols[1]) clanReputation->clan2.id = std::stoi(cols[1]);
            if (cols[2]) clanReputation->reputation = std::stof(cols[2]);

            Storage *storage = (Storage *)o;
            storage->clanReputations.push_back(clanReputation);
            return 0;
        };
        db->execute("select * from ClanReputations;", this, callback);
    }
    void _loadClanReputationsPtrs()
    {
        for (auto &clanReputation : clanReputations)
        {
            clanReputation->clan.ptr = clans[clanReputation->clan.id];
            clanReputation->clan2.ptr = clans[clanReputation->clan2.id];
        }
    }
    void _loadClanReputationsArrays()
    {
    }
    void _saveClanReputations()
    {
        if (clanReputations.empty())
            return;
        std::string query;
        query += "insert or replace into ClanReputations values\n";
        for (auto &clanReputation : clanReputations)
        {
            query += "(";
            query += "'" + std::to_string(clanReputation->clan.id) + "',";
            query += "'" + std::to_string(clanReputation->clan2.id) + "',";
            query += "'" + std::to_string(clanReputation->reputation) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadClans()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Clan> clan = std::make_shared<Clan>();
            if (cols[0]) clan->id = std::stoi(cols[0]);
            if (cols[1]) clan->text_id = cols[1];
            if (cols[2]) clan->resource = cols[2];
            if (cols[3]) clan->name.id = std::stoi(cols[3]);

            Storage *storage = (Storage *)o;
            storage->clans[clan->id] = clan;
            return 0;
        };
        db->execute("select * from Clans;", this, callback);
    }
    void _loadClansPtrs()
    {
        for (auto &clan : clans)
        {
            clan.second->name.ptr = strings[clan.second->name.id];
        }
    }
    void _loadClansArrays()
    {
        for (auto &clan : clans)
        {
            for (auto &clanReputation : clanReputations)
                if (clan.first == clanReputation->clan.id)
                    clan.second->reputations.push_back(clanReputation);
        }
    }
    void _saveClans()
    {
        if (clans.empty())
            return;
        std::string query;
        query += "insert or replace into Clans values\n";
        for (auto &clan : clans)
        {
            query += "(";
            query += "'" + std::to_string(clan.second->id) + "',";
            query += "'" + clan.second->text_id.string() + "',";
            query += "'" + clan.second->resource.string() + "',";
            query += "'" + std::to_string(clan.second->name.id) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadConfigurationEquipments()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<ConfigurationEquipment> configurationEquipment = std::make_shared<ConfigurationEquipment>();
            if (cols[0]) configurationEquipment->configuration.id = std::stoi(cols[0]);
            if (cols[1]) configurationEquipment->equipment.id = std::stoi(cols[1]);
            if (cols[2]) configurationEquipment->quantity = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->configurationEquipments.push_back(configurationEquipment);
            return 0;
        };
        db->execute("select * from ConfigurationEquipments;", this, callback);
    }
    void _loadConfigurationEquipmentsPtrs()
    {
        for (auto &configurationEquipment : configurationEquipments)
        {
            configurationEquipment->configuration.ptr = configurations[configurationEquipment->configuration.id];
            configurationEquipment->equipment.ptr = equipments[configurationEquipment->equipment.id];
        }
    }
    void _loadConfigurationEquipmentsArrays()
    {
    }
    void _saveConfigurationEquipments()
    {
        if (configurationEquipments.empty())
            return;
        std::string query;
        query += "insert or replace into ConfigurationEquipments values\n";
        for (auto &configurationEquipment : configurationEquipments)
        {
            query += "(";
            query += "'" + std::to_string(configurationEquipment->configuration.id) + "',";
            query += "'" + std::to_string(configurationEquipment->equipment.id) + "',";
            query += "'" + std::to_string(configurationEquipment->quantity) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadConfigurationGoods()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<ConfigurationGood> configurationGood = std::make_shared<ConfigurationGood>();
            if (cols[0]) configurationGood->configuration.id = std::stoi(cols[0]);
            if (cols[1]) configurationGood->goods.id = std::stoi(cols[1]);
            if (cols[2]) configurationGood->quantity = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->configurationGoods.push_back(configurationGood);
            return 0;
        };
        db->execute("select * from ConfigurationGoods;", this, callback);
    }
    void _loadConfigurationGoodsPtrs()
    {
        for (auto &configurationGood : configurationGoods)
        {
            configurationGood->configuration.ptr = configurations[configurationGood->configuration.id];
            configurationGood->goods.ptr = goods[configurationGood->goods.id];
        }
    }
    void _loadConfigurationGoodsArrays()
    {
    }
    void _saveConfigurationGoods()
    {
        if (configurationGoods.empty())
            return;
        std::string query;
        query += "insert or replace into ConfigurationGoods values\n";
        for (auto &configurationGood : configurationGoods)
        {
            query += "(";
            query += "'" + std::to_string(configurationGood->configuration.id) + "',";
            query += "'" + std::to_string(configurationGood->goods.id) + "',";
            query += "'" + std::to_string(configurationGood->quantity) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadConfigurationProjectiles()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<ConfigurationProjectile> configurationProjectile = std::make_shared<ConfigurationProjectile>();
            if (cols[0]) configurationProjectile->configuration.id = std::stoi(cols[0]);
            if (cols[1]) configurationProjectile->projectile.id = std::stoi(cols[1]);
            if (cols[2]) configurationProjectile->quantity = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->configurationProjectiles.push_back(configurationProjectile);
            return 0;
        };
        db->execute("select * from ConfigurationProjectiles;", this, callback);
    }
    void _loadConfigurationProjectilesPtrs()
    {
        for (auto &configurationProjectile : configurationProjectiles)
        {
            configurationProjectile->configuration.ptr = configurations[configurationProjectile->configuration.id];
            configurationProjectile->projectile.ptr = projectiles[configurationProjectile->projectile.id];
        }
    }
    void _loadConfigurationProjectilesArrays()
    {
    }
    void _saveConfigurationProjectiles()
    {
        if (configurationProjectiles.empty())
            return;
        std::string query;
        query += "insert or replace into ConfigurationProjectiles values\n";
        for (auto &configurationProjectile : configurationProjectiles)
        {
            query += "(";
            query += "'" + std::to_string(configurationProjectile->configuration.id) + "',";
            query += "'" + std::to_string(configurationProjectile->projectile.id) + "',";
            query += "'" + std::to_string(configurationProjectile->quantity) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadConfigurationWeapons()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<ConfigurationWeapon> configurationWeapon = std::make_shared<ConfigurationWeapon>();
            if (cols[0]) configurationWeapon->configuration.id = std::stoi(cols[0]);
            if (cols[1]) configurationWeapon->weapon.id = std::stoi(cols[1]);
            if (cols[2]) configurationWeapon->quantity = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->configurationWeapons.push_back(configurationWeapon);
            return 0;
        };
        db->execute("select * from ConfigurationWeapons;", this, callback);
    }
    void _loadConfigurationWeaponsPtrs()
    {
        for (auto &configurationWeapon : configurationWeapons)
        {
            configurationWeapon->configuration.ptr = configurations[configurationWeapon->configuration.id];
            configurationWeapon->weapon.ptr = weapons[configurationWeapon->weapon.id];
        }
    }
    void _loadConfigurationWeaponsArrays()
    {
    }
    void _saveConfigurationWeapons()
    {
        if (configurationWeapons.empty())
            return;
        std::string query;
        query += "insert or replace into ConfigurationWeapons values\n";
        for (auto &configurationWeapon : configurationWeapons)
        {
            query += "(";
            query += "'" + std::to_string(configurationWeapon->configuration.id) + "',";
            query += "'" + std::to_string(configurationWeapon->weapon.id) + "',";
            query += "'" + std::to_string(configurationWeapon->quantity) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadConfigurations()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Configuration> configuration = std::make_shared<Configuration>();
            if (cols[0]) configuration->id = std::stoi(cols[0]);
            if (cols[1]) configuration->text_id = cols[1];
            if (cols[2]) configuration->name.id = std::stoi(cols[2]);
            if (cols[3]) configuration->glider.id = std::stoi(cols[3]);

            Storage *storage = (Storage *)o;
            storage->configurations[configuration->id] = configuration;
            return 0;
        };
        db->execute("select * from Configurations;", this, callback);
    }
    void _loadConfigurationsPtrs()
    {
        for (auto &configuration : configurations)
        {
            configuration.second->name.ptr = strings[configuration.second->name.id];
            configuration.second->glider.ptr = gliders[configuration.second->glider.id];
        }
    }
    void _loadConfigurationsArrays()
    {
        for (auto &configuration : configurations)
        {
            for (auto &configurationEquipment : configurationEquipments)
                if (configuration.first == configurationEquipment->configuration.id)
                    configuration.second->equipments.push_back(configurationEquipment);
            for (auto &configurationGood : configurationGoods)
                if (configuration.first == configurationGood->configuration.id)
                    configuration.second->goods.push_back(configurationGood);
            for (auto &configurationProjectile : configurationProjectiles)
                if (configuration.first == configurationProjectile->configuration.id)
                    configuration.second->projectiles.push_back(configurationProjectile);
            for (auto &configurationWeapon : configurationWeapons)
                if (configuration.first == configurationWeapon->configuration.id)
                    configuration.second->weapons.push_back(configurationWeapon);
        }
    }
    void _saveConfigurations()
    {
        if (configurations.empty())
            return;
        std::string query;
        query += "insert or replace into Configurations values\n";
        for (auto &configuration : configurations)
        {
            query += "(";
            query += "'" + std::to_string(configuration.second->id) + "',";
            query += "'" + configuration.second->text_id.string() + "',";
            query += "'" + std::to_string(configuration.second->name.id) + "',";
            query += "'" + std::to_string(configuration.second->glider.id) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadCoordinates()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Coordinate> coordinate = std::make_shared<Coordinate>();
            if (cols[0]) coordinate->id = std::stoi(cols[0]);
            if (cols[1]) coordinate->x = std::stof(cols[1]);
            if (cols[2]) coordinate->y = std::stof(cols[2]);
            if (cols[3]) coordinate->z = std::stof(cols[3]);
            if (cols[4]) coordinate->yaw = std::stof(cols[4]);
            if (cols[5]) coordinate->pitch = std::stof(cols[5]);
            if (cols[6]) coordinate->roll = std::stof(cols[6]);

            Storage *storage = (Storage *)o;
            storage->coordinates[coordinate->id] = coordinate;
            return 0;
        };
        db->execute("select * from Coordinates;", this, callback);
    }
    void _loadCoordinatesPtrs()
    {
    }
    void _loadCoordinatesArrays()
    {
    }
    void _saveCoordinates()
    {
        if (coordinates.empty())
            return;
        std::string query;
        query += "insert or replace into Coordinates values\n";
        for (auto &coordinate : coordinates)
        {
            query += "(";
            query += "'" + std::to_string(coordinate.second->id) + "',";
            query += "'" + std::to_string(coordinate.second->x) + "',";
            query += "'" + std::to_string(coordinate.second->y) + "',";
            query += "'" + std::to_string(coordinate.second->z) + "',";
            query += "'" + std::to_string(coordinate.second->yaw) + "',";
            query += "'" + std::to_string(coordinate.second->pitch) + "',";
            query += "'" + std::to_string(coordinate.second->roll) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadEquipments()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Equipment> equipment = std::make_shared<Equipment>();
            if (cols[0]) equipment->id = std::stoi(cols[0]);
            if (cols[1]) equipment->text_id = cols[1];
            if (cols[2]) equipment->resource = cols[2];
            if (cols[3]) equipment->name.id = std::stoi(cols[3]);
            if (cols[4]) equipment->type = std::stoi(cols[4]);
            if (cols[5]) equipment->standard = std::stoi(cols[5]);
            if (cols[6]) equipment->weight = std::stof(cols[6]);
            if (cols[7]) equipment->durability = std::stof(cols[7]);
            if (cols[8]) equipment->power = std::stof(cols[8]);
            if (cols[9]) equipment->value1 = std::stof(cols[9]);
            if (cols[10]) equipment->value2 = std::stof(cols[10]);
            if (cols[11]) equipment->value3 = std::stof(cols[11]);
            if (cols[12]) equipment->manual = std::stoi(cols[12]);
            if (cols[13]) equipment->price = std::stof(cols[13]);
            if (cols[14]) equipment->notrade = std::stoi(cols[14]);

            Storage *storage = (Storage *)o;
            storage->equipments[equipment->id] = equipment;
            return 0;
        };
        db->execute("select * from Equipments;", this, callback);
    }
    void _loadEquipmentsPtrs()
    {
        for (auto &equipment : equipments)
        {
            equipment.second->name.ptr = strings[equipment.second->name.id];
        }
    }
    void _loadEquipmentsArrays()
    {
    }
    void _saveEquipments()
    {
        if (equipments.empty())
            return;
        std::string query;
        query += "insert or replace into Equipments values\n";
        for (auto &equipment : equipments)
        {
            query += "(";
            query += "'" + std::to_string(equipment.second->id) + "',";
            query += "'" + equipment.second->text_id.string() + "',";
            query += "'" + equipment.second->resource.string() + "',";
            query += "'" + std::to_string(equipment.second->name.id) + "',";
            query += "'" + std::to_string(equipment.second->type) + "',";
            query += "'" + std::to_string(equipment.second->standard) + "',";
            query += "'" + std::to_string(equipment.second->weight) + "',";
            query += "'" + std::to_string(equipment.second->durability) + "',";
            query += "'" + std::to_string(equipment.second->power) + "',";
            query += "'" + std::to_string(equipment.second->value1) + "',";
            query += "'" + std::to_string(equipment.second->value2) + "',";
            query += "'" + std::to_string(equipment.second->value3) + "',";
            query += "'" + std::to_string(equipment.second->manual) + "',";
            query += "'" + std::to_string(equipment.second->price) + "',";
            query += "'" + std::to_string(equipment.second->notrade) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadGliders()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Glider> glider = std::make_shared<Glider>();
            if (cols[0]) glider->id = std::stoi(cols[0]);
            if (cols[1]) glider->text_id = cols[1];
            if (cols[2]) glider->resource = cols[2];
            if (cols[3]) glider->name.id = std::stoi(cols[3]);
            if (cols[4]) glider->standard = std::stoi(cols[4]);
            if (cols[5]) glider->weight = std::stof(cols[5]);
            if (cols[6]) glider->maxweight = std::stof(cols[6]);
            if (cols[7]) glider->rotatespeed = std::stof(cols[7]);
            if (cols[8]) glider->armor = std::stof(cols[8]);
            if (cols[9]) glider->price = std::stoi(cols[9]);
            if (cols[10]) glider->restore = std::stof(cols[10]);
            if (cols[11]) glider->power = std::stof(cols[11]);
            if (cols[12]) glider->special = std::stoi(cols[12]);

            Storage *storage = (Storage *)o;
            storage->gliders[glider->id] = glider;
            return 0;
        };
        db->execute("select * from Gliders;", this, callback);
    }
    void _loadGlidersPtrs()
    {
        for (auto &glider : gliders)
        {
            glider.second->name.ptr = strings[glider.second->name.id];
        }
    }
    void _loadGlidersArrays()
    {
    }
    void _saveGliders()
    {
        if (gliders.empty())
            return;
        std::string query;
        query += "insert or replace into Gliders values\n";
        for (auto &glider : gliders)
        {
            query += "(";
            query += "'" + std::to_string(glider.second->id) + "',";
            query += "'" + glider.second->text_id.string() + "',";
            query += "'" + glider.second->resource.string() + "',";
            query += "'" + std::to_string(glider.second->name.id) + "',";
            query += "'" + std::to_string(glider.second->standard) + "',";
            query += "'" + std::to_string(glider.second->weight) + "',";
            query += "'" + std::to_string(glider.second->maxweight) + "',";
            query += "'" + std::to_string(glider.second->rotatespeed) + "',";
            query += "'" + std::to_string(glider.second->armor) + "',";
            query += "'" + std::to_string(glider.second->price) + "',";
            query += "'" + std::to_string(glider.second->restore) + "',";
            query += "'" + std::to_string(glider.second->power) + "',";
            query += "'" + std::to_string(glider.second->special) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadGoods()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Good> good = std::make_shared<Good>();
            if (cols[0]) good->id = std::stoi(cols[0]);
            if (cols[1]) good->text_id = cols[1];
            if (cols[2]) good->resource = cols[2];
            if (cols[3]) good->name.id = std::stoi(cols[3]);
            if (cols[4]) good->price = std::stoi(cols[4]);
            if (cols[5]) good->notrade = std::stoi(cols[5]);
            if (cols[6]) good->weight = std::stof(cols[6]);

            Storage *storage = (Storage *)o;
            storage->goods[good->id] = good;
            return 0;
        };
        db->execute("select * from Goods;", this, callback);
    }
    void _loadGoodsPtrs()
    {
        for (auto &good : goods)
        {
            good.second->name.ptr = strings[good.second->name.id];
        }
    }
    void _loadGoodsArrays()
    {
    }
    void _saveGoods()
    {
        if (goods.empty())
            return;
        std::string query;
        query += "insert or replace into Goods values\n";
        for (auto &good : goods)
        {
            query += "(";
            query += "'" + std::to_string(good.second->id) + "',";
            query += "'" + good.second->text_id.string() + "',";
            query += "'" + good.second->resource.string() + "',";
            query += "'" + std::to_string(good.second->name.id) + "',";
            query += "'" + std::to_string(good.second->price) + "',";
            query += "'" + std::to_string(good.second->notrade) + "',";
            query += "'" + std::to_string(good.second->weight) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadMapBuildingEquipments()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<MapBuildingEquipment> mapBuildingEquipment = std::make_shared<MapBuildingEquipment>();
            if (cols[0]) mapBuildingEquipment->mapBuilding.id = std::stoi(cols[0]);
            if (cols[1]) mapBuildingEquipment->equipment.id = std::stoi(cols[1]);
            if (cols[2]) mapBuildingEquipment->quantity = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->mapBuildingEquipments.push_back(mapBuildingEquipment);
            return 0;
        };
        db->execute("select * from MapBuildingEquipments;", this, callback);
    }
    void _loadMapBuildingEquipmentsPtrs()
    {
        for (auto &mapBuildingEquipment : mapBuildingEquipments)
        {
            mapBuildingEquipment->mapBuilding.ptr = mapBuildings[mapBuildingEquipment->mapBuilding.id];
            mapBuildingEquipment->equipment.ptr = equipments[mapBuildingEquipment->equipment.id];
        }
    }
    void _loadMapBuildingEquipmentsArrays()
    {
    }
    void _saveMapBuildingEquipments()
    {
        if (mapBuildingEquipments.empty())
            return;
        std::string query;
        query += "insert or replace into MapBuildingEquipments values\n";
        for (auto &mapBuildingEquipment : mapBuildingEquipments)
        {
            query += "(";
            query += "'" + std::to_string(mapBuildingEquipment->mapBuilding.id) + "',";
            query += "'" + std::to_string(mapBuildingEquipment->equipment.id) + "',";
            query += "'" + std::to_string(mapBuildingEquipment->quantity) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadMapBuildingGliders()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<MapBuildingGlider> mapBuildingGlider = std::make_shared<MapBuildingGlider>();
            if (cols[0]) mapBuildingGlider->mapBuilding.id = std::stoi(cols[0]);
            if (cols[1]) mapBuildingGlider->glider.id = std::stoi(cols[1]);
            if (cols[2]) mapBuildingGlider->quantity = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->mapBuildingGliders.push_back(mapBuildingGlider);
            return 0;
        };
        db->execute("select * from MapBuildingGliders;", this, callback);
    }
    void _loadMapBuildingGlidersPtrs()
    {
        for (auto &mapBuildingGlider : mapBuildingGliders)
        {
            mapBuildingGlider->mapBuilding.ptr = mapBuildings[mapBuildingGlider->mapBuilding.id];
            mapBuildingGlider->glider.ptr = gliders[mapBuildingGlider->glider.id];
        }
    }
    void _loadMapBuildingGlidersArrays()
    {
    }
    void _saveMapBuildingGliders()
    {
        if (mapBuildingGliders.empty())
            return;
        std::string query;
        query += "insert or replace into MapBuildingGliders values\n";
        for (auto &mapBuildingGlider : mapBuildingGliders)
        {
            query += "(";
            query += "'" + std::to_string(mapBuildingGlider->mapBuilding.id) + "',";
            query += "'" + std::to_string(mapBuildingGlider->glider.id) + "',";
            query += "'" + std::to_string(mapBuildingGlider->quantity) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadMapBuildingGoods()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<MapBuildingGood> mapBuildingGood = std::make_shared<MapBuildingGood>();
            if (cols[0]) mapBuildingGood->mapBuilding.id = std::stoi(cols[0]);
            if (cols[1]) mapBuildingGood->goods.id = std::stoi(cols[1]);
            if (cols[2]) mapBuildingGood->quantity = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->mapBuildingGoods.push_back(mapBuildingGood);
            return 0;
        };
        db->execute("select * from MapBuildingGoods;", this, callback);
    }
    void _loadMapBuildingGoodsPtrs()
    {
        for (auto &mapBuildingGood : mapBuildingGoods)
        {
            mapBuildingGood->mapBuilding.ptr = mapBuildings[mapBuildingGood->mapBuilding.id];
            mapBuildingGood->goods.ptr = goods[mapBuildingGood->goods.id];
        }
    }
    void _loadMapBuildingGoodsArrays()
    {
    }
    void _saveMapBuildingGoods()
    {
        if (mapBuildingGoods.empty())
            return;
        std::string query;
        query += "insert or replace into MapBuildingGoods values\n";
        for (auto &mapBuildingGood : mapBuildingGoods)
        {
            query += "(";
            query += "'" + std::to_string(mapBuildingGood->mapBuilding.id) + "',";
            query += "'" + std::to_string(mapBuildingGood->goods.id) + "',";
            query += "'" + std::to_string(mapBuildingGood->quantity) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadMapBuildingModificators()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<MapBuildingModificator> mapBuildingModificator = std::make_shared<MapBuildingModificator>();
            if (cols[0]) mapBuildingModificator->mapBuilding.id = std::stoi(cols[0]);
            if (cols[1]) mapBuildingModificator->modificator.id = std::stoi(cols[1]);
            if (cols[2]) mapBuildingModificator->quantity = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->mapBuildingModificators.push_back(mapBuildingModificator);
            return 0;
        };
        db->execute("select * from MapBuildingModificators;", this, callback);
    }
    void _loadMapBuildingModificatorsPtrs()
    {
        for (auto &mapBuildingModificator : mapBuildingModificators)
        {
            mapBuildingModificator->mapBuilding.ptr = mapBuildings[mapBuildingModificator->mapBuilding.id];
            mapBuildingModificator->modificator.ptr = modificators[mapBuildingModificator->modificator.id];
        }
    }
    void _loadMapBuildingModificatorsArrays()
    {
    }
    void _saveMapBuildingModificators()
    {
        if (mapBuildingModificators.empty())
            return;
        std::string query;
        query += "insert or replace into MapBuildingModificators values\n";
        for (auto &mapBuildingModificator : mapBuildingModificators)
        {
            query += "(";
            query += "'" + std::to_string(mapBuildingModificator->mapBuilding.id) + "',";
            query += "'" + std::to_string(mapBuildingModificator->modificator.id) + "',";
            query += "'" + std::to_string(mapBuildingModificator->quantity) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadMapBuildingProjectiles()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<MapBuildingProjectile> mapBuildingProjectile = std::make_shared<MapBuildingProjectile>();
            if (cols[0]) mapBuildingProjectile->mapBuilding.id = std::stoi(cols[0]);
            if (cols[1]) mapBuildingProjectile->projectile.id = std::stoi(cols[1]);
            if (cols[2]) mapBuildingProjectile->quantity = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->mapBuildingProjectiles.push_back(mapBuildingProjectile);
            return 0;
        };
        db->execute("select * from MapBuildingProjectiles;", this, callback);
    }
    void _loadMapBuildingProjectilesPtrs()
    {
        for (auto &mapBuildingProjectile : mapBuildingProjectiles)
        {
            mapBuildingProjectile->mapBuilding.ptr = mapBuildings[mapBuildingProjectile->mapBuilding.id];
            mapBuildingProjectile->projectile.ptr = projectiles[mapBuildingProjectile->projectile.id];
        }
    }
    void _loadMapBuildingProjectilesArrays()
    {
    }
    void _saveMapBuildingProjectiles()
    {
        if (mapBuildingProjectiles.empty())
            return;
        std::string query;
        query += "insert or replace into MapBuildingProjectiles values\n";
        for (auto &mapBuildingProjectile : mapBuildingProjectiles)
        {
            query += "(";
            query += "'" + std::to_string(mapBuildingProjectile->mapBuilding.id) + "',";
            query += "'" + std::to_string(mapBuildingProjectile->projectile.id) + "',";
            query += "'" + std::to_string(mapBuildingProjectile->quantity) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadMapBuildingWeapons()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<MapBuildingWeapon> mapBuildingWeapon = std::make_shared<MapBuildingWeapon>();
            if (cols[0]) mapBuildingWeapon->mapBuilding.id = std::stoi(cols[0]);
            if (cols[1]) mapBuildingWeapon->weapon.id = std::stoi(cols[1]);
            if (cols[2]) mapBuildingWeapon->quantity = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->mapBuildingWeapons.push_back(mapBuildingWeapon);
            return 0;
        };
        db->execute("select * from MapBuildingWeapons;", this, callback);
    }
    void _loadMapBuildingWeaponsPtrs()
    {
        for (auto &mapBuildingWeapon : mapBuildingWeapons)
        {
            mapBuildingWeapon->mapBuilding.ptr = mapBuildings[mapBuildingWeapon->mapBuilding.id];
            mapBuildingWeapon->weapon.ptr = weapons[mapBuildingWeapon->weapon.id];
        }
    }
    void _loadMapBuildingWeaponsArrays()
    {
    }
    void _saveMapBuildingWeapons()
    {
        if (mapBuildingWeapons.empty())
            return;
        std::string query;
        query += "insert or replace into MapBuildingWeapons values\n";
        for (auto &mapBuildingWeapon : mapBuildingWeapons)
        {
            query += "(";
            query += "'" + std::to_string(mapBuildingWeapon->mapBuilding.id) + "',";
            query += "'" + std::to_string(mapBuildingWeapon->weapon.id) + "',";
            query += "'" + std::to_string(mapBuildingWeapon->quantity) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadMapBuildings()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<MapBuilding> mapBuilding = std::make_shared<MapBuilding>();
            if (cols[0]) mapBuilding->id = std::stoi(cols[0]);
            if (cols[1]) mapBuilding->text_id = cols[1];
            if (cols[2]) mapBuilding->map.id = std::stoi(cols[2]);
            if (cols[3]) mapBuilding->building.id = std::stoi(cols[3]);
            if (cols[4]) mapBuilding->coordinate.id = std::stoi(cols[4]);

            Storage *storage = (Storage *)o;
            storage->mapBuildings[mapBuilding->id] = mapBuilding;
            return 0;
        };
        db->execute("select * from MapBuildings;", this, callback);
    }
    void _loadMapBuildingsPtrs()
    {
        for (auto &mapBuilding : mapBuildings)
        {
            mapBuilding.second->map.ptr = maps[mapBuilding.second->map.id];
            mapBuilding.second->building.ptr = buildings[mapBuilding.second->building.id];
            mapBuilding.second->coordinate.ptr = coordinates[mapBuilding.second->coordinate.id];
        }
    }
    void _loadMapBuildingsArrays()
    {
        for (auto &mapBuilding : mapBuildings)
        {
            for (auto &mapBuildingEquipment : mapBuildingEquipments)
                if (mapBuilding.first == mapBuildingEquipment->mapBuilding.id)
                    mapBuilding.second->equipments.push_back(mapBuildingEquipment);
            for (auto &mapBuildingGlider : mapBuildingGliders)
                if (mapBuilding.first == mapBuildingGlider->mapBuilding.id)
                    mapBuilding.second->gliders.push_back(mapBuildingGlider);
            for (auto &mapBuildingGood : mapBuildingGoods)
                if (mapBuilding.first == mapBuildingGood->mapBuilding.id)
                    mapBuilding.second->goods.push_back(mapBuildingGood);
            for (auto &mapBuildingModificator : mapBuildingModificators)
                if (mapBuilding.first == mapBuildingModificator->mapBuilding.id)
                    mapBuilding.second->modificators.push_back(mapBuildingModificator);
            for (auto &mapBuildingProjectile : mapBuildingProjectiles)
                if (mapBuilding.first == mapBuildingProjectile->mapBuilding.id)
                    mapBuilding.second->projectiles.push_back(mapBuildingProjectile);
            for (auto &mapBuildingWeapon : mapBuildingWeapons)
                if (mapBuilding.first == mapBuildingWeapon->mapBuilding.id)
                    mapBuilding.second->weapons.push_back(mapBuildingWeapon);
        }
    }
    void _saveMapBuildings()
    {
        if (mapBuildings.empty())
            return;
        std::string query;
        query += "insert or replace into MapBuildings values\n";
        for (auto &mapBuilding : mapBuildings)
        {
            query += "(";
            query += "'" + std::to_string(mapBuilding.second->id) + "',";
            query += "'" + mapBuilding.second->text_id.string() + "',";
            query += "'" + std::to_string(mapBuilding.second->map.id) + "',";
            query += "'" + std::to_string(mapBuilding.second->building.id) + "',";
            query += "'" + std::to_string(mapBuilding.second->coordinate.id) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadMapObjects()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<MapObject> mapObject = std::make_shared<MapObject>();
            if (cols[0]) mapObject->id = std::stoi(cols[0]);
            if (cols[1]) mapObject->map.id = std::stoi(cols[1]);
            if (cols[2]) mapObject->object.id = std::stoi(cols[2]);
            if (cols[3]) mapObject->coordinate.id = std::stoi(cols[3]);

            Storage *storage = (Storage *)o;
            storage->mapObjects[mapObject->id] = mapObject;
            return 0;
        };
        db->execute("select * from MapObjects;", this, callback);
    }
    void _loadMapObjectsPtrs()
    {
        for (auto &mapObject : mapObjects)
        {
            mapObject.second->map.ptr = maps[mapObject.second->map.id];
            mapObject.second->object.ptr = objects[mapObject.second->object.id];
            mapObject.second->coordinate.ptr = coordinates[mapObject.second->coordinate.id];
        }
    }
    void _loadMapObjectsArrays()
    {
    }
    void _saveMapObjects()
    {
        if (mapObjects.empty())
            return;
        std::string query;
        query += "insert or replace into MapObjects values\n";
        for (auto &mapObject : mapObjects)
        {
            query += "(";
            query += "'" + std::to_string(mapObject.second->id) + "',";
            query += "'" + std::to_string(mapObject.second->map.id) + "',";
            query += "'" + std::to_string(mapObject.second->object.id) + "',";
            query += "'" + std::to_string(mapObject.second->coordinate.id) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadMaps()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Map> map = std::make_shared<Map>();
            if (cols[0]) map->id = std::stoi(cols[0]);
            if (cols[1]) map->text_id = cols[1];
            if (cols[2]) map->resource = cols[2];
            if (cols[3]) map->name.id = std::stoi(cols[3]);

            Storage *storage = (Storage *)o;
            storage->maps[map->id] = map;
            return 0;
        };
        db->execute("select * from Maps;", this, callback);
    }
    void _loadMapsPtrs()
    {
        for (auto &map : maps)
        {
            map.second->name.ptr = strings[map.second->name.id];
        }
    }
    void _loadMapsArrays()
    {
    }
    void _saveMaps()
    {
        if (maps.empty())
            return;
        std::string query;
        query += "insert or replace into Maps values\n";
        for (auto &map : maps)
        {
            query += "(";
            query += "'" + std::to_string(map.second->id) + "',";
            query += "'" + map.second->text_id.string() + "',";
            query += "'" + map.second->resource.string() + "',";
            query += "'" + std::to_string(map.second->name.id) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadMechanoidGroups()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<MechanoidGroup> mechanoidGroup = std::make_shared<MechanoidGroup>();
            if (cols[0]) mechanoidGroup->id = std::stoi(cols[0]);
            if (cols[1]) mechanoidGroup->text_id = cols[1];
            if (cols[2]) mechanoidGroup->name.id = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->mechanoidGroups[mechanoidGroup->id] = mechanoidGroup;
            return 0;
        };
        db->execute("select * from MechanoidGroups;", this, callback);
    }
    void _loadMechanoidGroupsPtrs()
    {
        for (auto &mechanoidGroup : mechanoidGroups)
        {
            mechanoidGroup.second->name.ptr = strings[mechanoidGroup.second->name.id];
        }
    }
    void _loadMechanoidGroupsArrays()
    {
    }
    void _saveMechanoidGroups()
    {
        if (mechanoidGroups.empty())
            return;
        std::string query;
        query += "insert or replace into MechanoidGroups values\n";
        for (auto &mechanoidGroup : mechanoidGroups)
        {
            query += "(";
            query += "'" + std::to_string(mechanoidGroup.second->id) + "',";
            query += "'" + mechanoidGroup.second->text_id.string() + "',";
            query += "'" + std::to_string(mechanoidGroup.second->name.id) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadMechanoids()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Mechanoid> mechanoid = std::make_shared<Mechanoid>();
            if (cols[0]) mechanoid->id = std::stoi(cols[0]);
            if (cols[1]) mechanoid->text_id = cols[1];
            if (cols[2]) mechanoid->name = cols[2];
            if (cols[3]) mechanoid->generation = std::stoi(cols[3]);
            if (cols[4]) mechanoid->rating = std::stof(cols[4]);
            if (cols[5]) mechanoid->money = std::stof(cols[5]);
            if (cols[6]) mechanoid->configuration.id = std::stoi(cols[6]);
            if (cols[7]) mechanoid->clan.id = std::stoi(cols[7]);
            if (cols[8]) mechanoid->group.id = std::stoi(cols[8]);
            if (cols[9]) mechanoid->rating_fight = std::stof(cols[9]);
            if (cols[10]) mechanoid->rating_courier = std::stof(cols[10]);
            if (cols[11]) mechanoid->rating_trade = std::stof(cols[11]);
            if (cols[12]) mechanoid->map.id = std::stoi(cols[12]);
            if (cols[13]) mechanoid->map_building.id = std::stoi(cols[13]);
            if (cols[14]) mechanoid->coordinate.id = std::stoi(cols[14]);

            Storage *storage = (Storage *)o;
            storage->mechanoids[mechanoid->id] = mechanoid;
            return 0;
        };
        db->execute("select * from Mechanoids;", this, callback);
    }
    void _loadMechanoidsPtrs()
    {
        for (auto &mechanoid : mechanoids)
        {
            mechanoid.second->configuration.ptr = configurations[mechanoid.second->configuration.id];
            mechanoid.second->clan.ptr = clans[mechanoid.second->clan.id];
            mechanoid.second->group.ptr = mechanoidGroups[mechanoid.second->group.id];
            mechanoid.second->map.ptr = maps[mechanoid.second->map.id];
            mechanoid.second->map_building.ptr = mapBuildings[mechanoid.second->map_building.id];
            mechanoid.second->coordinate.ptr = coordinates[mechanoid.second->coordinate.id];
        }
    }
    void _loadMechanoidsArrays()
    {
    }
    void _saveMechanoids()
    {
        if (mechanoids.empty())
            return;
        std::string query;
        query += "insert or replace into Mechanoids values\n";
        for (auto &mechanoid : mechanoids)
        {
            query += "(";
            query += "'" + std::to_string(mechanoid.second->id) + "',";
            query += "'" + mechanoid.second->text_id.string() + "',";
            query += "'" + mechanoid.second->name.string() + "',";
            query += "'" + std::to_string(mechanoid.second->generation) + "',";
            query += "'" + std::to_string(mechanoid.second->rating) + "',";
            query += "'" + std::to_string(mechanoid.second->money) + "',";
            query += "'" + std::to_string(mechanoid.second->configuration.id) + "',";
            query += "'" + std::to_string(mechanoid.second->clan.id) + "',";
            query += "'" + std::to_string(mechanoid.second->group.id) + "',";
            query += "'" + std::to_string(mechanoid.second->rating_fight) + "',";
            query += "'" + std::to_string(mechanoid.second->rating_courier) + "',";
            query += "'" + std::to_string(mechanoid.second->rating_trade) + "',";
            query += "'" + std::to_string(mechanoid.second->map.id) + "',";
            query += "'" + std::to_string(mechanoid.second->map_building.id) + "',";
            query += "'" + std::to_string(mechanoid.second->coordinate.id) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadModificationClans()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<ModificationClan> modificationClan = std::make_shared<ModificationClan>();
            if (cols[0]) modificationClan->modification.id = std::stoi(cols[0]);
            if (cols[1]) modificationClan->clan.id = std::stoi(cols[1]);

            Storage *storage = (Storage *)o;
            storage->modificationClans.push_back(modificationClan);
            return 0;
        };
        db->execute("select * from ModificationClans;", this, callback);
    }
    void _loadModificationClansPtrs()
    {
        for (auto &modificationClan : modificationClans)
        {
            modificationClan->modification.ptr = modifications[modificationClan->modification.id];
            modificationClan->clan.ptr = clans[modificationClan->clan.id];
        }
    }
    void _loadModificationClansArrays()
    {
    }
    void _saveModificationClans()
    {
        if (modificationClans.empty())
            return;
        std::string query;
        query += "insert or replace into ModificationClans values\n";
        for (auto &modificationClan : modificationClans)
        {
            query += "(";
            query += "'" + std::to_string(modificationClan->modification.id) + "',";
            query += "'" + std::to_string(modificationClan->clan.id) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadModificationMaps()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<ModificationMap> modificationMap = std::make_shared<ModificationMap>();
            if (cols[0]) modificationMap->modification.id = std::stoi(cols[0]);
            if (cols[1]) modificationMap->map.id = std::stoi(cols[1]);

            Storage *storage = (Storage *)o;
            storage->modificationMaps.push_back(modificationMap);
            return 0;
        };
        db->execute("select * from ModificationMaps;", this, callback);
    }
    void _loadModificationMapsPtrs()
    {
        for (auto &modificationMap : modificationMaps)
        {
            modificationMap->modification.ptr = modifications[modificationMap->modification.id];
            modificationMap->map.ptr = maps[modificationMap->map.id];
        }
    }
    void _loadModificationMapsArrays()
    {
    }
    void _saveModificationMaps()
    {
        if (modificationMaps.empty())
            return;
        std::string query;
        query += "insert or replace into ModificationMaps values\n";
        for (auto &modificationMap : modificationMaps)
        {
            query += "(";
            query += "'" + std::to_string(modificationMap->modification.id) + "',";
            query += "'" + std::to_string(modificationMap->map.id) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadModificationMechanoids()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<ModificationMechanoid> modificationMechanoid = std::make_shared<ModificationMechanoid>();
            if (cols[0]) modificationMechanoid->modification.id = std::stoi(cols[0]);
            if (cols[1]) modificationMechanoid->mechanoid.id = std::stoi(cols[1]);

            Storage *storage = (Storage *)o;
            storage->modificationMechanoids.push_back(modificationMechanoid);
            return 0;
        };
        db->execute("select * from ModificationMechanoids;", this, callback);
    }
    void _loadModificationMechanoidsPtrs()
    {
        for (auto &modificationMechanoid : modificationMechanoids)
        {
            modificationMechanoid->modification.ptr = modifications[modificationMechanoid->modification.id];
            modificationMechanoid->mechanoid.ptr = mechanoids[modificationMechanoid->mechanoid.id];
        }
    }
    void _loadModificationMechanoidsArrays()
    {
    }
    void _saveModificationMechanoids()
    {
        if (modificationMechanoids.empty())
            return;
        std::string query;
        query += "insert or replace into ModificationMechanoids values\n";
        for (auto &modificationMechanoid : modificationMechanoids)
        {
            query += "(";
            query += "'" + std::to_string(modificationMechanoid->modification.id) + "',";
            query += "'" + std::to_string(modificationMechanoid->mechanoid.id) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadModifications()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Modification> modification = std::make_shared<Modification>();
            if (cols[0]) modification->id = std::stoi(cols[0]);
            if (cols[1]) modification->name = cols[1];
            if (cols[2]) modification->directory = cols[2];
            if (cols[3]) modification->author = cols[3];
            if (cols[4]) modification->date_created = cols[4];
            if (cols[5]) modification->date_modified = cols[5];
            if (cols[6]) modification->comment = cols[6];
            if (cols[7]) modification->version = std::stof(cols[7]);
            if (cols[8]) modification->script_language = cols[8];
            if (cols[9]) modification->script_main = cols[9];

            Storage *storage = (Storage *)o;
            storage->modifications[modification->id] = modification;
            return 0;
        };
        db->execute("select * from Modifications;", this, callback);
    }
    void _loadModificationsPtrs()
    {
    }
    void _loadModificationsArrays()
    {
        for (auto &modification : modifications)
        {
            for (auto &modificationClan : modificationClans)
                if (modification.first == modificationClan->modification.id)
                    modification.second->clans.push_back(modificationClan);
            for (auto &modificationMap : modificationMaps)
                if (modification.first == modificationMap->modification.id)
                    modification.second->maps.push_back(modificationMap);
            for (auto &modificationMechanoid : modificationMechanoids)
                if (modification.first == modificationMechanoid->modification.id)
                    modification.second->mechanoids.push_back(modificationMechanoid);
        }
    }
    void _saveModifications()
    {
        if (modifications.empty())
            return;
        std::string query;
        query += "insert or replace into Modifications values\n";
        for (auto &modification : modifications)
        {
            query += "(";
            query += "'" + std::to_string(modification.second->id) + "',";
            query += "'" + modification.second->name.string() + "',";
            query += "'" + modification.second->directory.string() + "',";
            query += "'" + modification.second->author.string() + "',";
            query += "'" + modification.second->date_created.string() + "',";
            query += "'" + modification.second->date_modified.string() + "',";
            query += "'" + modification.second->comment.string() + "',";
            query += "'" + std::to_string(modification.second->version) + "',";
            query += "'" + modification.second->script_language.string() + "',";
            query += "'" + modification.second->script_main.string() + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadModificators()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Modificator> modificator = std::make_shared<Modificator>();
            if (cols[0]) modificator->id = std::stoi(cols[0]);
            if (cols[1]) modificator->text_id = cols[1];
            if (cols[2]) modificator->resource = cols[2];
            if (cols[3]) modificator->name = cols[3];
            if (cols[4]) modificator->probability = std::stof(cols[4]);
            if (cols[5]) modificator->price = std::stof(cols[5]);
            if (cols[6]) modificator->k_price = std::stof(cols[6]);
            if (cols[7]) modificator->k_param1 = std::stof(cols[7]);
            if (cols[8]) modificator->k_param2 = std::stof(cols[8]);

            Storage *storage = (Storage *)o;
            storage->modificators[modificator->id] = modificator;
            return 0;
        };
        db->execute("select * from Modificators;", this, callback);
    }
    void _loadModificatorsPtrs()
    {
    }
    void _loadModificatorsArrays()
    {
    }
    void _saveModificators()
    {
        if (modificators.empty())
            return;
        std::string query;
        query += "insert or replace into Modificators values\n";
        for (auto &modificator : modificators)
        {
            query += "(";
            query += "'" + std::to_string(modificator.second->id) + "',";
            query += "'" + modificator.second->text_id.string() + "',";
            query += "'" + modificator.second->resource.string() + "',";
            query += "'" + modificator.second->name.string() + "',";
            query += "'" + std::to_string(modificator.second->probability) + "',";
            query += "'" + std::to_string(modificator.second->price) + "',";
            query += "'" + std::to_string(modificator.second->k_price) + "',";
            query += "'" + std::to_string(modificator.second->k_param1) + "',";
            query += "'" + std::to_string(modificator.second->k_param2) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadObjects()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Object> object = std::make_shared<Object>();
            if (cols[0]) object->id = std::stoi(cols[0]);
            if (cols[1]) object->text_id = cols[1];
            if (cols[2]) object->resource = cols[2];
            if (cols[3]) object->name = cols[3];
            if (cols[4]) object->type = std::stoi(cols[4]);

            Storage *storage = (Storage *)o;
            storage->objects[object->id] = object;
            return 0;
        };
        db->execute("select * from Objects;", this, callback);
    }
    void _loadObjectsPtrs()
    {
    }
    void _loadObjectsArrays()
    {
    }
    void _saveObjects()
    {
        if (objects.empty())
            return;
        std::string query;
        query += "insert or replace into Objects values\n";
        for (auto &object : objects)
        {
            query += "(";
            query += "'" + std::to_string(object.second->id) + "',";
            query += "'" + object.second->text_id.string() + "',";
            query += "'" + object.second->resource.string() + "',";
            query += "'" + object.second->name.string() + "',";
            query += "'" + std::to_string(object.second->type) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadPlayers()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Player> player = std::make_shared<Player>();
            if (cols[0]) player->id = std::stoi(cols[0]);
            if (cols[1]) player->mechanoid.id = std::stoi(cols[1]);

            Storage *storage = (Storage *)o;
            storage->players[player->id] = player;
            return 0;
        };
        db->execute("select * from Players;", this, callback);
    }
    void _loadPlayersPtrs()
    {
        for (auto &player : players)
        {
            player.second->mechanoid.ptr = mechanoids[player.second->mechanoid.id];
        }
    }
    void _loadPlayersArrays()
    {
    }
    void _savePlayers()
    {
        if (players.empty())
            return;
        std::string query;
        query += "insert or replace into Players values\n";
        for (auto &player : players)
        {
            query += "(";
            query += "'" + std::to_string(player.second->id) + "',";
            query += "'" + std::to_string(player.second->mechanoid.id) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadProjectiles()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Projectile> projectile = std::make_shared<Projectile>();
            if (cols[0]) projectile->id = std::stoi(cols[0]);
            if (cols[1]) projectile->text_id = cols[1];
            if (cols[2]) projectile->resource = cols[2];
            if (cols[3]) projectile->name.id = std::stoi(cols[3]);
            if (cols[4]) projectile->type = std::stoi(cols[4]);
            if (cols[5]) projectile->weight = std::stof(cols[5]);
            if (cols[6]) projectile->damage = std::stof(cols[6]);
            if (cols[7]) projectile->speed = std::stof(cols[7]);
            if (cols[8]) projectile->scale = std::stof(cols[8]);
            if (cols[9]) projectile->notrade = std::stoi(cols[9]);

            Storage *storage = (Storage *)o;
            storage->projectiles[projectile->id] = projectile;
            return 0;
        };
        db->execute("select * from Projectiles;", this, callback);
    }
    void _loadProjectilesPtrs()
    {
        for (auto &projectile : projectiles)
        {
            projectile.second->name.ptr = strings[projectile.second->name.id];
        }
    }
    void _loadProjectilesArrays()
    {
    }
    void _saveProjectiles()
    {
        if (projectiles.empty())
            return;
        std::string query;
        query += "insert or replace into Projectiles values\n";
        for (auto &projectile : projectiles)
        {
            query += "(";
            query += "'" + std::to_string(projectile.second->id) + "',";
            query += "'" + projectile.second->text_id.string() + "',";
            query += "'" + projectile.second->resource.string() + "',";
            query += "'" + std::to_string(projectile.second->name.id) + "',";
            query += "'" + std::to_string(projectile.second->type) + "',";
            query += "'" + std::to_string(projectile.second->weight) + "',";
            query += "'" + std::to_string(projectile.second->damage) + "',";
            query += "'" + std::to_string(projectile.second->speed) + "',";
            query += "'" + std::to_string(projectile.second->scale) + "',";
            query += "'" + std::to_string(projectile.second->notrade) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadQuestRewardEquipments()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<QuestRewardEquipment> questRewardEquipment = std::make_shared<QuestRewardEquipment>();
            if (cols[0]) questRewardEquipment->questReward.id = std::stoi(cols[0]);
            if (cols[1]) questRewardEquipment->equipment.id = std::stoi(cols[1]);
            if (cols[2]) questRewardEquipment->quantity = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->questRewardEquipments.push_back(questRewardEquipment);
            return 0;
        };
        db->execute("select * from QuestRewardEquipments;", this, callback);
    }
    void _loadQuestRewardEquipmentsPtrs()
    {
        for (auto &questRewardEquipment : questRewardEquipments)
        {
            questRewardEquipment->questReward.ptr = questRewards[questRewardEquipment->questReward.id];
            questRewardEquipment->equipment.ptr = equipments[questRewardEquipment->equipment.id];
        }
    }
    void _loadQuestRewardEquipmentsArrays()
    {
    }
    void _saveQuestRewardEquipments()
    {
        if (questRewardEquipments.empty())
            return;
        std::string query;
        query += "insert or replace into QuestRewardEquipments values\n";
        for (auto &questRewardEquipment : questRewardEquipments)
        {
            query += "(";
            query += "'" + std::to_string(questRewardEquipment->questReward.id) + "',";
            query += "'" + std::to_string(questRewardEquipment->equipment.id) + "',";
            query += "'" + std::to_string(questRewardEquipment->quantity) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadQuestRewardGliders()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<QuestRewardGlider> questRewardGlider = std::make_shared<QuestRewardGlider>();
            if (cols[0]) questRewardGlider->questReward.id = std::stoi(cols[0]);
            if (cols[1]) questRewardGlider->glider.id = std::stoi(cols[1]);
            if (cols[2]) questRewardGlider->quantity = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->questRewardGliders.push_back(questRewardGlider);
            return 0;
        };
        db->execute("select * from QuestRewardGliders;", this, callback);
    }
    void _loadQuestRewardGlidersPtrs()
    {
        for (auto &questRewardGlider : questRewardGliders)
        {
            questRewardGlider->questReward.ptr = questRewards[questRewardGlider->questReward.id];
            questRewardGlider->glider.ptr = gliders[questRewardGlider->glider.id];
        }
    }
    void _loadQuestRewardGlidersArrays()
    {
    }
    void _saveQuestRewardGliders()
    {
        if (questRewardGliders.empty())
            return;
        std::string query;
        query += "insert or replace into QuestRewardGliders values\n";
        for (auto &questRewardGlider : questRewardGliders)
        {
            query += "(";
            query += "'" + std::to_string(questRewardGlider->questReward.id) + "',";
            query += "'" + std::to_string(questRewardGlider->glider.id) + "',";
            query += "'" + std::to_string(questRewardGlider->quantity) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadQuestRewardGoods()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<QuestRewardGood> questRewardGood = std::make_shared<QuestRewardGood>();
            if (cols[0]) questRewardGood->questReward.id = std::stoi(cols[0]);
            if (cols[1]) questRewardGood->good.id = std::stoi(cols[1]);
            if (cols[2]) questRewardGood->quantity = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->questRewardGoods.push_back(questRewardGood);
            return 0;
        };
        db->execute("select * from QuestRewardGoods;", this, callback);
    }
    void _loadQuestRewardGoodsPtrs()
    {
        for (auto &questRewardGood : questRewardGoods)
        {
            questRewardGood->questReward.ptr = questRewards[questRewardGood->questReward.id];
            questRewardGood->good.ptr = goods[questRewardGood->good.id];
        }
    }
    void _loadQuestRewardGoodsArrays()
    {
    }
    void _saveQuestRewardGoods()
    {
        if (questRewardGoods.empty())
            return;
        std::string query;
        query += "insert or replace into QuestRewardGoods values\n";
        for (auto &questRewardGood : questRewardGoods)
        {
            query += "(";
            query += "'" + std::to_string(questRewardGood->questReward.id) + "',";
            query += "'" + std::to_string(questRewardGood->good.id) + "',";
            query += "'" + std::to_string(questRewardGood->quantity) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadQuestRewardModificators()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<QuestRewardModificator> questRewardModificator = std::make_shared<QuestRewardModificator>();
            if (cols[0]) questRewardModificator->questReward.id = std::stoi(cols[0]);
            if (cols[1]) questRewardModificator->modificator.id = std::stoi(cols[1]);
            if (cols[2]) questRewardModificator->quantity = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->questRewardModificators.push_back(questRewardModificator);
            return 0;
        };
        db->execute("select * from QuestRewardModificators;", this, callback);
    }
    void _loadQuestRewardModificatorsPtrs()
    {
        for (auto &questRewardModificator : questRewardModificators)
        {
            questRewardModificator->questReward.ptr = questRewards[questRewardModificator->questReward.id];
            questRewardModificator->modificator.ptr = modificators[questRewardModificator->modificator.id];
        }
    }
    void _loadQuestRewardModificatorsArrays()
    {
    }
    void _saveQuestRewardModificators()
    {
        if (questRewardModificators.empty())
            return;
        std::string query;
        query += "insert or replace into QuestRewardModificators values\n";
        for (auto &questRewardModificator : questRewardModificators)
        {
            query += "(";
            query += "'" + std::to_string(questRewardModificator->questReward.id) + "',";
            query += "'" + std::to_string(questRewardModificator->modificator.id) + "',";
            query += "'" + std::to_string(questRewardModificator->quantity) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadQuestRewardProjectiles()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<QuestRewardProjectile> questRewardProjectile = std::make_shared<QuestRewardProjectile>();
            if (cols[0]) questRewardProjectile->questReward.id = std::stoi(cols[0]);
            if (cols[1]) questRewardProjectile->projectile.id = std::stoi(cols[1]);
            if (cols[2]) questRewardProjectile->quantity = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->questRewardProjectiles.push_back(questRewardProjectile);
            return 0;
        };
        db->execute("select * from QuestRewardProjectiles;", this, callback);
    }
    void _loadQuestRewardProjectilesPtrs()
    {
        for (auto &questRewardProjectile : questRewardProjectiles)
        {
            questRewardProjectile->questReward.ptr = questRewards[questRewardProjectile->questReward.id];
            questRewardProjectile->projectile.ptr = projectiles[questRewardProjectile->projectile.id];
        }
    }
    void _loadQuestRewardProjectilesArrays()
    {
    }
    void _saveQuestRewardProjectiles()
    {
        if (questRewardProjectiles.empty())
            return;
        std::string query;
        query += "insert or replace into QuestRewardProjectiles values\n";
        for (auto &questRewardProjectile : questRewardProjectiles)
        {
            query += "(";
            query += "'" + std::to_string(questRewardProjectile->questReward.id) + "',";
            query += "'" + std::to_string(questRewardProjectile->projectile.id) + "',";
            query += "'" + std::to_string(questRewardProjectile->quantity) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadQuestRewardReputations()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<QuestRewardReputation> questRewardReputation = std::make_shared<QuestRewardReputation>();
            if (cols[0]) questRewardReputation->questReward.id = std::stoi(cols[0]);
            if (cols[1]) questRewardReputation->clan.id = std::stoi(cols[1]);
            if (cols[2]) questRewardReputation->reputation = std::stof(cols[2]);

            Storage *storage = (Storage *)o;
            storage->questRewardReputations.push_back(questRewardReputation);
            return 0;
        };
        db->execute("select * from QuestRewardReputations;", this, callback);
    }
    void _loadQuestRewardReputationsPtrs()
    {
        for (auto &questRewardReputation : questRewardReputations)
        {
            questRewardReputation->questReward.ptr = questRewards[questRewardReputation->questReward.id];
            questRewardReputation->clan.ptr = clans[questRewardReputation->clan.id];
        }
    }
    void _loadQuestRewardReputationsArrays()
    {
    }
    void _saveQuestRewardReputations()
    {
        if (questRewardReputations.empty())
            return;
        std::string query;
        query += "insert or replace into QuestRewardReputations values\n";
        for (auto &questRewardReputation : questRewardReputations)
        {
            query += "(";
            query += "'" + std::to_string(questRewardReputation->questReward.id) + "',";
            query += "'" + std::to_string(questRewardReputation->clan.id) + "',";
            query += "'" + std::to_string(questRewardReputation->reputation) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadQuestRewardWeapons()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<QuestRewardWeapon> questRewardWeapon = std::make_shared<QuestRewardWeapon>();
            if (cols[0]) questRewardWeapon->questReward.id = std::stoi(cols[0]);
            if (cols[1]) questRewardWeapon->weapon.id = std::stoi(cols[1]);
            if (cols[2]) questRewardWeapon->quantity = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->questRewardWeapons.push_back(questRewardWeapon);
            return 0;
        };
        db->execute("select * from QuestRewardWeapons;", this, callback);
    }
    void _loadQuestRewardWeaponsPtrs()
    {
        for (auto &questRewardWeapon : questRewardWeapons)
        {
            questRewardWeapon->questReward.ptr = questRewards[questRewardWeapon->questReward.id];
            questRewardWeapon->weapon.ptr = weapons[questRewardWeapon->weapon.id];
        }
    }
    void _loadQuestRewardWeaponsArrays()
    {
    }
    void _saveQuestRewardWeapons()
    {
        if (questRewardWeapons.empty())
            return;
        std::string query;
        query += "insert or replace into QuestRewardWeapons values\n";
        for (auto &questRewardWeapon : questRewardWeapons)
        {
            query += "(";
            query += "'" + std::to_string(questRewardWeapon->questReward.id) + "',";
            query += "'" + std::to_string(questRewardWeapon->weapon.id) + "',";
            query += "'" + std::to_string(questRewardWeapon->quantity) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadQuestRewards()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<QuestReward> questReward = std::make_shared<QuestReward>();
            if (cols[0]) questReward->id = std::stoi(cols[0]);
            if (cols[1]) questReward->money = std::stoi(cols[1]);
            if (cols[2]) questReward->rating = std::stof(cols[2]);

            Storage *storage = (Storage *)o;
            storage->questRewards[questReward->id] = questReward;
            return 0;
        };
        db->execute("select * from QuestRewards;", this, callback);
    }
    void _loadQuestRewardsPtrs()
    {
    }
    void _loadQuestRewardsArrays()
    {
        for (auto &questReward : questRewards)
        {
            for (auto &questRewardEquipment : questRewardEquipments)
                if (questReward.first == questRewardEquipment->questReward.id)
                    questReward.second->equipments.push_back(questRewardEquipment);
            for (auto &questRewardGlider : questRewardGliders)
                if (questReward.first == questRewardGlider->questReward.id)
                    questReward.second->gliders.push_back(questRewardGlider);
            for (auto &questRewardGood : questRewardGoods)
                if (questReward.first == questRewardGood->questReward.id)
                    questReward.second->goods.push_back(questRewardGood);
            for (auto &questRewardModificator : questRewardModificators)
                if (questReward.first == questRewardModificator->questReward.id)
                    questReward.second->modificators.push_back(questRewardModificator);
            for (auto &questRewardProjectile : questRewardProjectiles)
                if (questReward.first == questRewardProjectile->questReward.id)
                    questReward.second->projectiles.push_back(questRewardProjectile);
            for (auto &questRewardReputation : questRewardReputations)
                if (questReward.first == questRewardReputation->questReward.id)
                    questReward.second->reputations.push_back(questRewardReputation);
            for (auto &questRewardWeapon : questRewardWeapons)
                if (questReward.first == questRewardWeapon->questReward.id)
                    questReward.second->weapons.push_back(questRewardWeapon);
        }
    }
    void _saveQuestRewards()
    {
        if (questRewards.empty())
            return;
        std::string query;
        query += "insert or replace into QuestRewards values\n";
        for (auto &questReward : questRewards)
        {
            query += "(";
            query += "'" + std::to_string(questReward.second->id) + "',";
            query += "'" + std::to_string(questReward.second->money) + "',";
            query += "'" + std::to_string(questReward.second->rating) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadQuests()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Quest> quest = std::make_shared<Quest>();
            if (cols[0]) quest->id = std::stoi(cols[0]);
            if (cols[1]) quest->text_id = cols[1];
            if (cols[2]) quest->name.id = std::stoi(cols[2]);
            if (cols[3]) quest->title.id = std::stoi(cols[3]);
            if (cols[4]) quest->description.id = std::stoi(cols[4]);
            if (cols[5]) quest->reward.id = std::stoi(cols[5]);
            if (cols[6]) quest->time = std::stoi(cols[6]);

            Storage *storage = (Storage *)o;
            storage->quests[quest->id] = quest;
            return 0;
        };
        db->execute("select * from Quests;", this, callback);
    }
    void _loadQuestsPtrs()
    {
        for (auto &quest : quests)
        {
            quest.second->name.ptr = strings[quest.second->name.id];
            quest.second->title.ptr = strings[quest.second->title.id];
            quest.second->description.ptr = strings[quest.second->description.id];
            quest.second->reward.ptr = questRewards[quest.second->reward.id];
        }
    }
    void _loadQuestsArrays()
    {
    }
    void _saveQuests()
    {
        if (quests.empty())
            return;
        std::string query;
        query += "insert or replace into Quests values\n";
        for (auto &quest : quests)
        {
            query += "(";
            query += "'" + std::to_string(quest.second->id) + "',";
            query += "'" + quest.second->text_id.string() + "',";
            query += "'" + std::to_string(quest.second->name.id) + "',";
            query += "'" + std::to_string(quest.second->title.id) + "',";
            query += "'" + std::to_string(quest.second->description.id) + "',";
            query += "'" + std::to_string(quest.second->reward.id) + "',";
            query += "'" + std::to_string(quest.second->time) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadSaveObjects()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<SaveObject> saveObject = std::make_shared<SaveObject>();
            if (cols[0]) saveObject->save.id = std::stoi(cols[0]);
            if (cols[1]) saveObject->object.id = std::stoi(cols[1]);
            if (cols[2]) saveObject->map.id = std::stoi(cols[2]);
            if (cols[3]) saveObject->coordinate.id = std::stoi(cols[3]);

            Storage *storage = (Storage *)o;
            storage->saveObjects.push_back(saveObject);
            return 0;
        };
        db->execute("select * from SaveObjects;", this, callback);
    }
    void _loadSaveObjectsPtrs()
    {
        for (auto &saveObject : saveObjects)
        {
            saveObject->save.ptr = saves[saveObject->save.id];
            saveObject->object.ptr = objects[saveObject->object.id];
            saveObject->map.ptr = maps[saveObject->map.id];
            saveObject->coordinate.ptr = coordinates[saveObject->coordinate.id];
        }
    }
    void _loadSaveObjectsArrays()
    {
    }
    void _saveSaveObjects()
    {
        if (saveObjects.empty())
            return;
        std::string query;
        query += "insert or replace into SaveObjects values\n";
        for (auto &saveObject : saveObjects)
        {
            query += "(";
            query += "'" + std::to_string(saveObject->save.id) + "',";
            query += "'" + std::to_string(saveObject->object.id) + "',";
            query += "'" + std::to_string(saveObject->map.id) + "',";
            query += "'" + std::to_string(saveObject->coordinate.id) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadSavePlayers()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<SavePlayer> savePlayer = std::make_shared<SavePlayer>();
            if (cols[0]) savePlayer->save.id = std::stoi(cols[0]);
            if (cols[1]) savePlayer->player.id = std::stoi(cols[1]);

            Storage *storage = (Storage *)o;
            storage->savePlayers.push_back(savePlayer);
            return 0;
        };
        db->execute("select * from SavePlayers;", this, callback);
    }
    void _loadSavePlayersPtrs()
    {
        for (auto &savePlayer : savePlayers)
        {
            savePlayer->save.ptr = saves[savePlayer->save.id];
            savePlayer->player.ptr = players[savePlayer->player.id];
        }
    }
    void _loadSavePlayersArrays()
    {
    }
    void _saveSavePlayers()
    {
        if (savePlayers.empty())
            return;
        std::string query;
        query += "insert or replace into SavePlayers values\n";
        for (auto &savePlayer : savePlayers)
        {
            query += "(";
            query += "'" + std::to_string(savePlayer->save.id) + "',";
            query += "'" + std::to_string(savePlayer->player.id) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadSaveQuests()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<SaveQuest> saveQuest = std::make_shared<SaveQuest>();
            if (cols[0]) saveQuest->save.id = std::stoi(cols[0]);
            if (cols[1]) saveQuest->quest.id = std::stoi(cols[1]);
            if (cols[2]) saveQuest->state = std::stoi(cols[2]);

            Storage *storage = (Storage *)o;
            storage->saveQuests.push_back(saveQuest);
            return 0;
        };
        db->execute("select * from SaveQuests;", this, callback);
    }
    void _loadSaveQuestsPtrs()
    {
        for (auto &saveQuest : saveQuests)
        {
            saveQuest->save.ptr = saves[saveQuest->save.id];
            saveQuest->quest.ptr = quests[saveQuest->quest.id];
        }
    }
    void _loadSaveQuestsArrays()
    {
    }
    void _saveSaveQuests()
    {
        if (saveQuests.empty())
            return;
        std::string query;
        query += "insert or replace into SaveQuests values\n";
        for (auto &saveQuest : saveQuests)
        {
            query += "(";
            query += "'" + std::to_string(saveQuest->save.id) + "',";
            query += "'" + std::to_string(saveQuest->quest.id) + "',";
            query += "'" + std::to_string(saveQuest->state) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadSaves()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Save> save = std::make_shared<Save>();
            if (cols[0]) save->id = std::stoi(cols[0]);
            if (cols[1]) save->modification.id = std::stoi(cols[1]);
            if (cols[2]) save->name = cols[2];
            if (cols[3]) save->date = std::stoi(cols[3]);

            Storage *storage = (Storage *)o;
            storage->saves[save->id] = save;
            return 0;
        };
        db->execute("select * from Saves;", this, callback);
    }
    void _loadSavesPtrs()
    {
        for (auto &save : saves)
        {
            save.second->modification.ptr = modifications[save.second->modification.id];
        }
    }
    void _loadSavesArrays()
    {
        for (auto &save : saves)
        {
            for (auto &saveObject : saveObjects)
                if (save.first == saveObject->save.id)
                    save.second->objects.push_back(saveObject);
            for (auto &savePlayer : savePlayers)
                if (save.first == savePlayer->save.id)
                    save.second->players.push_back(savePlayer);
            for (auto &saveQuest : saveQuests)
                if (save.first == saveQuest->save.id)
                    save.second->quests.push_back(saveQuest);
            for (auto &scriptVariable : scriptVariables)
                if (save.first == scriptVariable->save.id)
                    save.second->scriptVariables.push_back(scriptVariable);
        }
    }
    void _saveSaves()
    {
        if (saves.empty())
            return;
        std::string query;
        query += "insert or replace into Saves values\n";
        for (auto &save : saves)
        {
            query += "(";
            query += "'" + std::to_string(save.second->id) + "',";
            query += "'" + std::to_string(save.second->modification.id) + "',";
            query += "'" + save.second->name.string() + "',";
            query += "'" + std::to_string(save.second->date) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadScriptVariables()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<ScriptVariable> scriptVariable = std::make_shared<ScriptVariable>();
            if (cols[0]) scriptVariable->save.id = std::stoi(cols[0]);
            if (cols[1]) scriptVariable->variable = cols[1];
            if (cols[2]) scriptVariable->value = cols[2];

            Storage *storage = (Storage *)o;
            storage->scriptVariables.push_back(scriptVariable);
            return 0;
        };
        db->execute("select * from ScriptVariables;", this, callback);
    }
    void _loadScriptVariablesPtrs()
    {
        for (auto &scriptVariable : scriptVariables)
        {
            scriptVariable->save.ptr = saves[scriptVariable->save.id];
        }
    }
    void _loadScriptVariablesArrays()
    {
    }
    void _saveScriptVariables()
    {
        if (scriptVariables.empty())
            return;
        std::string query;
        query += "insert or replace into ScriptVariables values\n";
        for (auto &scriptVariable : scriptVariables)
        {
            query += "(";
            query += "'" + std::to_string(scriptVariable->save.id) + "',";
            query += "'" + scriptVariable->variable.string() + "',";
            query += "'" + scriptVariable->value.string() + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadStrings()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<String> string = std::make_shared<String>();
            if (cols[0]) string->id = std::stoi(cols[0]);
            if (cols[1]) string->ru = cols[1];
            if (cols[2]) string->en = cols[2];

            Storage *storage = (Storage *)o;
            storage->strings[string->id] = string;
            return 0;
        };
        db->execute("select * from Strings;", this, callback);
    }
    void _loadStringsPtrs()
    {
    }
    void _loadStringsArrays()
    {
    }
    void _saveStrings()
    {
        if (strings.empty())
            return;
        std::string query;
        query += "insert or replace into Strings values\n";
        for (auto &string : strings)
        {
            query += "(";
            query += "'" + std::to_string(string.second->id) + "',";
            query += "'" + string.second->ru.string() + "',";
            query += "'" + string.second->en.string() + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

    void _loadWeapons()
    {
        auto callback = [](void *o, int ncols, char **cols, char **names)
        {
            Ptr<Weapon> weapon = std::make_shared<Weapon>();
            if (cols[0]) weapon->id = std::stoi(cols[0]);
            if (cols[1]) weapon->text_id = cols[1];
            if (cols[2]) weapon->resource = cols[2];
            if (cols[3]) weapon->name.id = std::stoi(cols[3]);
            if (cols[4]) weapon->type = std::stoi(cols[4]);
            if (cols[5]) weapon->standard = std::stoi(cols[5]);
            if (cols[6]) weapon->weight = std::stof(cols[6]);
            if (cols[7]) weapon->power = std::stof(cols[7]);
            if (cols[8]) weapon->firerate = std::stof(cols[8]);
            if (cols[9]) weapon->damage = std::stof(cols[9]);
            if (cols[10]) weapon->price = std::stof(cols[10]);
            if (cols[11]) weapon->projectile.id = std::stoi(cols[11]);

            Storage *storage = (Storage *)o;
            storage->weapons[weapon->id] = weapon;
            return 0;
        };
        db->execute("select * from Weapons;", this, callback);
    }
    void _loadWeaponsPtrs()
    {
        for (auto &weapon : weapons)
        {
            weapon.second->name.ptr = strings[weapon.second->name.id];
            weapon.second->projectile.ptr = projectiles[weapon.second->projectile.id];
        }
    }
    void _loadWeaponsArrays()
    {
    }
    void _saveWeapons()
    {
        if (weapons.empty())
            return;
        std::string query;
        query += "insert or replace into Weapons values\n";
        for (auto &weapon : weapons)
        {
            query += "(";
            query += "'" + std::to_string(weapon.second->id) + "',";
            query += "'" + weapon.second->text_id.string() + "',";
            query += "'" + weapon.second->resource.string() + "',";
            query += "'" + std::to_string(weapon.second->name.id) + "',";
            query += "'" + std::to_string(weapon.second->type) + "',";
            query += "'" + std::to_string(weapon.second->standard) + "',";
            query += "'" + std::to_string(weapon.second->weight) + "',";
            query += "'" + std::to_string(weapon.second->power) + "',";
            query += "'" + std::to_string(weapon.second->firerate) + "',";
            query += "'" + std::to_string(weapon.second->damage) + "',";
            query += "'" + std::to_string(weapon.second->price) + "',";
            query += "'" + std::to_string(weapon.second->projectile.id) + "',";
            query.resize(query.size() - 1);
            query += "),\n";
        }
        query.resize(query.size() - 2);
        query += ";";
        db->execute(query.c_str(), 0, 0);
    }

public:
    StorageImpl(Ptr<Database> db) : db(db) {}

    virtual void clear()
    {
        buildings.clear();
        clanReputations.clear();
        clans.clear();
        configurationEquipments.clear();
        configurationGoods.clear();
        configurationProjectiles.clear();
        configurationWeapons.clear();
        configurations.clear();
        coordinates.clear();
        equipments.clear();
        gliders.clear();
        goods.clear();
        mapBuildingEquipments.clear();
        mapBuildingGliders.clear();
        mapBuildingGoods.clear();
        mapBuildingModificators.clear();
        mapBuildingProjectiles.clear();
        mapBuildingWeapons.clear();
        mapBuildings.clear();
        mapObjects.clear();
        maps.clear();
        mechanoidGroups.clear();
        mechanoids.clear();
        modificationClans.clear();
        modificationMaps.clear();
        modificationMechanoids.clear();
        modifications.clear();
        modificators.clear();
        objects.clear();
        players.clear();
        projectiles.clear();
        questRewardEquipments.clear();
        questRewardGliders.clear();
        questRewardGoods.clear();
        questRewardModificators.clear();
        questRewardProjectiles.clear();
        questRewardReputations.clear();
        questRewardWeapons.clear();
        questRewards.clear();
        quests.clear();
        saveObjects.clear();
        savePlayers.clear();
        saveQuests.clear();
        saves.clear();
        scriptVariables.clear();
        strings.clear();
        weapons.clear();
    }
    virtual void load()
    {
        _loadBuildings();
        _loadClanReputations();
        _loadClans();
        _loadConfigurationEquipments();
        _loadConfigurationGoods();
        _loadConfigurationProjectiles();
        _loadConfigurationWeapons();
        _loadConfigurations();
        _loadCoordinates();
        _loadEquipments();
        _loadGliders();
        _loadGoods();
        _loadMapBuildingEquipments();
        _loadMapBuildingGliders();
        _loadMapBuildingGoods();
        _loadMapBuildingModificators();
        _loadMapBuildingProjectiles();
        _loadMapBuildingWeapons();
        _loadMapBuildings();
        _loadMapObjects();
        _loadMaps();
        _loadMechanoidGroups();
        _loadMechanoids();
        _loadModificationClans();
        _loadModificationMaps();
        _loadModificationMechanoids();
        _loadModifications();
        _loadModificators();
        _loadObjects();
        _loadPlayers();
        _loadProjectiles();
        _loadQuestRewardEquipments();
        _loadQuestRewardGliders();
        _loadQuestRewardGoods();
        _loadQuestRewardModificators();
        _loadQuestRewardProjectiles();
        _loadQuestRewardReputations();
        _loadQuestRewardWeapons();
        _loadQuestRewards();
        _loadQuests();
        _loadSaveObjects();
        _loadSavePlayers();
        _loadSaveQuests();
        _loadSaves();
        _loadScriptVariables();
        _loadStrings();
        _loadWeapons();

        _loadBuildingsPtrs();
        _loadClanReputationsPtrs();
        _loadClansPtrs();
        _loadConfigurationEquipmentsPtrs();
        _loadConfigurationGoodsPtrs();
        _loadConfigurationProjectilesPtrs();
        _loadConfigurationWeaponsPtrs();
        _loadConfigurationsPtrs();
        _loadCoordinatesPtrs();
        _loadEquipmentsPtrs();
        _loadGlidersPtrs();
        _loadGoodsPtrs();
        _loadMapBuildingEquipmentsPtrs();
        _loadMapBuildingGlidersPtrs();
        _loadMapBuildingGoodsPtrs();
        _loadMapBuildingModificatorsPtrs();
        _loadMapBuildingProjectilesPtrs();
        _loadMapBuildingWeaponsPtrs();
        _loadMapBuildingsPtrs();
        _loadMapObjectsPtrs();
        _loadMapsPtrs();
        _loadMechanoidGroupsPtrs();
        _loadMechanoidsPtrs();
        _loadModificationClansPtrs();
        _loadModificationMapsPtrs();
        _loadModificationMechanoidsPtrs();
        _loadModificationsPtrs();
        _loadModificatorsPtrs();
        _loadObjectsPtrs();
        _loadPlayersPtrs();
        _loadProjectilesPtrs();
        _loadQuestRewardEquipmentsPtrs();
        _loadQuestRewardGlidersPtrs();
        _loadQuestRewardGoodsPtrs();
        _loadQuestRewardModificatorsPtrs();
        _loadQuestRewardProjectilesPtrs();
        _loadQuestRewardReputationsPtrs();
        _loadQuestRewardWeaponsPtrs();
        _loadQuestRewardsPtrs();
        _loadQuestsPtrs();
        _loadSaveObjectsPtrs();
        _loadSavePlayersPtrs();
        _loadSaveQuestsPtrs();
        _loadSavesPtrs();
        _loadScriptVariablesPtrs();
        _loadStringsPtrs();
        _loadWeaponsPtrs();

        _loadBuildingsArrays();
        _loadClanReputationsArrays();
        _loadClansArrays();
        _loadConfigurationEquipmentsArrays();
        _loadConfigurationGoodsArrays();
        _loadConfigurationProjectilesArrays();
        _loadConfigurationWeaponsArrays();
        _loadConfigurationsArrays();
        _loadCoordinatesArrays();
        _loadEquipmentsArrays();
        _loadGlidersArrays();
        _loadGoodsArrays();
        _loadMapBuildingEquipmentsArrays();
        _loadMapBuildingGlidersArrays();
        _loadMapBuildingGoodsArrays();
        _loadMapBuildingModificatorsArrays();
        _loadMapBuildingProjectilesArrays();
        _loadMapBuildingWeaponsArrays();
        _loadMapBuildingsArrays();
        _loadMapObjectsArrays();
        _loadMapsArrays();
        _loadMechanoidGroupsArrays();
        _loadMechanoidsArrays();
        _loadModificationClansArrays();
        _loadModificationMapsArrays();
        _loadModificationMechanoidsArrays();
        _loadModificationsArrays();
        _loadModificatorsArrays();
        _loadObjectsArrays();
        _loadPlayersArrays();
        _loadProjectilesArrays();
        _loadQuestRewardEquipmentsArrays();
        _loadQuestRewardGlidersArrays();
        _loadQuestRewardGoodsArrays();
        _loadQuestRewardModificatorsArrays();
        _loadQuestRewardProjectilesArrays();
        _loadQuestRewardReputationsArrays();
        _loadQuestRewardWeaponsArrays();
        _loadQuestRewardsArrays();
        _loadQuestsArrays();
        _loadSaveObjectsArrays();
        _loadSavePlayersArrays();
        _loadSaveQuestsArrays();
        _loadSavesArrays();
        _loadScriptVariablesArrays();
        _loadStringsArrays();
        _loadWeaponsArrays();
    }
    virtual void save()
    {
        _saveStrings();
        _saveQuestRewards();
        _saveConfigurations();
        _saveMaps();
        _saveClans();
        _saveCoordinates();
        _saveModifications();
        _saveProjectiles();
        _saveSaves();
        _saveEquipments();
        _saveGliders();
        _saveGoods();
        _saveWeapons();
        _saveMechanoids();
        _saveModificators();
        _saveObjects();
        _saveBuildings();
        _saveMapBuildings();
        _saveMechanoidGroups();
        _savePlayers();
        _saveQuests();
        _saveClanReputations();
        _saveConfigurationEquipments();
        _saveConfigurationGoods();
        _saveConfigurationProjectiles();
        _saveConfigurationWeapons();
        _saveMapBuildingEquipments();
        _saveMapBuildingGliders();
        _saveMapBuildingGoods();
        _saveMapBuildingModificators();
        _saveMapBuildingProjectiles();
        _saveMapBuildingWeapons();
        _saveMapObjects();
        _saveModificationClans();
        _saveModificationMaps();
        _saveModificationMechanoids();
        _saveQuestRewardEquipments();
        _saveQuestRewardGliders();
        _saveQuestRewardGoods();
        _saveQuestRewardModificators();
        _saveQuestRewardProjectiles();
        _saveQuestRewardReputations();
        _saveQuestRewardWeapons();
        _saveSaveObjects();
        _saveSavePlayers();
        _saveSaveQuests();
        _saveScriptVariables();
    }
};

