/* DO NOT EDIT! This is an autogenerated file. */

#pragma once

#include "../Table.h"
#include "../Types.h"

namespace polygon4
{

namespace detail
{

class Building;
class Clan;
class ClanReputation;
class Configuration;
class ConfigurationEquipment;
class ConfigurationGood;
class ConfigurationProjectile;
class ConfigurationWeapon;
class Equipment;
class Glider;
class Good;
class Group;
class GroupMechanoid;
class Map;
class MapBuilding;
class MapBuildingEquipment;
class MapBuildingGlider;
class MapBuildingGood;
class MapBuildingModificator;
class MapBuildingProjectile;
class MapBuildingWeapon;
class MapGood;
class MapObject;
class Mechanoid;
class MechanoidQuest;
class Modification;
class ModificationMap;
class Modificator;
class Object;
class Player;
class Projectile;
class Quest;
class QuestReward;
class QuestRewardEquipment;
class QuestRewardGlider;
class QuestRewardGood;
class QuestRewardModificator;
class QuestRewardProjectile;
class QuestRewardReputation;
class QuestRewardWeapon;
class ScriptVariable;
class Setting;
class String;
class Table;
class Weapon;

class DLL_EXPORT Building : public IBuilding
{
    // data
public:
    Text text_id;
    Text resource;
    float scale = 1;
    float scale_x = 1;
    float scale_y = 1;
    float scale_z = 1;

    // constructors
public:
    Building();
    Building(const Building &);
    Building &operator=(const Building &);
    Building(Building &&) = default;
    Building &operator=(Building &&) = default;
    virtual ~Building();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Building &rhs) const;

private:
    void copyFrom(const Building &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Building;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT Clan : public IClan
{
    // data
public:
    Text text_id;
    Text resource;
    Ptr<String> name;
    Ptr<String> member_name;
    Ptr<Modification> modification;
    int32_t bonusexp = 0;
    int32_t bonusrepair = 0;
    int32_t bonustrade = 0;
    int32_t helpness = 0;
    float Volatile = 0.0f;
    float noblivion = 0.0f;
    float playereffect = 0.0f;
    int32_t color = 0;

    Ptr<CTable<Mechanoid>> mechanoids;
    Ptr<CTable<ClanReputation>> reputations;

    // constructors
public:
    Clan();
    Clan(const Clan &);
    Clan &operator=(const Clan &);
    Clan(Clan &&) = default;
    Clan &operator=(Clan &&) = default;
    virtual ~Clan();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Clan &rhs) const;

protected:
    template <class T, class... Args>
    void initMechanoids(Args&&... args)
    {
        for (auto &v : *mechanoids)
        {
            auto p = v.second.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initReputations(Args&&... args)
    {
        for (auto &v : *reputations)
        {
            auto p = v.second.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

private:
    void copyFrom(const Clan &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Clan;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT ClanReputation : public IClanReputation
{
    // data
public:
    Ptr<Clan> clan1;
    Ptr<Clan> clan2;
    float reputation = 0.0f;

    // constructors
public:
    ClanReputation();
    ClanReputation(const ClanReputation &);
    ClanReputation &operator=(const ClanReputation &);
    ClanReputation(ClanReputation &&) = default;
    ClanReputation &operator=(ClanReputation &&) = default;
    virtual ~ClanReputation();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const ClanReputation &rhs) const;

private:
    void copyFrom(const ClanReputation &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::ClanReputation;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT Configuration : public IConfiguration
{
    // data
public:
    Text text_id;
    Ptr<String> name;
    Ptr<Glider> glider;

    Ptr<CTable<ConfigurationEquipment>> equipments;
    Ptr<CTable<ConfigurationGood>> goods;
    Ptr<CTable<ConfigurationProjectile>> projectiles;
    Ptr<CTable<ConfigurationWeapon>> weapons;

    // constructors
public:
    Configuration();
    Configuration(const Configuration &);
    Configuration &operator=(const Configuration &);
    Configuration(Configuration &&) = default;
    Configuration &operator=(Configuration &&) = default;
    virtual ~Configuration();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Configuration &rhs) const;

protected:
    template <class T, class... Args>
    void initEquipments(Args&&... args)
    {
        for (auto &v : *equipments)
        {
            auto p = v->configuration.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initGoods(Args&&... args)
    {
        for (auto &v : *goods)
        {
            auto p = v->configuration.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initProjectiles(Args&&... args)
    {
        for (auto &v : *projectiles)
        {
            auto p = v->configuration.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initWeapons(Args&&... args)
    {
        for (auto &v : *weapons)
        {
            auto p = v->configuration.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

private:
    void copyFrom(const Configuration &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Configuration;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT ConfigurationEquipment : public IConfigurationEquipment
{
    // data
public:
    Ptr<Configuration> configuration;
    Ptr<Equipment> equipment;
    int32_t quantity = 0;

    // constructors
public:
    ConfigurationEquipment();
    ConfigurationEquipment(const ConfigurationEquipment &);
    ConfigurationEquipment &operator=(const ConfigurationEquipment &);
    ConfigurationEquipment(ConfigurationEquipment &&) = default;
    ConfigurationEquipment &operator=(ConfigurationEquipment &&) = default;
    virtual ~ConfigurationEquipment();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const ConfigurationEquipment &rhs) const;
    Ptr<Configuration> operator->() const;

private:
    void copyFrom(const ConfigurationEquipment &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::ConfigurationEquipment;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT ConfigurationGood : public IConfigurationGood
{
    // data
public:
    Ptr<Configuration> configuration;
    Ptr<Good> good;
    int32_t quantity = 0;

    // constructors
public:
    ConfigurationGood();
    ConfigurationGood(const ConfigurationGood &);
    ConfigurationGood &operator=(const ConfigurationGood &);
    ConfigurationGood(ConfigurationGood &&) = default;
    ConfigurationGood &operator=(ConfigurationGood &&) = default;
    virtual ~ConfigurationGood();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const ConfigurationGood &rhs) const;
    Ptr<Configuration> operator->() const;

private:
    void copyFrom(const ConfigurationGood &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::ConfigurationGood;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT ConfigurationProjectile : public IConfigurationProjectile
{
    // data
public:
    Ptr<Configuration> configuration;
    Ptr<Projectile> projectile;
    int32_t quantity = 0;

    // constructors
public:
    ConfigurationProjectile();
    ConfigurationProjectile(const ConfigurationProjectile &);
    ConfigurationProjectile &operator=(const ConfigurationProjectile &);
    ConfigurationProjectile(ConfigurationProjectile &&) = default;
    ConfigurationProjectile &operator=(ConfigurationProjectile &&) = default;
    virtual ~ConfigurationProjectile();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const ConfigurationProjectile &rhs) const;
    Ptr<Configuration> operator->() const;

private:
    void copyFrom(const ConfigurationProjectile &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::ConfigurationProjectile;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT ConfigurationWeapon : public IConfigurationWeapon
{
    // data
public:
    Ptr<Configuration> configuration;
    Ptr<Weapon> weapon;
    int32_t quantity = 0;

    // constructors
public:
    ConfigurationWeapon();
    ConfigurationWeapon(const ConfigurationWeapon &);
    ConfigurationWeapon &operator=(const ConfigurationWeapon &);
    ConfigurationWeapon(ConfigurationWeapon &&) = default;
    ConfigurationWeapon &operator=(ConfigurationWeapon &&) = default;
    virtual ~ConfigurationWeapon();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const ConfigurationWeapon &rhs) const;
    Ptr<Configuration> operator->() const;

private:
    void copyFrom(const ConfigurationWeapon &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::ConfigurationWeapon;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT Equipment : public IEquipment
{
    // data
public:
    Text text_id;
    Text resource;
    Ptr<String> name;
    int32_t type = 0;
    int32_t standard = 0;
    float weight = 0.0f;
    float durability = 0.0f;
    float power = 0.0f;
    float value1 = 0.0f;
    float value2 = 0.0f;
    float value3 = 0.0f;
    int32_t manual = 0;
    float price = 0.0f;
    int32_t notrade = 0;

    // constructors
public:
    Equipment();
    Equipment(const Equipment &);
    Equipment &operator=(const Equipment &);
    Equipment(Equipment &&) = default;
    Equipment &operator=(Equipment &&) = default;
    virtual ~Equipment();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Equipment &rhs) const;

private:
    void copyFrom(const Equipment &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Equipment;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT Glider : public IGlider
{
    // data
public:
    Text text_id;
    Text resource;
    Ptr<String> name;
    int32_t standard = 0;
    float weight = 0.0f;
    float maxweight = 0.0f;
    float armor = 0.0f;
    float price = 0.0f;
    float restore = 0.0f;
    float power = 0.0f;
    int32_t special = 0;
    float rotatespeed = 0.0f;
    float resfront = 0.0f;
    float resstop = 0.0f;
    float resside = 0.0f;
    float stabfront = 0.0f;
    float stabside = 0.0f;
    float careen = 0.0f;
    float delta_t = 0.0f;
    float turbulence = 0.0f;

    // constructors
public:
    Glider();
    Glider(const Glider &);
    Glider &operator=(const Glider &);
    Glider(Glider &&) = default;
    Glider &operator=(Glider &&) = default;
    virtual ~Glider();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Glider &rhs) const;

private:
    void copyFrom(const Glider &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Glider;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT Good : public IGood
{
    // data
public:
    Text text_id;
    Text resource;
    Text resource_drop;
    Ptr<String> name;
    float price = 0.0f;
    float weight = 0.0f;
    int32_t notrade = 0;
    int32_t type = 0;

    // constructors
public:
    Good();
    Good(const Good &);
    Good &operator=(const Good &);
    Good(Good &&) = default;
    Good &operator=(Good &&) = default;
    virtual ~Good();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Good &rhs) const;

private:
    void copyFrom(const Good &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Good;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT Group : public IGroup
{
    // data
public:
    Text text_id;
    Ptr<String> name;

    Ptr<CTable<GroupMechanoid>> mechanoids;

    // constructors
public:
    Group();
    Group(const Group &);
    Group &operator=(const Group &);
    Group(Group &&) = default;
    Group &operator=(Group &&) = default;
    virtual ~Group();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Group &rhs) const;

protected:
    template <class T, class... Args>
    void initMechanoids(Args&&... args)
    {
        for (auto &v : *mechanoids)
        {
            auto p = v->group.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

private:
    void copyFrom(const Group &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Group;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT GroupMechanoid : public IGroupMechanoid
{
    // data
public:
    Ptr<Group> group;
    Ptr<Mechanoid> mechanoid;

    // constructors
public:
    GroupMechanoid();
    GroupMechanoid(const GroupMechanoid &);
    GroupMechanoid &operator=(const GroupMechanoid &);
    GroupMechanoid(GroupMechanoid &&) = default;
    GroupMechanoid &operator=(GroupMechanoid &&) = default;
    virtual ~GroupMechanoid();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const GroupMechanoid &rhs) const;
    Ptr<Group> operator->() const;

private:
    void copyFrom(const GroupMechanoid &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::GroupMechanoid;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT Map : public IMap
{
    // data
public:
    Text text_id;
    Text resource;
    Ptr<String> name;
    float h_min = 0.0f;
    float h_max = 0.0f;
    float kx = 0.0f;
    float bx = 0.0f;
    float ky = 0.0f;
    float by = 0.0f;

    Ptr<CTable<MapBuilding>> buildings;
    Ptr<CTable<MapGood>> goods;
    Ptr<CTable<MapObject>> objects;

    // constructors
public:
    Map();
    Map(const Map &);
    Map &operator=(const Map &);
    Map(Map &&) = default;
    Map &operator=(Map &&) = default;
    virtual ~Map();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Map &rhs) const;

protected:
    template <class T, class... Args>
    void initBuildings(Args&&... args)
    {
        for (auto &v : *buildings)
        {
            auto p = v.second.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initGoods(Args&&... args)
    {
        for (auto &v : *goods)
        {
            auto p = v.second.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initObjects(Args&&... args)
    {
        for (auto &v : *objects)
        {
            auto p = v.second.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

private:
    void copyFrom(const Map &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Map;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT MapBuilding : public IMapBuilding
{
    // data
public:
    Text text_id;
    Ptr<String> name;
    Ptr<Map> map;
    Ptr<Building> building;
    float x = 0.0f;
    float y = 0.0f;
    float z = 0.0f;
    float roll = 0.0f;
    float pitch = 0.0f;
    float yaw = 0.0f;
    float scale = 1;
    float scale_x = 1;
    float scale_y = 1;
    float scale_z = 1;
    int32_t interactive = 0;

    Ptr<CTable<MapBuildingEquipment>> equipments;
    Ptr<CTable<MapBuildingGlider>> gliders;
    Ptr<CTable<MapBuildingGood>> goods;
    Ptr<CTable<MapBuildingModificator>> modificators;
    Ptr<CTable<MapBuildingProjectile>> projectiles;
    Ptr<CTable<MapBuildingWeapon>> weapons;

    // constructors
public:
    MapBuilding();
    MapBuilding(const MapBuilding &);
    MapBuilding &operator=(const MapBuilding &);
    MapBuilding(MapBuilding &&) = default;
    MapBuilding &operator=(MapBuilding &&) = default;
    virtual ~MapBuilding();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const MapBuilding &rhs) const;

protected:
    template <class T, class... Args>
    void initEquipments(Args&&... args)
    {
        for (auto &v : *equipments)
        {
            auto p = v->mapBuilding.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initGliders(Args&&... args)
    {
        for (auto &v : *gliders)
        {
            auto p = v->mapBuilding.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initGoods(Args&&... args)
    {
        for (auto &v : *goods)
        {
            auto p = v->mapBuilding.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initModificators(Args&&... args)
    {
        for (auto &v : *modificators)
        {
            auto p = v->mapBuilding.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initProjectiles(Args&&... args)
    {
        for (auto &v : *projectiles)
        {
            auto p = v->mapBuilding.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initWeapons(Args&&... args)
    {
        for (auto &v : *weapons)
        {
            auto p = v->mapBuilding.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

private:
    void copyFrom(const MapBuilding &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::MapBuilding;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT MapBuildingEquipment : public IMapBuildingEquipment
{
    // data
public:
    Ptr<MapBuilding> map_building;
    Ptr<Equipment> equipment;
    int32_t quantity = 0;

    // constructors
public:
    MapBuildingEquipment();
    MapBuildingEquipment(const MapBuildingEquipment &);
    MapBuildingEquipment &operator=(const MapBuildingEquipment &);
    MapBuildingEquipment(MapBuildingEquipment &&) = default;
    MapBuildingEquipment &operator=(MapBuildingEquipment &&) = default;
    virtual ~MapBuildingEquipment();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const MapBuildingEquipment &rhs) const;
    Ptr<MapBuilding> operator->() const;

private:
    void copyFrom(const MapBuildingEquipment &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::MapBuildingEquipment;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT MapBuildingGlider : public IMapBuildingGlider
{
    // data
public:
    Ptr<MapBuilding> map_building;
    Ptr<Glider> glider;
    int32_t quantity = 0;

    // constructors
public:
    MapBuildingGlider();
    MapBuildingGlider(const MapBuildingGlider &);
    MapBuildingGlider &operator=(const MapBuildingGlider &);
    MapBuildingGlider(MapBuildingGlider &&) = default;
    MapBuildingGlider &operator=(MapBuildingGlider &&) = default;
    virtual ~MapBuildingGlider();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const MapBuildingGlider &rhs) const;
    Ptr<MapBuilding> operator->() const;

private:
    void copyFrom(const MapBuildingGlider &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::MapBuildingGlider;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT MapBuildingGood : public IMapBuildingGood
{
    // data
public:
    Ptr<MapBuilding> map_building;
    Ptr<Good> good;
    int32_t quantity = 0;

    // constructors
public:
    MapBuildingGood();
    MapBuildingGood(const MapBuildingGood &);
    MapBuildingGood &operator=(const MapBuildingGood &);
    MapBuildingGood(MapBuildingGood &&) = default;
    MapBuildingGood &operator=(MapBuildingGood &&) = default;
    virtual ~MapBuildingGood();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const MapBuildingGood &rhs) const;
    Ptr<MapBuilding> operator->() const;

private:
    void copyFrom(const MapBuildingGood &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::MapBuildingGood;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT MapBuildingModificator : public IMapBuildingModificator
{
    // data
public:
    Ptr<MapBuilding> map_building;
    Ptr<Modificator> modificator;
    int32_t quantity = 0;

    // constructors
public:
    MapBuildingModificator();
    MapBuildingModificator(const MapBuildingModificator &);
    MapBuildingModificator &operator=(const MapBuildingModificator &);
    MapBuildingModificator(MapBuildingModificator &&) = default;
    MapBuildingModificator &operator=(MapBuildingModificator &&) = default;
    virtual ~MapBuildingModificator();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const MapBuildingModificator &rhs) const;
    Ptr<MapBuilding> operator->() const;

private:
    void copyFrom(const MapBuildingModificator &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::MapBuildingModificator;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT MapBuildingProjectile : public IMapBuildingProjectile
{
    // data
public:
    Ptr<MapBuilding> map_building;
    Ptr<Projectile> projectile;
    int32_t quantity = 0;

    // constructors
public:
    MapBuildingProjectile();
    MapBuildingProjectile(const MapBuildingProjectile &);
    MapBuildingProjectile &operator=(const MapBuildingProjectile &);
    MapBuildingProjectile(MapBuildingProjectile &&) = default;
    MapBuildingProjectile &operator=(MapBuildingProjectile &&) = default;
    virtual ~MapBuildingProjectile();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const MapBuildingProjectile &rhs) const;
    Ptr<MapBuilding> operator->() const;

private:
    void copyFrom(const MapBuildingProjectile &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::MapBuildingProjectile;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT MapBuildingWeapon : public IMapBuildingWeapon
{
    // data
public:
    Ptr<MapBuilding> map_building;
    Ptr<Weapon> weapon;
    int32_t quantity = 0;

    // constructors
public:
    MapBuildingWeapon();
    MapBuildingWeapon(const MapBuildingWeapon &);
    MapBuildingWeapon &operator=(const MapBuildingWeapon &);
    MapBuildingWeapon(MapBuildingWeapon &&) = default;
    MapBuildingWeapon &operator=(MapBuildingWeapon &&) = default;
    virtual ~MapBuildingWeapon();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const MapBuildingWeapon &rhs) const;
    Ptr<MapBuilding> operator->() const;

private:
    void copyFrom(const MapBuildingWeapon &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::MapBuildingWeapon;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT MapGood : public IMapGood
{
    // data
public:
    Text text_id;
    Ptr<Map> map;
    Ptr<Good> good;
    float x = 0.0f;
    float y = 0.0f;
    float z = 0.0f;
    float roll = 0.0f;
    float pitch = 0.0f;
    float yaw = 0.0f;
    float scale = 1;
    float scale_x = 1;
    float scale_y = 1;
    float scale_z = 1;

    // constructors
public:
    MapGood();
    MapGood(const MapGood &);
    MapGood &operator=(const MapGood &);
    MapGood(MapGood &&) = default;
    MapGood &operator=(MapGood &&) = default;
    virtual ~MapGood();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const MapGood &rhs) const;

private:
    void copyFrom(const MapGood &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::MapGood;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT MapObject : public IMapObject
{
    // data
public:
    Text text_id;
    Ptr<Map> map;
    Ptr<Object> object;
    float x = 0.0f;
    float y = 0.0f;
    float z = 0.0f;
    float roll = 0.0f;
    float pitch = 0.0f;
    float yaw = 0.0f;
    float scale = 1;
    float scale_x = 1;
    float scale_y = 1;
    float scale_z = 1;

    // constructors
public:
    MapObject();
    MapObject(const MapObject &);
    MapObject &operator=(const MapObject &);
    MapObject(MapObject &&) = default;
    MapObject &operator=(MapObject &&) = default;
    virtual ~MapObject();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const MapObject &rhs) const;

private:
    void copyFrom(const MapObject &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::MapObject;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT Mechanoid : public IMechanoid
{
    // data
public:
    Text text_id;
    Ptr<String> name;
    Ptr<Modification> modification;
    Ptr<ModificationMap> map;
    Ptr<Clan> clan;
    Ptr<MapBuilding> building;
    Ptr<Configuration> configuration;
    Ptr<Group> group;
    int32_t generation = 0;
    float money = 0.0f;
    float rating = 0.0f;
    float rating_fight = 0.0f;
    float rating_courier = 0.0f;
    float rating_trade = 0.0f;
    float x = 0.0f;
    float y = 0.0f;
    float z = 0.0f;
    float roll = 0.0f;
    float pitch = 0.0f;
    float yaw = 0.0f;

    Ptr<CTable<MechanoidQuest>> quests;

    // constructors
public:
    Mechanoid();
    Mechanoid(const Mechanoid &);
    Mechanoid &operator=(const Mechanoid &);
    Mechanoid(Mechanoid &&) = default;
    Mechanoid &operator=(Mechanoid &&) = default;
    virtual ~Mechanoid();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Mechanoid &rhs) const;

protected:
    template <class T, class... Args>
    void initQuests(Args&&... args)
    {
        for (auto &v : *quests)
        {
            auto p = v->mechanoid.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

private:
    void copyFrom(const Mechanoid &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Mechanoid;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT MechanoidQuest : public IMechanoidQuest
{
    // data
public:
    Ptr<Mechanoid> mechanoid;
    Ptr<Quest> quest;
    int32_t state = 0;

    // constructors
public:
    MechanoidQuest();
    MechanoidQuest(const MechanoidQuest &);
    MechanoidQuest &operator=(const MechanoidQuest &);
    MechanoidQuest(MechanoidQuest &&) = default;
    MechanoidQuest &operator=(MechanoidQuest &&) = default;
    virtual ~MechanoidQuest();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const MechanoidQuest &rhs) const;
    Ptr<Mechanoid> operator->() const;

private:
    void copyFrom(const MechanoidQuest &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::MechanoidQuest;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT Modification : public IModification
{
    // data
public:
    Ptr<String> name;
    Text directory;
    Text author;
    Text date_created;
    Text date_modified;
    Text comment;
    Text version;
    Text script_language;
    Text script_main;
    Ptr<Mechanoid> player_mechanoid;
    Ptr<Configuration> cooperative_player_configuration;

    Ptr<CTable<ModificationMap>> maps;
    Ptr<CTable<Clan>> clans;
    Ptr<CTable<Mechanoid>> mechanoids;

    // constructors
public:
    Modification();
    Modification(const Modification &);
    Modification &operator=(const Modification &);
    Modification(Modification &&) = default;
    Modification &operator=(Modification &&) = default;
    virtual ~Modification();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Modification &rhs) const;

protected:
    template <class T, class... Args>
    void initMaps(Args&&... args)
    {
        for (auto &v : *maps)
        {
            auto p = v->map.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initClans(Args&&... args)
    {
        for (auto &v : *clans)
        {
            auto p = v.second.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initMechanoids(Args&&... args)
    {
        for (auto &v : *mechanoids)
        {
            auto p = v.second.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

private:
    void copyFrom(const Modification &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Modification;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT ModificationMap : public IModificationMap
{
    // data
public:
    Ptr<Modification> modification;
    Ptr<Map> map;

    // constructors
public:
    ModificationMap();
    ModificationMap(const ModificationMap &);
    ModificationMap &operator=(const ModificationMap &);
    ModificationMap(ModificationMap &&) = default;
    ModificationMap &operator=(ModificationMap &&) = default;
    virtual ~ModificationMap();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const ModificationMap &rhs) const;
    Ptr<Map> operator->() const;

private:
    void copyFrom(const ModificationMap &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::ModificationMap;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT Modificator : public IModificator
{
    // data
public:
    Text text_id;
    Text resource;
    Ptr<String> name;
    float probability = 0.0f;
    float price = 0.0f;
    float k_price = 0.0f;
    float k_param1 = 0.0f;
    float k_param2 = 0.0f;
    int32_t unicum_id = 0;
    int32_t mask = 0;

    // constructors
public:
    Modificator();
    Modificator(const Modificator &);
    Modificator &operator=(const Modificator &);
    Modificator(Modificator &&) = default;
    Modificator &operator=(Modificator &&) = default;
    virtual ~Modificator();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Modificator &rhs) const;

private:
    void copyFrom(const Modificator &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Modificator;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT Object : public IObject
{
    // data
public:
    Text text_id;
    Text resource;
    Ptr<String> name;
    int32_t type = 0;
    float scale = 1;
    float scale_x = 1;
    float scale_y = 1;
    float scale_z = 1;

    // constructors
public:
    Object();
    Object(const Object &);
    Object &operator=(const Object &);
    Object(Object &&) = default;
    Object &operator=(Object &&) = default;
    virtual ~Object();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Object &rhs) const;

private:
    void copyFrom(const Object &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Object;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT Player : public IPlayer
{
    // data
public:
    Ptr<Mechanoid> mechanoid;

    // constructors
public:
    Player();
    Player(const Player &);
    Player &operator=(const Player &);
    Player(Player &&) = default;
    Player &operator=(Player &&) = default;
    virtual ~Player();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Player &rhs) const;

private:
    void copyFrom(const Player &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Player;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT Projectile : public IProjectile
{
    // data
public:
    Text text_id;
    Text resource;
    Ptr<String> name;
    int32_t type = 0;
    int32_t subtype = 0;
    float weight = 0.0f;
    float damage = 0.0f;
    float T = 0.0f;
    float speed = 0.0f;
    float scale = 0.0f;
    int32_t numstate = 0;
    float rotate = 0.0f;
    float life_time = 0.0f;
    float detonation_delay = 0.0f;
    float distance_detonation = 0.0f;
    float strength = 0.0f;
    float price = 0.0f;
    int32_t notrade = 0;

    // constructors
public:
    Projectile();
    Projectile(const Projectile &);
    Projectile &operator=(const Projectile &);
    Projectile(Projectile &&) = default;
    Projectile &operator=(Projectile &&) = default;
    virtual ~Projectile();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Projectile &rhs) const;

private:
    void copyFrom(const Projectile &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Projectile;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT Quest : public IQuest
{
    // data
public:
    Ptr<String> name;
    Ptr<String> title;
    Ptr<String> description;
    int32_t time = 0;

    Ptr<CTable<QuestReward>> rewards;

    // constructors
public:
    Quest();
    Quest(const Quest &);
    Quest &operator=(const Quest &);
    Quest(Quest &&) = default;
    Quest &operator=(Quest &&) = default;
    virtual ~Quest();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Quest &rhs) const;

protected:
    template <class T, class... Args>
    void initRewards(Args&&... args)
    {
        for (auto &v : *rewards)
        {
            auto p = v.second.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

private:
    void copyFrom(const Quest &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Quest;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT QuestReward : public IQuestReward
{
    // data
public:
    Text text_id;
    Ptr<Quest> quest;
    float money = 0.0f;
    float rating = 0.0f;

    Ptr<CTable<QuestRewardEquipment>> equipments;
    Ptr<CTable<QuestRewardGlider>> gliders;
    Ptr<CTable<QuestRewardGood>> goods;
    Ptr<CTable<QuestRewardModificator>> modificators;
    Ptr<CTable<QuestRewardProjectile>> projectiles;
    Ptr<CTable<QuestRewardReputation>> reputations;
    Ptr<CTable<QuestRewardWeapon>> weapons;

    // constructors
public:
    QuestReward();
    QuestReward(const QuestReward &);
    QuestReward &operator=(const QuestReward &);
    QuestReward(QuestReward &&) = default;
    QuestReward &operator=(QuestReward &&) = default;
    virtual ~QuestReward();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const QuestReward &rhs) const;

protected:
    template <class T, class... Args>
    void initEquipments(Args&&... args)
    {
        for (auto &v : *equipments)
        {
            auto p = v->questReward.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initGliders(Args&&... args)
    {
        for (auto &v : *gliders)
        {
            auto p = v->questReward.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initGoods(Args&&... args)
    {
        for (auto &v : *goods)
        {
            auto p = v->questReward.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initModificators(Args&&... args)
    {
        for (auto &v : *modificators)
        {
            auto p = v->questReward.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initProjectiles(Args&&... args)
    {
        for (auto &v : *projectiles)
        {
            auto p = v->questReward.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initReputations(Args&&... args)
    {
        for (auto &v : *reputations)
        {
            auto p = v->questReward.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

    template <class T, class... Args>
    void initWeapons(Args&&... args)
    {
        for (auto &v : *weapons)
        {
            auto p = v->questReward.get();
            p->replace<T>(p, std::forward<Args>(args)...);
        }
    }

private:
    void copyFrom(const QuestReward &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::QuestReward;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT QuestRewardEquipment : public IQuestRewardEquipment
{
    // data
public:
    Ptr<QuestReward> quest_reward;
    Ptr<Equipment> equipment;
    int32_t quantity = 0;

    // constructors
public:
    QuestRewardEquipment();
    QuestRewardEquipment(const QuestRewardEquipment &);
    QuestRewardEquipment &operator=(const QuestRewardEquipment &);
    QuestRewardEquipment(QuestRewardEquipment &&) = default;
    QuestRewardEquipment &operator=(QuestRewardEquipment &&) = default;
    virtual ~QuestRewardEquipment();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const QuestRewardEquipment &rhs) const;
    Ptr<QuestReward> operator->() const;

private:
    void copyFrom(const QuestRewardEquipment &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::QuestRewardEquipment;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT QuestRewardGlider : public IQuestRewardGlider
{
    // data
public:
    Ptr<QuestReward> quest_reward;
    Ptr<Glider> glider;
    int32_t quantity = 0;

    // constructors
public:
    QuestRewardGlider();
    QuestRewardGlider(const QuestRewardGlider &);
    QuestRewardGlider &operator=(const QuestRewardGlider &);
    QuestRewardGlider(QuestRewardGlider &&) = default;
    QuestRewardGlider &operator=(QuestRewardGlider &&) = default;
    virtual ~QuestRewardGlider();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const QuestRewardGlider &rhs) const;
    Ptr<QuestReward> operator->() const;

private:
    void copyFrom(const QuestRewardGlider &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::QuestRewardGlider;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT QuestRewardGood : public IQuestRewardGood
{
    // data
public:
    Ptr<QuestReward> quest_reward;
    Ptr<Good> good;
    int32_t quantity = 0;

    // constructors
public:
    QuestRewardGood();
    QuestRewardGood(const QuestRewardGood &);
    QuestRewardGood &operator=(const QuestRewardGood &);
    QuestRewardGood(QuestRewardGood &&) = default;
    QuestRewardGood &operator=(QuestRewardGood &&) = default;
    virtual ~QuestRewardGood();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const QuestRewardGood &rhs) const;
    Ptr<QuestReward> operator->() const;

private:
    void copyFrom(const QuestRewardGood &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::QuestRewardGood;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT QuestRewardModificator : public IQuestRewardModificator
{
    // data
public:
    Ptr<QuestReward> quest_reward;
    Ptr<Modificator> modificator;
    int32_t quantity = 0;

    // constructors
public:
    QuestRewardModificator();
    QuestRewardModificator(const QuestRewardModificator &);
    QuestRewardModificator &operator=(const QuestRewardModificator &);
    QuestRewardModificator(QuestRewardModificator &&) = default;
    QuestRewardModificator &operator=(QuestRewardModificator &&) = default;
    virtual ~QuestRewardModificator();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const QuestRewardModificator &rhs) const;
    Ptr<QuestReward> operator->() const;

private:
    void copyFrom(const QuestRewardModificator &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::QuestRewardModificator;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT QuestRewardProjectile : public IQuestRewardProjectile
{
    // data
public:
    Ptr<QuestReward> quest_reward;
    Ptr<Projectile> projectile;
    int32_t quantity = 0;

    // constructors
public:
    QuestRewardProjectile();
    QuestRewardProjectile(const QuestRewardProjectile &);
    QuestRewardProjectile &operator=(const QuestRewardProjectile &);
    QuestRewardProjectile(QuestRewardProjectile &&) = default;
    QuestRewardProjectile &operator=(QuestRewardProjectile &&) = default;
    virtual ~QuestRewardProjectile();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const QuestRewardProjectile &rhs) const;
    Ptr<QuestReward> operator->() const;

private:
    void copyFrom(const QuestRewardProjectile &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::QuestRewardProjectile;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT QuestRewardReputation : public IQuestRewardReputation
{
    // data
public:
    Ptr<QuestReward> quest_reward;
    Ptr<Clan> clan;
    float quantity = 0.0f;

    // constructors
public:
    QuestRewardReputation();
    QuestRewardReputation(const QuestRewardReputation &);
    QuestRewardReputation &operator=(const QuestRewardReputation &);
    QuestRewardReputation(QuestRewardReputation &&) = default;
    QuestRewardReputation &operator=(QuestRewardReputation &&) = default;
    virtual ~QuestRewardReputation();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const QuestRewardReputation &rhs) const;
    Ptr<QuestReward> operator->() const;

private:
    void copyFrom(const QuestRewardReputation &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::QuestRewardReputation;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT QuestRewardWeapon : public IQuestRewardWeapon
{
    // data
public:
    Ptr<QuestReward> quest_reward;
    Ptr<Weapon> weapon;
    int32_t quantity = 0;

    // constructors
public:
    QuestRewardWeapon();
    QuestRewardWeapon(const QuestRewardWeapon &);
    QuestRewardWeapon &operator=(const QuestRewardWeapon &);
    QuestRewardWeapon(QuestRewardWeapon &&) = default;
    QuestRewardWeapon &operator=(QuestRewardWeapon &&) = default;
    virtual ~QuestRewardWeapon();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const QuestRewardWeapon &rhs) const;
    Ptr<QuestReward> operator->() const;

private:
    void copyFrom(const QuestRewardWeapon &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::QuestRewardWeapon;
    static const bool has_id = false;

    static const char *getSql();
};

class DLL_EXPORT ScriptVariable : public IScriptVariable
{
    // data
public:
    Text variable;
    int32_t value_int = 0;
    float value_float = 0.0f;
    Text value_text;

    // constructors
public:
    ScriptVariable();
    ScriptVariable(const ScriptVariable &);
    ScriptVariable &operator=(const ScriptVariable &);
    ScriptVariable(ScriptVariable &&) = default;
    ScriptVariable &operator=(ScriptVariable &&) = default;
    virtual ~ScriptVariable();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const ScriptVariable &rhs) const;

private:
    void copyFrom(const ScriptVariable &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::ScriptVariable;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT Setting : public ISetting
{
    // data
public:
    Text text_id;
    Ptr<Player> player;
    int32_t value_int = 0;
    float value_float = 0.0f;
    Text value_text;
    Blob value_blob;

    // constructors
public:
    Setting();
    Setting(const Setting &);
    Setting &operator=(const Setting &);
    Setting(Setting &&) = default;
    Setting &operator=(Setting &&) = default;
    virtual ~Setting();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Setting &rhs) const;

private:
    void copyFrom(const Setting &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Setting;
    static const bool has_id = true;

    static const char *getSql();
};

enum class LocalizationType : EnumType
{
    ru,
    en,

    max,
};

class DLL_EXPORT String : public IString
{
    // data
public:
    Text text_id;
    Ptr<Table> table;
    Text ru;
    Text en;

    // constructors
public:
    String();
    String(const String &);
    String &operator=(const String &);
    String(String &&) = default;
    String &operator=(String &&) = default;
    virtual ~String();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const String &rhs) const;

private:
    void copyFrom(const String &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::String;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT Table : public ITable
{
    // data
public:
    Text text;

    // constructors
public:
    Table();
    Table(const Table &);
    Table &operator=(const Table &);
    Table(Table &&) = default;
    Table &operator=(Table &&) = default;
    virtual ~Table();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Table &rhs) const;

private:
    void copyFrom(const Table &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Table;
    static const bool has_id = true;

    static const char *getSql();
};

class DLL_EXPORT Weapon : public IWeapon
{
    // data
public:
    Text text_id;
    Text resource;
    Ptr<String> name;
    Ptr<Projectile> projectile;
    int32_t type = 0;
    int32_t standard = 0;
    float weight = 0.0f;
    float power = 0.0f;
    float firerate = 0.0f;
    float damage = 0.0f;
    float price = 0.0f;
    float fx = 0.0f;
    int32_t shoottype = 0;
    float shootscale = 0.0f;
    int32_t xstate = 0;
    float rcolor = 0.0f;
    float gcolor = 0.0f;
    float bcolor = 0.0f;
    int32_t typearms = 0;
    float tfire = 0.0f;
    int32_t vtype = 0;
    float spare = 0.0f;
    float reconstruction = 0.0f;
    float maxdistance = 0.0f;
    float angle = 0.0f;
    float fxtime = 0.0f;
    int32_t damagetype = 0;
    float fxmodeltime = 0.0f;
    float inside_mul = 0.0f;
    float inside_x = 0.0f;
    float inside_y = 0.0f;
    float inside_z = 0.0f;
    int32_t notrade = 0;

    // constructors
public:
    Weapon();
    Weapon(const Weapon &);
    Weapon &operator=(const Weapon &);
    Weapon(Weapon &&) = default;
    Weapon &operator=(Weapon &&) = default;
    virtual ~Weapon();

    // functions
public:
    virtual EObjectType getType() const override;
    virtual Text getVariableString(int columnId) const override;
    virtual void setVariableString(int columnId, const Text &text) override;
    virtual void setVariableString(int columnId, IObjectBase *ptr) override;
    virtual Ptr<TreeItem> printTree() const override;
    virtual Text getName() const override;

    bool operator==(const Weapon &rhs) const;

private:
    void copyFrom(const Weapon &rhs);

private:
    friend class StorageImpl;
    template <class T> friend class CTable;

public:
    static const EObjectType object_type = EObjectType::Weapon;
    static const bool has_id = true;

    static const char *getSql();
};

} // namespace detail

} // namespace polygon4
